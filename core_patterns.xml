<?xml version="1.0" encoding="UTF-8"?>
<system>
	<pattern name="Factory Method">
		<instance>
			<role name="Creator" element="io.questdb.FactoryProviderFactory" />
			<role name="FactoryMethod()" element="io.questdb.FactoryProviderFactory::getInstance(io.questdb.ServerConfiguration, io.questdb.cairo.CairoEngine, io.questdb.griffin.FunctionFactoryCache):io.questdb.FactoryProvider" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.std.LongVec" />
			<role name="FactoryMethod()" element="io.questdb.std.LongVec::newInstance():io.questdb.std.LongVec" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.std.IOURingFacade" />
			<role name="FactoryMethod()" element="io.questdb.std.IOURingFacade::newInstance(int):io.questdb.std.IOURing" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.cutlass.auth.AuthenticatorFactory" />
			<role name="FactoryMethod()" element="io.questdb.cutlass.auth.AuthenticatorFactory::getLineTCPAuthenticator(long, long):io.questdb.cutlass.auth.Authenticator" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.cutlass.http.HttpRequestProcessorFactory" />
			<role name="FactoryMethod()" element="io.questdb.cutlass.http.HttpRequestProcessorFactory::newInstance():io.questdb.cutlass.http.HttpRequestProcessor" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.cutlass.http.HttpRequestProcessorSelector" />
			<role name="FactoryMethod()" element="io.questdb.cutlass.http.HttpRequestProcessorSelector::getDefaultProcessor():io.questdb.cutlass.http.HttpRequestProcessor" />
			<role name="FactoryMethod()" element="io.questdb.cutlass.http.HttpRequestProcessorSelector::select(java.lang.CharSequence):io.questdb.cutlass.http.HttpRequestProcessor" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.cutlass.http.HttpServerConfiguration" />
			<role name="FactoryMethod()" element="io.questdb.cutlass.http.HttpServerConfiguration::getWaitProcessorConfiguration():io.questdb.cutlass.http.WaitProcessorConfiguration" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="FactoryMethod()" element="io.questdb.cairo.sql.RecordCursor::getRecordB():io.questdb.cairo.sql.Record" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.cairo.sql.AnalyticSPI" />
			<role name="FactoryMethod()" element="io.questdb.cairo.sql.AnalyticSPI::getRecordAt(long):io.questdb.cairo.sql.Record" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.cairo.sql.SymbolTableSource" />
			<role name="FactoryMethod()" element="io.questdb.cairo.sql.SymbolTableSource::getSymbolTable(int):io.questdb.cairo.sql.SymbolTable" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.cairo.SymbolMapReader" />
			<role name="FactoryMethod()" element="io.questdb.cairo.SymbolMapReader::newSymbolTableView():io.questdb.cairo.sql.StaticSymbolTable" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.cairo.wal.MetadataService" />
			<role name="FactoryMethod()" element="io.questdb.cairo.wal.MetadataService::getUpdateOperator():io.questdb.cairo.UpdateOperator" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.griffin.model.RuntimeIntrinsicIntervalModel" />
			<role name="FactoryMethod()" element="io.questdb.griffin.model.RuntimeIntrinsicIntervalModel::calculateIntervals(io.questdb.griffin.SqlExecutionContext):io.questdb.std.LongList" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory" />
			<role name="FactoryMethod()" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory::createDataFrameCursorFor(int):io.questdb.griffin.engine.table.DataFrameRecordCursor" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.griffin.engine.functions.cast.AbstractCastToSymbolFunction" />
			<role name="FactoryMethod()" element="io.questdb.griffin.engine.functions.cast.AbstractCastToSymbolFunction::newFunc():io.questdb.griffin.engine.functions.cast.AbstractCastToSymbolFunction" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.griffin.FunctionFactory" />
			<role name="FactoryMethod()" element="io.questdb.griffin.FunctionFactory::newInstance(int, io.questdb.std.ObjList, io.questdb.std.IntList, io.questdb.cairo.CairoConfiguration, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.Function" />
		</instance>
		<instance>
			<role name="Creator" element="io.questdb.metrics.MetricsRegistry" />
			<role name="FactoryMethod()" element="io.questdb.metrics.MetricsRegistry::newCounter(java.lang.CharSequence):io.questdb.metrics.Counter" />
			<role name="FactoryMethod()" element="io.questdb.metrics.MetricsRegistry::newCounter(java.lang.CharSequence, java.lang.CharSequence, java.lang.CharSequence[]):io.questdb.metrics.CounterWithOneLabel" />
			<role name="FactoryMethod()" element="io.questdb.metrics.MetricsRegistry::newCounter(java.lang.CharSequence, java.lang.CharSequence, java.lang.CharSequence[], java.lang.CharSequence, java.lang.CharSequence[]):io.questdb.metrics.CounterWithTwoLabels" />
			<role name="FactoryMethod()" element="io.questdb.metrics.MetricsRegistry::newDoubleGauge(java.lang.CharSequence):io.questdb.metrics.DoubleGauge" />
			<role name="FactoryMethod()" element="io.questdb.metrics.MetricsRegistry::newLongGauge(java.lang.CharSequence):io.questdb.metrics.LongGauge" />
			<role name="FactoryMethod()" element="io.questdb.metrics.MetricsRegistry::newLongGauge(int):io.questdb.metrics.LongGauge" />
			<role name="FactoryMethod()" element="io.questdb.metrics.MetricsRegistry::newVirtualGauge(java.lang.CharSequence, io.questdb.metrics.VirtualLongGauge$StatProvider):io.questdb.metrics.LongGauge" />
		</instance>
	</pattern>
	<pattern name="Prototype" />
	<pattern name="Singleton">
		<instance>
			<role name="Singleton" element="io.questdb.network.PeerDisconnectedException" />
			<role name="uniqueInstance" element="io.questdb.network.PeerDisconnectedException::INSTANCE:io.questdb.network.PeerDisconnectedException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.network.PeerIsSlowToWriteException" />
			<role name="uniqueInstance" element="io.questdb.network.PeerIsSlowToWriteException::INSTANCE:io.questdb.network.PeerIsSlowToWriteException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.network.NoSpaceLeftInResponseBufferException" />
			<role name="uniqueInstance" element="io.questdb.network.NoSpaceLeftInResponseBufferException::INSTANCE:io.questdb.network.NoSpaceLeftInResponseBufferException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.network.EpollFacadeImpl" />
			<role name="uniqueInstance" element="io.questdb.network.EpollFacadeImpl::INSTANCE:io.questdb.network.EpollFacadeImpl" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.network.ServerDisconnectException" />
			<role name="uniqueInstance" element="io.questdb.network.ServerDisconnectException::INSTANCE:io.questdb.network.ServerDisconnectException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.network.PeerIsSlowToReadException" />
			<role name="uniqueInstance" element="io.questdb.network.PeerIsSlowToReadException::INSTANCE:io.questdb.network.PeerIsSlowToReadException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.NullIndexFrameCursor" />
			<role name="uniqueInstance" element="io.questdb.NullIndexFrameCursor::INSTANCE:io.questdb.NullIndexFrameCursor" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.std.NumericException" />
			<role name="uniqueInstance" element="io.questdb.std.NumericException::INSTANCE:io.questdb.std.NumericException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.std.StationaryMillisClock" />
			<role name="uniqueInstance" element="io.questdb.std.StationaryMillisClock::INSTANCE:io.questdb.std.StationaryMillisClock" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.std.str.StdoutSink" />
			<role name="uniqueInstance" element="io.questdb.std.str.StdoutSink::INSTANCE:io.questdb.std.str.StdoutSink" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.std.IOURingFacadeImpl" />
			<role name="uniqueInstance" element="io.questdb.std.IOURingFacadeImpl::INSTANCE:io.questdb.std.IOURingFacadeImpl" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.std.datetime.TimeZoneRuleFactory" />
			<role name="uniqueInstance" element="io.questdb.std.datetime.TimeZoneRuleFactory::INSTANCE:io.questdb.std.datetime.TimeZoneRuleFactory" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.std.datetime.DateLocaleFactory" />
			<role name="uniqueInstance" element="io.questdb.std.datetime.DateLocaleFactory::INSTANCE:io.questdb.std.datetime.DateLocaleFactory" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.std.ex.BytecodeException" />
			<role name="uniqueInstance" element="io.questdb.std.ex.BytecodeException::INSTANCE:io.questdb.std.ex.BytecodeException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.std.ex.ZLibException" />
			<role name="uniqueInstance" element="io.questdb.std.ex.ZLibException::INSTANCE:io.questdb.std.ex.ZLibException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.line.LineProtoMicroTimestampAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.line.LineProtoMicroTimestampAdapter::INSTANCE:io.questdb.cutlass.line.LineProtoMicroTimestampAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.line.LineProtoHourTimestampAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.line.LineProtoHourTimestampAdapter::INSTANCE:io.questdb.cutlass.line.LineProtoHourTimestampAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.line.LineProtoNanoTimestampAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.line.LineProtoNanoTimestampAdapter::INSTANCE:io.questdb.cutlass.line.LineProtoNanoTimestampAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.line.LineProtoException" />
			<role name="uniqueInstance" element="io.questdb.cutlass.line.LineProtoException::INSTANCE:io.questdb.cutlass.line.LineProtoException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.line.LineProtoSecondTimestampAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.line.LineProtoSecondTimestampAdapter::INSTANCE:io.questdb.cutlass.line.LineProtoSecondTimestampAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.line.udp.Utf8RepairContinue" />
			<role name="uniqueInstance" element="io.questdb.cutlass.line.udp.Utf8RepairContinue::INSTANCE:io.questdb.cutlass.line.udp.Utf8RepairContinue" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.line.udp.LineUdpParserSupport$BadCastException" />
			<role name="uniqueInstance" element="io.questdb.cutlass.line.udp.LineUdpParserSupport$BadCastException::INSTANCE:io.questdb.cutlass.line.udp.LineUdpParserSupport$BadCastException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.line.LineProtoMinuteTimestampAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.line.LineProtoMinuteTimestampAdapter::INSTANCE:io.questdb.cutlass.line.LineProtoMinuteTimestampAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.line.LineProtoMilliTimestampAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.line.LineProtoMilliTimestampAdapter::INSTANCE:io.questdb.cutlass.line.LineProtoMilliTimestampAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.auth.AnonymousAuthenticator" />
			<role name="uniqueInstance" element="io.questdb.cutlass.auth.AnonymousAuthenticator::INSTANCE:io.questdb.cutlass.auth.AnonymousAuthenticator" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.auth.AuthenticatorException" />
			<role name="uniqueInstance" element="io.questdb.cutlass.auth.AuthenticatorException::INSTANCE:io.questdb.cutlass.auth.AuthenticatorException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.Utf8Exception" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.Utf8Exception::INSTANCE:io.questdb.cutlass.text.Utf8Exception" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.AbstractTextLexer$LineLimitException" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.AbstractTextLexer$LineLimitException::INSTANCE:io.questdb.cutlass.text.AbstractTextLexer$LineLimitException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.IntAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.IntAdapter::INSTANCE:io.questdb.cutlass.text.types.IntAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.BooleanAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.BooleanAdapter::INSTANCE:io.questdb.cutlass.text.types.BooleanAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.ShortAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.ShortAdapter::INSTANCE:io.questdb.cutlass.text.types.ShortAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.DoubleAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.DoubleAdapter::INSTANCE:io.questdb.cutlass.text.types.DoubleAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.FloatAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.FloatAdapter::INSTANCE:io.questdb.cutlass.text.types.FloatAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.BadDateAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.BadDateAdapter::INSTANCE:io.questdb.cutlass.text.types.BadDateAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.ByteAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.ByteAdapter::INSTANCE:io.questdb.cutlass.text.types.ByteAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.UuidAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.UuidAdapter::INSTANCE:io.questdb.cutlass.text.types.UuidAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.BadTimestampAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.BadTimestampAdapter::INSTANCE:io.questdb.cutlass.text.types.BadTimestampAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.CharAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.CharAdapter::INSTANCE:io.questdb.cutlass.text.types.CharAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.LongAdapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.LongAdapter::INSTANCE:io.questdb.cutlass.text.types.LongAdapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.text.types.Long256Adapter" />
			<role name="uniqueInstance" element="io.questdb.cutlass.text.types.Long256Adapter::INSTANCE:io.questdb.cutlass.text.types.Long256Adapter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.http.ex.TooFewBytesReceivedException" />
			<role name="uniqueInstance" element="io.questdb.cutlass.http.ex.TooFewBytesReceivedException::INSTANCE:io.questdb.cutlass.http.ex.TooFewBytesReceivedException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.http.ex.BufferOverflowException" />
			<role name="uniqueInstance" element="io.questdb.cutlass.http.ex.BufferOverflowException::INSTANCE:io.questdb.cutlass.http.ex.BufferOverflowException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.http.ex.RetryFailedOperationException" />
			<role name="uniqueInstance" element="io.questdb.cutlass.http.ex.RetryFailedOperationException::INSTANCE:io.questdb.cutlass.http.ex.RetryFailedOperationException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.http.ex.RetryOperationException" />
			<role name="uniqueInstance" element="io.questdb.cutlass.http.ex.RetryOperationException::INSTANCE:io.questdb.cutlass.http.ex.RetryOperationException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.pgwire.AuthenticationException" />
			<role name="uniqueInstance" element="io.questdb.cutlass.pgwire.AuthenticationException::INSTANCE:io.questdb.cutlass.pgwire.AuthenticationException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cutlass.pgwire.BadProtocolException" />
			<role name="uniqueInstance" element="io.questdb.cutlass.pgwire.BadProtocolException::INSTANCE:io.questdb.cutlass.pgwire.BadProtocolException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.mp.OpenBarrier" />
			<role name="uniqueInstance" element="io.questdb.mp.OpenBarrier::INSTANCE:io.questdb.mp.OpenBarrier" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.mp.AlertedException" />
			<role name="uniqueInstance" element="io.questdb.mp.AlertedException::INSTANCE:io.questdb.mp.AlertedException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.mp.NullWaitStrategy" />
			<role name="uniqueInstance" element="io.questdb.mp.NullWaitStrategy::INSTANCE:io.questdb.mp.NullWaitStrategy" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.mp.TimeoutException" />
			<role name="uniqueInstance" element="io.questdb.mp.TimeoutException::INSTANCE:io.questdb.mp.TimeoutException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.BuildInformationHolder" />
			<role name="uniqueInstance" element="io.questdb.BuildInformationHolder::INSTANCE:io.questdb.BuildInformationHolder" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.DefaultFactoryProvider" />
			<role name="uniqueInstance" element="io.questdb.DefaultFactoryProvider::INSTANCE:io.questdb.DefaultFactoryProvider" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.sql.WriterOutOfDateException" />
			<role name="uniqueInstance" element="io.questdb.cairo.sql.WriterOutOfDateException::INSTANCE:io.questdb.cairo.sql.WriterOutOfDateException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.sql.InvalidColumnException" />
			<role name="uniqueInstance" element="io.questdb.cairo.sql.InvalidColumnException::INSTANCE:io.questdb.cairo.sql.InvalidColumnException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="uniqueInstance" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker::NOOP_CIRCUIT_BREAKER:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.pool.ex.PoolClosedException" />
			<role name="uniqueInstance" element="io.questdb.cairo.pool.ex.PoolClosedException::INSTANCE:io.questdb.cairo.pool.ex.PoolClosedException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.SymbolValueCountCollector" />
			<role name="uniqueInstance" element="io.questdb.cairo.SymbolValueCountCollector::NOOP:io.questdb.cairo.SymbolValueCountCollector" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.security.AllowAllSecurityContextFactory" />
			<role name="uniqueInstance" element="io.questdb.cairo.security.AllowAllSecurityContextFactory::INSTANCE:io.questdb.cairo.security.AllowAllSecurityContextFactory" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.security.AllowAllSecurityContext" />
			<role name="uniqueInstance" element="io.questdb.cairo.security.AllowAllSecurityContext::INSTANCE:io.questdb.cairo.security.AllowAllSecurityContext" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.security.ReadOnlySecurityContext" />
			<role name="uniqueInstance" element="io.questdb.cairo.security.ReadOnlySecurityContext::INSTANCE:io.questdb.cairo.security.ReadOnlySecurityContext" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.security.DenyAllSecurityContext" />
			<role name="uniqueInstance" element="io.questdb.cairo.security.DenyAllSecurityContext::INSTANCE:io.questdb.cairo.security.DenyAllSecurityContext" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.DefaultLifecycleManager" />
			<role name="uniqueInstance" element="io.questdb.cairo.DefaultLifecycleManager::INSTANCE:io.questdb.cairo.DefaultLifecycleManager" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.vm.NullMemoryMR" />
			<role name="uniqueInstance" element="io.questdb.cairo.vm.NullMemoryMR::INSTANCE:io.questdb.cairo.vm.NullMemoryMR" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.vm.api.NullMemory" />
			<role name="uniqueInstance" element="io.questdb.cairo.vm.api.NullMemory::INSTANCE:io.questdb.cairo.vm.api.NullMemory" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.IndexFrame" />
			<role name="uniqueInstance" element="io.questdb.cairo.IndexFrame::NULL_INSTANCE:io.questdb.cairo.IndexFrame" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.AlterTableContextException" />
			<role name="uniqueInstance" element="io.questdb.cairo.AlterTableContextException::INSTANCE:io.questdb.cairo.AlterTableContextException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.wal.BasicWalInitializerFactory" />
			<role name="uniqueInstance" element="io.questdb.cairo.wal.BasicWalInitializerFactory::INSTANCE:io.questdb.cairo.wal.BasicWalInitializerFactory" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.wal.BasicWalInitializer" />
			<role name="uniqueInstance" element="io.questdb.cairo.wal.BasicWalInitializer::INSTANCE:io.questdb.cairo.wal.BasicWalInitializer" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.cairo.EmptySymbolMapReader" />
			<role name="uniqueInstance" element="io.questdb.cairo.EmptySymbolMapReader::INSTANCE:io.questdb.cairo.EmptySymbolMapReader" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.log.LogFactory" />
			<role name="uniqueInstance" element="io.questdb.log.LogFactory::INSTANCE:io.questdb.log.LogFactory" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.log.NullLogRecord" />
			<role name="uniqueInstance" element="io.questdb.log.NullLogRecord::INSTANCE:io.questdb.log.NullLogRecord" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.EmptyRecordMetadata" />
			<role name="uniqueInstance" element="io.questdb.griffin.EmptyRecordMetadata::INSTANCE:io.questdb.griffin.EmptyRecordMetadata" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.AnyRecordMetadata" />
			<role name="uniqueInstance" element="io.questdb.griffin.AnyRecordMetadata::INSTANCE:io.questdb.griffin.AnyRecordMetadata" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.QueryFutureUpdateListener" />
			<role name="uniqueInstance" element="io.questdb.griffin.QueryFutureUpdateListener::EMPTY:io.questdb.griffin.QueryFutureUpdateListener" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.EmptyTableRecordCursor" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.EmptyTableRecordCursor::INSTANCE:io.questdb.griffin.engine.EmptyTableRecordCursor" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.EmptyTableRandomRecordCursor" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.EmptyTableRandomRecordCursor::INSTANCE:io.questdb.griffin.engine.EmptyTableRandomRecordCursor" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.EmptyTableNoSizeRecordCursor" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.EmptyTableNoSizeRecordCursor::INSTANCE:io.questdb.griffin.engine.EmptyTableNoSizeRecordCursor" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.table.NoMoreFramesException" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.table.NoMoreFramesException::INSTANCE:io.questdb.griffin.engine.table.NoMoreFramesException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.LongTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.LongTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.LongTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.DoubleTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.DoubleTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.DoubleTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.Long128Constant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.Long128Constant::NULL:io.questdb.griffin.engine.functions.constants.Long128Constant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.ByteConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.ByteConstant::ZERO:io.questdb.griffin.engine.functions.constants.ByteConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.GeoLongConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.GeoLongConstant::NULL:io.questdb.griffin.engine.functions.constants.GeoLongConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.CharTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.CharTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.CharTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.FloatTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.FloatTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.FloatTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.ShortTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.ShortTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.ShortTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.GeoShortConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.GeoShortConstant::NULL:io.questdb.griffin.engine.functions.constants.GeoShortConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.IntConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.IntConstant::NULL:io.questdb.griffin.engine.functions.constants.IntConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.GeoIntConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.GeoIntConstant::NULL:io.questdb.griffin.engine.functions.constants.GeoIntConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.ShortConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.ShortConstant::ZERO:io.questdb.griffin.engine.functions.constants.ShortConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.TimestampTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.TimestampTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.TimestampTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.ByteTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.ByteTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.ByteTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.RegProcedureTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.RegProcedureTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.RegProcedureTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.DateTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.DateTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.DateTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.Long256NullConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.Long256NullConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.Long256NullConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.StringArrayTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.StringArrayTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.StringArrayTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.BooleanTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.BooleanTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.BooleanTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.StrTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.StrTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.StrTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.IntTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.IntTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.IntTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.Long256TypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.Long256TypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.Long256TypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.TimestampConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.TimestampConstant::NULL:io.questdb.griffin.engine.functions.constants.TimestampConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.SymbolTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.SymbolTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.SymbolTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.NullConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.NullConstant::NULL:io.questdb.griffin.engine.functions.constants.NullConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.DoubleConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.DoubleConstant::NULL:io.questdb.griffin.engine.functions.constants.DoubleConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.FloatConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.FloatConstant::NULL:io.questdb.griffin.engine.functions.constants.FloatConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.DateConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.DateConstant::NULL:io.questdb.griffin.engine.functions.constants.DateConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.CharConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.CharConstant::ZERO:io.questdb.griffin.engine.functions.constants.CharConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.RegClassTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.RegClassTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.RegClassTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.UuidConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.UuidConstant::NULL:io.questdb.griffin.engine.functions.constants.UuidConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.UuidTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.UuidTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.UuidTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.NullBinConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.NullBinConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.NullBinConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.GeoByteConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.GeoByteConstant::NULL:io.questdb.griffin.engine.functions.constants.GeoByteConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.constants.BinTypeConstant" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.constants.BinTypeConstant::INSTANCE:io.questdb.griffin.engine.functions.constants.BinTypeConstant" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.engine.functions.test.TestNPEFactory$NPEFunction" />
			<role name="uniqueInstance" element="io.questdb.griffin.engine.functions.test.TestNPEFactory$NPEFunction::INSTANCE:io.questdb.griffin.engine.functions.test.TestNPEFactory$NPEFunction" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.griffin.SqlOptimiser$NonLiteralException" />
			<role name="uniqueInstance" element="io.questdb.griffin.SqlOptimiser$NonLiteralException::INSTANCE:io.questdb.griffin.SqlOptimiser$NonLiteralException" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.metrics.NullCounter" />
			<role name="uniqueInstance" element="io.questdb.metrics.NullCounter::INSTANCE:io.questdb.metrics.NullCounter" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.metrics.NullLongGauge" />
			<role name="uniqueInstance" element="io.questdb.metrics.NullLongGauge::INSTANCE:io.questdb.metrics.NullLongGauge" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.metrics.DoubleGauge" />
			<role name="uniqueInstance" element="io.questdb.metrics.DoubleGauge::INSTANCE:io.questdb.metrics.DoubleGauge" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.test.std.TestFilesFacadeImpl" />
			<role name="uniqueInstance" element="io.questdb.test.std.TestFilesFacadeImpl::INSTANCE:io.questdb.test.std.TestFilesFacadeImpl" />
		</instance>
		<instance>
			<role name="Singleton" element="io.questdb.test.tools.StationaryMicrosClock" />
			<role name="uniqueInstance" element="io.questdb.test.tools.StationaryMicrosClock::INSTANCE:io.questdb.test.tools.StationaryMicrosClock" />
		</instance>
	</pattern>
	<pattern name="(Object)Adapter">
		<instance>
			<role name="Adaptee" element="io.questdb.std.LongLongHashSet$SinkStrategy" />
			<role name="Adapter" element="io.questdb.std.LongLongHashSet" />
			<role name="adaptee" element="io.questdb.std.LongLongHashSet::sinkStrategy:io.questdb.std.LongLongHashSet$SinkStrategy" />
			<role name="Request()" element="io.questdb.std.LongLongHashSet::toSink(io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cutlass.http.HttpHeaderParser$BoundaryAugmenter" />
			<role name="Adapter" element="io.questdb.cutlass.http.HttpHeaderParser" />
			<role name="adaptee" element="io.questdb.cutlass.http.HttpHeaderParser::boundaryAugmenter:io.questdb.cutlass.http.HttpHeaderParser$BoundaryAugmenter" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpHeaderParser::getBoundary():io.questdb.std.str.DirectByteCharSequence" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.Uuid" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.bind.UuidBindVariable" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.bind.UuidBindVariable::value:io.questdb.std.Uuid" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bind.UuidBindVariable::clear():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.Long256Impl" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.bind.Long256BindVariable" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.bind.Long256BindVariable::value:io.questdb.std.Long256Impl" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bind.Long256BindVariable::clear():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.AvgDoubleGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.AvgDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.AvgDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.AvgDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstByteGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstByteGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstByteGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstCharGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstCharGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstCharGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstDateGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstDateGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstDateGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstDoubleGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstFloatGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstFloatGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstFloatGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionByte" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionByte::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionByte::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionInt" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionInt::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionInt::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionLong" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionLong::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionLong::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionShort" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionShort::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionShort::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstIntGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstIntGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstIntGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstLongGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstLongGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstLongGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstShortGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstShortGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstShortGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstTimestampGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstTimestampGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstTimestampGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.FirstUuidGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.FirstUuidGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstUuidGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction::latDegree:io.questdb.cairo.sql.Function" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction::lonDegree:io.questdb.cairo.sql.Function" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction::timestamp:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.IsLongOrderedGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.IsLongOrderedGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.IsLongOrderedGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.IsLongOrderedGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.KSumDoubleGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.KSumDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.KSumDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.KSumDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MaxCharGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MaxCharGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxCharGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxCharGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MaxDateGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MaxDateGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxDateGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxDateGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MaxDoubleGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MaxDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MaxFloatGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MaxFloatGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxFloatGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxFloatGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MaxIntGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MaxIntGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxIntGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxIntGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MaxLongGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MaxLongGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxLongGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxLongGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MaxStrGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MaxStrGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxStrGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxStrGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MaxTimestampGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MaxTimestampGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxTimestampGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxTimestampGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MinCharGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MinCharGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinCharGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinCharGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MinDateGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MinDateGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinDateGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinDateGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MinDoubleGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MinDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MinFloatGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MinFloatGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinFloatGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinFloatGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MinIntGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MinIntGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinIntGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinIntGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MinLongGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MinLongGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinLongGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinLongGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MinStrGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MinStrGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinStrGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinStrGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MinTimestampGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MinTimestampGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinTimestampGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinTimestampGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.NSumDoubleGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.NSumDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.NSumDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.NSumDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.StdDevSampleDoubleGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.StdDevSampleDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.StdDevSampleDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.StdDevSampleDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.StringAggGroupByFunctionFactory$StringAggGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.StringAggGroupByFunctionFactory$StringAggGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.StringAggGroupByFunctionFactory$StringAggGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.StringAggGroupByFunctionFactory$StringAggGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.SumDoubleGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.SumDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.SumFloatGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.SumFloatGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumFloatGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumFloatGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.SumIntGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.SumIntGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumIntGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumIntGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.SumLong256GroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.SumLong256GroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumLong256GroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumLong256GroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.SumLongGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.SumLongGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumLongGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumLongGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.test.TestSumDoubleGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.test.TestSumDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.test.TestSumStringGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.test.TestSumStringGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumStringGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumStringGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.test.TestSumTDoubleGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.test.TestSumTDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumTDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumTDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory::addFunctions:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory::newInstance(int, io.questdb.std.ObjList, io.questdb.std.IntList, io.questdb.cairo.CairoConfiguration, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.Function" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory::diffFunctions:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory::newInstance(int, io.questdb.std.ObjList, io.questdb.std.IntList, io.questdb.cairo.CairoConfiguration, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.Function" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction::sets:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction::sets:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction::sets:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction::sets:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction::sets:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction::sets:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MaxStrGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MaxStrGroupByFunction::sinks:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxStrGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.groupby.MinStrGroupByFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.groupby.MinStrGroupByFunction::sinks:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinStrGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.ListFunctionFactory$Func" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.ListFunctionFactory$Func::symbols:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.ListFunctionFactory$Func::getSymbol(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndStringListFunctionFactory$Func" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndStringListFunctionFactory$Func::symbols:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndStringListFunctionFactory$Func::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndSymbolListFunctionFactory$Func" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndSymbolListFunctionFactory$Func::symbols:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndSymbolListFunctionFactory$Func::getSymbol(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.RingQueue" />
			<role name="Adapter" element="io.questdb.cutlass.text.CopyRequestJob" />
			<role name="adaptee" element="io.questdb.cutlass.text.CopyRequestJob::requestQueue:io.questdb.mp.RingQueue" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyRequestJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.RingQueue" />
			<role name="Adapter" element="io.questdb.network.AbstractIODispatcher" />
			<role name="adaptee" element="io.questdb.network.AbstractIODispatcher::disconnectQueue:io.questdb.mp.RingQueue" />
			<role name="adaptee" element="io.questdb.network.AbstractIODispatcher::ioEventQueue:io.questdb.mp.RingQueue" />
			<role name="adaptee" element="io.questdb.network.AbstractIODispatcher::interestQueue:io.questdb.mp.RingQueue" />
			<role name="Request()" element="io.questdb.network.AbstractIODispatcher::disconnect(C, int):void" />
			<role name="Request()" element="io.questdb.network.AbstractIODispatcher::processIOQueue(io.questdb.network.IORequestProcessor):boolean" />
			<role name="Request()" element="io.questdb.network.AbstractIODispatcher::registerChannel(C, int):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndStringRndListFunctionFactory$Func" />
			<role name="Adaptee" element="io.questdb.griffin.engine.functions.rnd.RndStringMemory" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndStringRndListFunctionFactory$Func::strMem:io.questdb.griffin.engine.functions.rnd.RndStringMemory" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndStringRndListFunctionFactory$Func::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndStringRndListFunctionFactory$Func::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndSymbolFunctionFactory$Func" />
			<role name="Adaptee" element="io.questdb.griffin.engine.functions.rnd.RndStringMemory" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndSymbolFunctionFactory$Func::strMem:io.questdb.griffin.engine.functions.rnd.RndStringMemory" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndSymbolFunctionFactory$Func::getSymbol(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.CountVectorAggregateFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.CountVectorAggregateFunction$CountFunc" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.CountVectorAggregateFunction::countFunc:io.questdb.griffin.engine.groupby.vect.CountVectorAggregateFunction$CountFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.CountVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.catalogue.TypeOfFunctionFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.catalogue.TypeOfFunctionFactory::NULL:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.TypeOfFunctionFactory::newInstance(int, io.questdb.std.ObjList, io.questdb.std.IntList, io.questdb.cairo.CairoConfiguration, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.Function" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.Long256Impl" />
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction::sumA:io.questdb.std.Long256Impl" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction::wrapUp(long):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState" />
			<role name="Adaptee" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="adaptee" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::recordCursorFactory:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::clear():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.http.processors.TextQueryProcessorState" />
			<role name="Adaptee" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="adaptee" element="io.questdb.cutlass.http.processors.TextQueryProcessorState::recordCursorFactory:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessorState::clear():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.AtomicIntList" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalWriter" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalWriter::initialSymbolCounts:io.questdb.std.AtomicIntList" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::getSymbolCountWatermark(int):int" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.wal.WalWriterEvents" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalWriter" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalWriter::events:io.questdb.cairo.wal.WalWriterEvents" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::commit():long" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::truncateSoft():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.text.ParallelCsvFileImporter" />
			<role name="Adaptee" element="io.questdb.std.str.StringSink" />
			<role name="adaptee" element="io.questdb.cutlass.text.ParallelCsvFileImporter::partitionNameSink:io.questdb.std.str.StringSink" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::clear():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.text.TextMetadataDetector" />
			<role name="Adaptee" element="io.questdb.std.str.StringSink" />
			<role name="adaptee" element="io.questdb.cutlass.text.TextMetadataDetector::tempSink:io.questdb.std.str.StringSink" />
			<role name="Request()" element="io.questdb.cutlass.text.TextMetadataDetector::clear():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState" />
			<role name="Adaptee" element="io.questdb.std.str.StringSink" />
			<role name="adaptee" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::query:io.questdb.std.str.StringSink" />
			<role name="adaptee" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::columnsQueryParameter:io.questdb.std.str.StringSink" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::clear():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::symbolMapWriters:io.questdb.std.ObjList" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::indexers:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int, int, boolean, boolean, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addIndex(java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::changeCacheFlag(int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::dropIndex(java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.LongList" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::partitionRemoveCandidates:io.questdb.std.LongList" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::rollback():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.ColumnVersionWriter" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::columnVersionWriter:io.questdb.cairo.ColumnVersionWriter" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::rollback():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int, int, boolean, boolean, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addIndex(java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::detachPartition(long):io.questdb.cairo.AttachDetachStatus" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableWriterMetadata" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::metadata:io.questdb.cairo.TableWriterMetadata" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::ic():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int, int, boolean, boolean, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addIndex(java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::detachPartition(long):io.questdb.cairo.AttachDetachStatus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::dropIndex(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::getMetaMaxUncommittedRows():long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeColumn(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::renameColumn(java.lang.CharSequence, java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::setMetaMaxUncommittedRows(int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::setMetaO3MaxLag(long):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TxWriter" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::txWriter:io.questdb.cairo.TxWriter" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::getMetadataVersion():long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::newRow(long):io.questdb.cairo.TableWriter$Row" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::rollback():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int, int, boolean, boolean, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addIndex(java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::detachPartition(long):io.questdb.cairo.AttachDetachStatus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::dropIndex(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeColumn(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removePartition(long):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.log.SyncLogger" />
			<role name="Adaptee" element="io.questdb.std.ThreadLocal" />
			<role name="adaptee" element="io.questdb.log.SyncLogger::line:io.questdb.std.ThreadLocal" />
			<role name="Request()" element="io.questdb.log.SyncLogger::$():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.log.Logger" />
			<role name="Adaptee" element="io.questdb.log.Logger$ThreadLocalCursor" />
			<role name="adaptee" element="io.questdb.log.Logger::tl:io.questdb.log.Logger$ThreadLocalCursor" />
			<role name="Request()" element="io.questdb.log.Logger::$():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IntList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::pages:io.questdb.std.IntList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IntList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::pages:io.questdb.std.IntList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IntList" />
			<role name="Adapter" element="io.questdb.griffin.UpdateOperatorImpl" />
			<role name="adaptee" element="io.questdb.griffin.UpdateOperatorImpl::updateColumnIndexes:io.questdb.std.IntList" />
			<role name="Request()" element="io.questdb.griffin.UpdateOperatorImpl::executeUpdate(io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.engine.ops.UpdateOperation):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.UpdateOperatorImpl" />
			<role name="adaptee" element="io.questdb.griffin.UpdateOperatorImpl::srcColumns:io.questdb.std.ObjList" />
			<role name="adaptee" element="io.questdb.griffin.UpdateOperatorImpl::dstColumns:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.UpdateOperatorImpl::executeUpdate(io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.engine.ops.UpdateOperation):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.LongList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::topsRemaining:io.questdb.std.LongList" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::columnPageAddress:io.questdb.std.LongList" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::columnPageNextAddress:io.questdb.std.LongList" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::pageRowsRemaining:io.questdb.std.LongList" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::pageSizes:io.questdb.std.LongList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.LongList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::topsRemaining:io.questdb.std.LongList" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::columnPageAddress:io.questdb.std.LongList" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::columnPageNextAddress:io.questdb.std.LongList" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::pageRowsRemaining:io.questdb.std.LongList" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::pageSizes:io.questdb.std.LongList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="Adaptee" element="io.questdb.griffin.DropIndexOperator" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::dropIndexOperator:io.questdb.griffin.DropIndexOperator" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::dropIndex(java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.text.CopyRequestJob" />
			<role name="Adaptee" element="io.questdb.cutlass.text.CopyContext" />
			<role name="adaptee" element="io.questdb.cutlass.text.CopyRequestJob::copyContext:io.questdb.cutlass.text.CopyContext" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyRequestJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.text.CopyRequestJob" />
			<role name="Adaptee" element="io.questdb.cutlass.text.CopyRequestTask" />
			<role name="adaptee" element="io.questdb.cutlass.text.CopyRequestJob::task:io.questdb.cutlass.text.CopyRequestTask" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyRequestJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.text.CopyRequestJob" />
			<role name="Adaptee" element="io.questdb.cutlass.text.ParallelCsvFileImporter" />
			<role name="adaptee" element="io.questdb.cutlass.text.CopyRequestJob::parallelImporter:io.questdb.cutlass.text.ParallelCsvFileImporter" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyRequestJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cairo.wal.ApplyWal2TableJob" />
			<role name="Adaptee" element="io.questdb.std.IntLongHashMap" />
			<role name="adaptee" element="io.questdb.cairo.wal.ApplyWal2TableJob::lastAppliedSeqTxns:io.questdb.std.IntLongHashMap" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::doRun(int, long, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory" />
			<role name="Adaptee" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory::cursor:io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.PurgingOperator" />
			<role name="Adapter" element="io.questdb.griffin.UpdateOperatorImpl" />
			<role name="adaptee" element="io.questdb.griffin.UpdateOperatorImpl::purgingOperator:io.questdb.griffin.PurgingOperator" />
			<role name="Request()" element="io.questdb.griffin.UpdateOperatorImpl::executeUpdate(io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.engine.ops.UpdateOperation):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.str.StringSink" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.bind.StrBindVariable" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.bind.StrBindVariable::sink:io.questdb.std.str.StringSink" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bind.StrBindVariable::clear():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.VirtualRecord" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$RankFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$RankFunction::partitionByRecord:io.questdb.cairo.sql.VirtualRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$RankFunction::pass1(io.questdb.cairo.sql.Record, long, io.questdb.cairo.sql.AnalyticSPI):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.VirtualRecord" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.analytic.RowNumberFunctionFactory$RowNumberFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.analytic.RowNumberFunctionFactory$RowNumberFunction::partitionByRecord:io.questdb.cairo.sql.VirtualRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.analytic.RowNumberFunctionFactory$RowNumberFunction::pass1(io.questdb.cairo.sql.Record, long, io.questdb.cairo.sql.AnalyticSPI):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjHashSet" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.catalogue.WalTableListFunctionFactory$WalTableListCursorFactory$TableListRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.catalogue.WalTableListFunctionFactory$WalTableListCursorFactory$TableListRecordCursor::tableBucket:io.questdb.std.ObjHashSet" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.WalTableListFunctionFactory$WalTableListCursorFactory$TableListRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.map.CompactMapCursor" />
			<role name="Adapter" element="io.questdb.cairo.map.CompactMap" />
			<role name="adaptee" element="io.questdb.cairo.map.CompactMap::cursor:io.questdb.cairo.map.CompactMapCursor" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMap::getCursor():io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.map.FastMap" />
			<role name="Adapter" element="io.questdb.cairo.map.FastMapCursor" />
			<role name="adaptee" element="io.questdb.cairo.map.FastMap::cursor:io.questdb.cairo.map.FastMapCursor" />
			<role name="adaptee" element="io.questdb.cairo.map.FastMapCursor::map:io.questdb.cairo.map.FastMap" />
			<role name="Request()" element="io.questdb.cairo.map.FastMap::getCursor():io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.cairo.map.FastMapCursor::close():void" />
			<role name="Request()" element="io.questdb.cairo.map.FastMapCursor::size():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.async.PageFrameSequence" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::frameSequence:io.questdb.cairo.sql.async.PageFrameSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.async.PageFrameSequence" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::frameSequence:io.questdb.cairo.sql.async.PageFrameSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.wal.WalReader" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalDataCursor" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalDataCursor::reader:io.questdb.cairo.wal.WalReader" />
			<role name="Request()" element="io.questdb.cairo.wal.WalDataCursor::size():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.FilterOnValuesRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FilterOnValuesRecordCursorFactory::cursorFactories:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnValuesRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cutlass.line.udp.CharSequenceCache" />
			<role name="Adapter" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$TableStructureAdapter" />
			<role name="adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$TableStructureAdapter::cache:io.questdb.cutlass.line.udp.CharSequenceCache" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$TableStructureAdapter::getTableName():java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cairo.ptt.IsoDatePartitionFormat" />
			<role name="Adaptee" element="io.questdb.cairo.PartitionBy$PartitionFloorMethod" />
			<role name="adaptee" element="io.questdb.cairo.ptt.IsoDatePartitionFormat::floorMethod:io.questdb.cairo.PartitionBy$PartitionFloorMethod" />
			<role name="Request()" element="io.questdb.cairo.ptt.IsoDatePartitionFormat::format(long, io.questdb.std.datetime.DateLocale, java.lang.CharSequence, io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.cairo.O3PartitionPurgeJob" />
			<role name="adaptee" element="io.questdb.cairo.O3PartitionPurgeJob::partitionList:io.questdb.std.ObjList" />
			<role name="adaptee" element="io.questdb.cairo.O3PartitionPurgeJob::txnScoreboards:io.questdb.std.ObjList" />
			<role name="adaptee" element="io.questdb.cairo.O3PartitionPurgeJob::txnReaders:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.cairo.O3PartitionPurgeJob::doRun(int, long, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.TemplateParser" />
			<role name="Adapter" element="io.questdb.log.LogRollingFileWriter" />
			<role name="adaptee" element="io.questdb.log.LogRollingFileWriter::locationParser:io.questdb.log.TemplateParser" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::bindProperties(io.questdb.log.LogFactory):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.HttpLogRecordSink" />
			<role name="Adapter" element="io.questdb.log.LogAlertSocketWriter" />
			<role name="adaptee" element="io.questdb.log.LogAlertSocketWriter::alertSink:io.questdb.log.HttpLogRecordSink" />
			<role name="Request()" element="io.questdb.log.LogAlertSocketWriter::bindProperties(io.questdb.log.LogFactory):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.str.Path" />
			<role name="Adapter" element="io.questdb.log.LogRollingFileWriter" />
			<role name="adaptee" element="io.questdb.log.LogRollingFileWriter::path:io.questdb.std.str.Path" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::bindProperties(io.questdb.log.LogFactory):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.PageAddressCacheRecord" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::record:io.questdb.cairo.sql.PageAddressCacheRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.PageAddressCacheRecord" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::record:io.questdb.cairo.sql.PageAddressCacheRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.RecordChain$RecordChainRecord" />
			<role name="Adapter" element="io.questdb.cairo.RecordChain" />
			<role name="adaptee" element="io.questdb.cairo.RecordChain::recordA:io.questdb.cairo.RecordChain$RecordChainRecord" />
			<role name="adaptee" element="io.questdb.cairo.RecordChain::recordC:io.questdb.cairo.RecordChain$RecordChainRecord" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::hasNext():boolean" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::getRecordAt(long):io.questdb.cairo.sql.Record" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableReaderRecord" />
			<role name="Adapter" element="io.questdb.cairo.TableReaderRecordCursor" />
			<role name="adaptee" element="io.questdb.cairo.TableReaderRecordCursor::recordA:io.questdb.cairo.TableReaderRecord" />
			<role name="Request()" element="io.questdb.cairo.TableReaderRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.cairo.TableReaderRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableReaderSelectedColumnRecord" />
			<role name="Adapter" element="io.questdb.cairo.TableReaderSelectedColumnRecordCursor" />
			<role name="adaptee" element="io.questdb.cairo.TableReaderSelectedColumnRecordCursor::recordA:io.questdb.cairo.TableReaderSelectedColumnRecord" />
			<role name="Request()" element="io.questdb.cairo.TableReaderSelectedColumnRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.cairo.TableReaderSelectedColumnRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.wal.WalDataRecord" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalDataCursor" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalDataCursor::recordA:io.questdb.cairo.wal.WalDataRecord" />
			<role name="Request()" element="io.questdb.cairo.wal.WalDataCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.WalDataCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.functions.catalogue.TableListFunctionFactory$TableListCursorFactory$TableListRecordCursor$TableListRecord" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.catalogue.TableListFunctionFactory$TableListCursorFactory$TableListRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.catalogue.TableListFunctionFactory$TableListCursorFactory$TableListRecordCursor::record:io.questdb.griffin.engine.functions.catalogue.TableListFunctionFactory$TableListCursorFactory$TableListRecordCursor$TableListRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.TableListFunctionFactory$TableListCursorFactory$TableListRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.functions.catalogue.WalTableListFunctionFactory$WalTableListCursorFactory$TableListRecordCursor$TableListRecord" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.catalogue.WalTableListFunctionFactory$WalTableListCursorFactory$TableListRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.catalogue.WalTableListFunctionFactory$WalTableListCursorFactory$TableListRecordCursor::record:io.questdb.griffin.engine.functions.catalogue.WalTableListFunctionFactory$WalTableListCursorFactory$TableListRecordCursor$TableListRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.WalTableListFunctionFactory$WalTableListCursorFactory$TableListRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.functions.rnd.LongSequenceFunctionFactory$LongSequenceRecord" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.LongSequenceFunctionFactory$LongSequenceRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.LongSequenceFunctionFactory$LongSequenceRecordCursor::recordA:io.questdb.griffin.engine.functions.rnd.LongSequenceFunctionFactory$LongSequenceRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.LongSequenceFunctionFactory$LongSequenceRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.LongSequenceFunctionFactory$LongSequenceRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.DistinctSymbolRecordCursorFactory$DistinctSymbolRecordCursor$DistinctSymbolRecord" />
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.DistinctSymbolRecordCursorFactory$DistinctSymbolRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.DistinctSymbolRecordCursorFactory$DistinctSymbolRecordCursor::recordB:io.questdb.griffin.engine.groupby.DistinctSymbolRecordCursorFactory$DistinctSymbolRecordCursor$DistinctSymbolRecord" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.DistinctSymbolRecordCursorFactory$DistinctSymbolRecordCursor::recordA:io.questdb.griffin.engine.groupby.DistinctSymbolRecordCursorFactory$DistinctSymbolRecordCursor$DistinctSymbolRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctSymbolRecordCursorFactory$DistinctSymbolRecordCursor::getRecordB():io.questdb.cairo.sql.Record" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctSymbolRecordCursorFactory$DistinctSymbolRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctSymbolRecordCursorFactory$DistinctSymbolRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor$RostiRecord" />
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor::record:io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor$RostiRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ThreadLocal" />
			<role name="Adapter" element="io.questdb.network.IOContextFactoryImpl" />
			<role name="adaptee" element="io.questdb.network.IOContextFactoryImpl::contextPool:io.questdb.std.ThreadLocal" />
			<role name="Request()" element="io.questdb.network.IOContextFactoryImpl::newInstance(int, io.questdb.network.IODispatcher):io.questdb.network.IOContext" />
			<role name="Request()" element="io.questdb.network.IOContextFactoryImpl::setup():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.network.Epoll" />
			<role name="Adapter" element="io.questdb.network.IODispatcherLinux" />
			<role name="adaptee" element="io.questdb.network.IODispatcherLinux::epoll:io.questdb.network.Epoll" />
			<role name="Request()" element="io.questdb.network.IODispatcherLinux::registerListenerFd():void" />
			<role name="Request()" element="io.questdb.network.IODispatcherLinux::unregisterListenerFd():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.network.Kqueue" />
			<role name="Adapter" element="io.questdb.network.IODispatcherOsx" />
			<role name="adaptee" element="io.questdb.network.IODispatcherOsx::kqueue:io.questdb.network.Kqueue" />
			<role name="Request()" element="io.questdb.network.IODispatcherOsx::registerListenerFd():void" />
			<role name="Request()" element="io.questdb.network.IODispatcherOsx::unregisterListenerFd():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.cairo.SymbolMapReaderImpl" />
			<role name="adaptee" element="io.questdb.cairo.SymbolMapReaderImpl::cache:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapReaderImpl::updateSymbolCount(int):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.http.processors.TextQueryProcessorState" />
			<role name="Adaptee" element="io.questdb.std.str.StringSink" />
			<role name="adaptee" element="io.questdb.cutlass.http.processors.TextQueryProcessorState::query:io.questdb.std.str.StringSink" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessorState::clear():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cairo.RebuildColumnBase" />
			<role name="Adaptee" element="io.questdb.std.str.StringSink" />
			<role name="adaptee" element="io.questdb.cairo.RebuildColumnBase::tempStringSink:io.questdb.std.str.StringSink" />
			<role name="Request()" element="io.questdb.cairo.RebuildColumnBase::clear():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.SqlCompiler$QueryBuilder" />
			<role name="Adaptee" element="io.questdb.std.str.StringSink" />
			<role name="adaptee" element="io.questdb.griffin.SqlCompiler$QueryBuilder::sink:io.questdb.std.str.StringSink" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$QueryBuilder::clear():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.DirectLongList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::rows:io.questdb.std.DirectLongList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.DirectLongList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::rows:io.questdb.std.DirectLongList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.map.Map" />
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::dataMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.map.Map" />
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::dataMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter" />
			<role name="Adaptee" element="io.questdb.std.LongList" />
			<role name="adaptee" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::columnBits:io.questdb.std.LongList" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::isIndexed(int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter" />
			<role name="Adaptee" element="io.questdb.std.IntList" />
			<role name="adaptee" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::symbolCapacities:io.questdb.std.IntList" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::getSymbolCapacity(int):int" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.model.RuntimeIntervalModel" />
			<role name="adaptee" element="io.questdb.griffin.model.RuntimeIntervalModel::dynamicRangeList:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.model.RuntimeIntervalModel::calculateIntervals(io.questdb.griffin.SqlExecutionContext):io.questdb.std.LongList" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor" />
			<role name="Adaptee" element="io.questdb.cairo.map.Map" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor" />
			<role name="Adaptee" element="io.questdb.cairo.map.Map" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByAllRecordCursor" />
			<role name="Adaptee" element="io.questdb.cairo.map.Map" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByAllRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryARW" />
			<role name="Adapter" element="io.questdb.cairo.RecordChain" />
			<role name="adaptee" element="io.questdb.cairo.RecordChain::mem:io.questdb.cairo.vm.api.MemoryARW" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::hasNext():boolean" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::toTop():void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::clear():void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putBin(io.questdb.std.BinarySequence):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putBool(boolean):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putByte(byte):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putChar(char):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putDouble(double):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putFloat(float):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putInt(int):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putLong(long):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putLong128(long, long):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putLong256(io.questdb.std.Long256):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putShort(short):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putStr(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::putStr(java.lang.CharSequence, int, int):void" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::skip(int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryARW" />
			<role name="Adapter" element="io.questdb.cairo.map.CompactMap" />
			<role name="adaptee" element="io.questdb.cairo.map.CompactMap::entries:io.questdb.cairo.vm.api.MemoryARW" />
			<role name="adaptee" element="io.questdb.cairo.map.CompactMap::entrySlots:io.questdb.cairo.vm.api.MemoryARW" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMap::close():void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMap::withKey():io.questdb.cairo.map.MapKey" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryARW" />
			<role name="Adapter" element="io.questdb.griffin.engine.join.LongChain" />
			<role name="adaptee" element="io.questdb.griffin.engine.join.LongChain::valueChain:io.questdb.cairo.vm.api.MemoryARW" />
			<role name="Request()" element="io.questdb.griffin.engine.join.LongChain::clear():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.MemorySRImpl" />
			<role name="Adapter" element="io.questdb.cairo.SymbolColumnIndexer" />
			<role name="adaptee" element="io.questdb.cairo.SymbolColumnIndexer::mem:io.questdb.cairo.vm.MemorySRImpl" />
			<role name="Request()" element="io.questdb.cairo.SymbolColumnIndexer::closeSlider():void" />
			<role name="Request()" element="io.questdb.cairo.SymbolColumnIndexer::configureFollowerAndWriter(io.questdb.std.str.Path, java.lang.CharSequence, long, io.questdb.cairo.vm.api.MemoryMA, long):void" />
			<role name="Request()" element="io.questdb.cairo.SymbolColumnIndexer::getFd():int" />
			<role name="Request()" element="io.questdb.cairo.SymbolColumnIndexer::refreshSourceAndIndex(long, long):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.text.CsvFileIndexer" />
			<role name="Adaptee" element="io.questdb.std.FilesFacade" />
			<role name="adaptee" element="io.questdb.cutlass.text.CsvFileIndexer::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::clear():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="Adaptee" element="io.questdb.cairo.TableToken" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::tableToken:io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::rollback():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::detachPartition(long):io.questdb.cairo.AttachDetachStatus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::dropIndex(java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cairo.wal.WalWriter" />
			<role name="Adaptee" element="io.questdb.cairo.TableToken" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalWriter::tableToken:io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::apply(io.questdb.griffin.engine.ops.AlterOperation, boolean):long" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::apply(io.questdb.griffin.engine.ops.UpdateOperation):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.SqlOptimiser$LiteralCollector" />
			<role name="adaptee" element="io.questdb.griffin.SqlOptimiser$LiteralCollector::names:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.SqlOptimiser$LiteralCollector::visit(io.questdb.griffin.model.ExpressionNode):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IntHashSet" />
			<role name="Adapter" element="io.questdb.griffin.SqlOptimiser$LiteralCollector" />
			<role name="adaptee" element="io.questdb.griffin.SqlOptimiser$LiteralCollector::indexes:io.questdb.std.IntHashSet" />
			<role name="Request()" element="io.questdb.griffin.SqlOptimiser$LiteralCollector::visit(io.questdb.griffin.model.ExpressionNode):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.LowerCaseCharSequenceObjHashMap" />
			<role name="Adapter" element="io.questdb.griffin.SqlOptimiser$LiteralCheckingVisitor" />
			<role name="adaptee" element="io.questdb.griffin.SqlOptimiser$LiteralCheckingVisitor::nameTypeMap:io.questdb.std.LowerCaseCharSequenceObjHashMap" />
			<role name="Request()" element="io.questdb.griffin.SqlOptimiser$LiteralCheckingVisitor::visit(io.questdb.griffin.model.ExpressionNode):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.LowerCaseCharSequenceObjHashMap" />
			<role name="Adapter" element="io.questdb.griffin.SqlOptimiser$LiteralRewritingVisitor" />
			<role name="adaptee" element="io.questdb.griffin.SqlOptimiser$LiteralRewritingVisitor::aliasToColumnMap:io.questdb.std.LowerCaseCharSequenceObjHashMap" />
			<role name="Request()" element="io.questdb.griffin.SqlOptimiser$LiteralRewritingVisitor::visit(io.questdb.griffin.model.ExpressionNode):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableWriter" />
			<role name="Adapter" element="io.questdb.griffin.UpdateOperatorImpl" />
			<role name="adaptee" element="io.questdb.griffin.UpdateOperatorImpl::tableWriter:io.questdb.cairo.TableWriter" />
			<role name="Request()" element="io.questdb.griffin.UpdateOperatorImpl::executeUpdate(io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.engine.ops.UpdateOperation):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.ops.AlterOperation" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalWriter" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalWriter::alterOp:io.questdb.griffin.engine.ops.AlterOperation" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::addColumn(java.lang.CharSequence, int, int, boolean, boolean, int):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.log.LogRollingFileWriter" />
			<role name="Adaptee" element="io.questdb.log.LogRollingFileWriter$NextDeadline" />
			<role name="adaptee" element="io.questdb.log.LogRollingFileWriter::rollDeadlineFunction:io.questdb.log.LogRollingFileWriter$NextDeadline" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::bindProperties(io.questdb.log.LogFactory):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.log.LogAlertSocketWriter" />
			<role name="Adaptee" element="io.questdb.log.LogAlertSocket" />
			<role name="adaptee" element="io.questdb.log.LogAlertSocketWriter::socket:io.questdb.log.LogAlertSocket" />
			<role name="Request()" element="io.questdb.log.LogAlertSocketWriter::bindProperties(io.questdb.log.LogFactory):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.test.cairo.TableModel" />
			<role name="Adaptee" element="io.questdb.std.LongList" />
			<role name="adaptee" element="io.questdb.test.cairo.TableModel::columnBits:io.questdb.std.LongList" />
			<role name="Request()" element="io.questdb.test.cairo.TableModel::getIndexBlockCapacity(int):int" />
			<role name="Request()" element="io.questdb.test.cairo.TableModel::getSymbolCacheFlag(int):boolean" />
			<role name="Request()" element="io.questdb.test.cairo.TableModel::getSymbolCapacity(int):int" />
			<role name="Request()" element="io.questdb.test.cairo.TableModel::isIndexed(int):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryMR" />
			<role name="Adapter" element="io.questdb.cairo.IndexBuilder" />
			<role name="adaptee" element="io.questdb.cairo.IndexBuilder::indexMem:io.questdb.cairo.vm.api.MemoryMR" />
			<role name="Request()" element="io.questdb.cairo.IndexBuilder::doReindex(io.questdb.std.FilesFacade, io.questdb.cairo.ColumnVersionReader, int, java.lang.CharSequence, long, long, long, int, int):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.text.CsvFileIndexer" />
			<role name="Adaptee" element="io.questdb.std.str.Path" />
			<role name="adaptee" element="io.questdb.cutlass.text.CsvFileIndexer::path:io.questdb.std.str.Path" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::clear():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cairo.RebuildColumnBase" />
			<role name="Adaptee" element="io.questdb.std.str.Path" />
			<role name="adaptee" element="io.questdb.cairo.RebuildColumnBase::path:io.questdb.std.str.Path" />
			<role name="Request()" element="io.questdb.cairo.RebuildColumnBase::clear():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.map.FastMap$BaseKey" />
			<role name="Adapter" element="io.questdb.cairo.map.FastMap" />
			<role name="adaptee" element="io.questdb.cairo.map.FastMap::key:io.questdb.cairo.map.FastMap$BaseKey" />
			<role name="Request()" element="io.questdb.cairo.map.FastMap::withKey():io.questdb.cairo.map.MapKey" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.SCSequence" />
			<role name="Adapter" element="io.questdb.log.LogAlertSocketWriter" />
			<role name="adaptee" element="io.questdb.log.LogAlertSocketWriter::writeSequence:io.questdb.mp.SCSequence" />
			<role name="Request()" element="io.questdb.log.LogAlertSocketWriter::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.SCSequence" />
			<role name="Adapter" element="io.questdb.log.LogConsoleWriter" />
			<role name="adaptee" element="io.questdb.log.LogConsoleWriter::subSeq:io.questdb.mp.SCSequence" />
			<role name="Request()" element="io.questdb.log.LogConsoleWriter::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.SCSequence" />
			<role name="Adapter" element="io.questdb.log.LogFileWriter" />
			<role name="adaptee" element="io.questdb.log.LogFileWriter::subSeq:io.questdb.mp.SCSequence" />
			<role name="Request()" element="io.questdb.log.LogFileWriter::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.SCSequence" />
			<role name="Adapter" element="io.questdb.log.LogRollingFileWriter" />
			<role name="adaptee" element="io.questdb.log.LogRollingFileWriter::subSeq:io.questdb.mp.SCSequence" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.Sequence" />
			<role name="Adapter" element="io.questdb.cutlass.text.CopyRequestJob" />
			<role name="adaptee" element="io.questdb.cutlass.text.CopyRequestJob::requestSubSeq:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyRequestJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.Sequence" />
			<role name="Adapter" element="io.questdb.mp.AbstractQueueConsumerJob" />
			<role name="adaptee" element="io.questdb.mp.AbstractQueueConsumerJob::subSeq:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.mp.AbstractQueueConsumerJob::run(int, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cutlass.text.TextMetadataParser" />
			<role name="adaptee" element="io.questdb.cutlass.text.TextMetadataParser::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.TextMetadataParser::onEvent(int, java.lang.CharSequence, int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cutlass.http.HttpConnectionContext" />
			<role name="adaptee" element="io.questdb.cutlass.http.HttpConnectionContext::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::fail(io.questdb.cutlass.http.HttpRequestProcessorSelector, io.questdb.cutlass.http.HttpException):void" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::tryRerun(io.questdb.cutlass.http.HttpRequestProcessorSelector, io.questdb.cutlass.http.RescheduleContext):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cairo.IndexBuilder" />
			<role name="adaptee" element="io.questdb.cairo.IndexBuilder::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.IndexBuilder::doReindex(io.questdb.std.FilesFacade, io.questdb.cairo.ColumnVersionReader, int, java.lang.CharSequence, long, long, long, int, int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cairo.RecoverVarIndex" />
			<role name="adaptee" element="io.questdb.cairo.RecoverVarIndex::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.RecoverVarIndex::doReindex(io.questdb.std.FilesFacade, io.questdb.cairo.ColumnVersionReader, int, java.lang.CharSequence, long, long, long, int, int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.str.Path" />
			<role name="Adapter" element="io.questdb.griffin.UpdateOperatorImpl" />
			<role name="adaptee" element="io.questdb.griffin.UpdateOperatorImpl::path:io.questdb.std.str.Path" />
			<role name="Request()" element="io.questdb.griffin.UpdateOperatorImpl::executeUpdate(io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.engine.ops.UpdateOperation):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.str.StringSink" />
			<role name="Adapter" element="io.questdb.test.log.LogAlertSocketTest$MockLogRecord" />
			<role name="adaptee" element="io.questdb.test.log.LogAlertSocketTest$MockLogRecord::sink:io.questdb.std.str.StringSink" />
			<role name="Request()" element="io.questdb.test.log.LogAlertSocketTest$MockLogRecord::$():void" />
			<role name="Request()" element="io.questdb.test.log.LogAlertSocketTest$MockLogRecord::$(java.lang.CharSequence):io.questdb.log.LogRecord" />
			<role name="Request()" element="io.questdb.test.log.LogAlertSocketTest$MockLogRecord::$(java.lang.CharSequence, int, int):io.questdb.log.LogRecord" />
			<role name="Request()" element="io.questdb.test.log.LogAlertSocketTest$MockLogRecord::$(int):io.questdb.log.LogRecord" />
			<role name="Request()" element="io.questdb.test.log.LogAlertSocketTest$MockLogRecord::$(char):io.questdb.log.LogRecord" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::detachPartition(long):io.questdb.cairo.AttachDetachStatus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::dropIndex(java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalWriter" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalWriter::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::addColumn(java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::commit():long" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndBooleanFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndBooleanFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndBooleanFunctionFactory$RndFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndByteCCFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndByteCCFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndByteCCFunctionFactory$RndFunction::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndByteFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndByteFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndByteFunctionFactory$RndFunction::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndCharFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndCharFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndCharFunctionFactory$RndFunction::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndDateCCCFunctionFactory$Func" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndDateCCCFunctionFactory$Func::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndDateCCCFunctionFactory$Func::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndDateFunctionFactory$Func" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndDateFunctionFactory$Func::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndDateFunctionFactory$Func::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndDoubleCCFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndDoubleCCFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndDoubleCCFunctionFactory$RndFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndDoubleFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndDoubleFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndDoubleFunctionFactory$RndFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndFloatCFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndFloatCFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndFloatCFunctionFactory$RndFunction::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndFloatFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndFloatFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndFloatFunctionFactory$RndFunction::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndByteFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndByteFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndByteFunction::getGeoByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndIntFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndIntFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndIntFunction::getGeoInt(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndIntFunction::getGeoShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndLongFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndLongFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndLongFunction::getGeoLong(io.questdb.cairo.sql.Record):long" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndLongFunction::getGeoShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndShortFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndShortFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndGeoHashFunctionFactory$RndShortFunction::getGeoShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndIntCCFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndIntCCFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndIntCCFunctionFactory$RndFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndIntFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndIntFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndIntFunctionFactory$RndFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndLong256FunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndLong256FunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndLong256FunctionFactory$RndFunction::getLong256(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndLong256NFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndLong256NFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndLong256NFunctionFactory$RndFunction::getLong256(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndLongCCFunctionFactory$Func" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndLongCCFunctionFactory$Func::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndLongCCFunctionFactory$Func::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndLongFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndLongFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndLongFunctionFactory$RndFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndShortCCFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndShortCCFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndShortCCFunctionFactory$RndFunction::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndShortFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndShortFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndShortFunctionFactory$RndFunction::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndStrFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndStrFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndStrFunction::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndStrFunctionFactory$FixedFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndStrFunctionFactory$FixedFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndStrFunctionFactory$FixedFunction::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndStringListFunctionFactory$Func" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndStringListFunctionFactory$Func::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndStringListFunctionFactory$Func::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndStringRndListFunctionFactory$Func" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndStringRndListFunctionFactory$Func::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndStringRndListFunctionFactory$Func::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndStringRndListFunctionFactory$Func::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndTimestampFunctionFactory$Func" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndTimestampFunctionFactory$Func::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndTimestampFunctionFactory$Func::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndUuidFunctionFactory$RndFunction" />
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndUuidFunctionFactory$RndFunction::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndUuidFunctionFactory$RndFunction::getLong128Hi(io.questdb.cairo.sql.Record):long" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndUuidFunctionFactory$RndFunction::getLong128Lo(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.HeapRowCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.HeapRowCursorFactory::cursorFactories:io.questdb.std.ObjList" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.HeapRowCursorFactory::cursors:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.HeapRowCursorFactory::getCursor(io.questdb.cairo.sql.DataFrame):io.questdb.cairo.sql.RowCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory::cursors:io.questdb.std.ObjList" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory::cursorFactories:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory::getCursor(io.questdb.cairo.sql.DataFrame):io.questdb.cairo.sql.RowCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AbstractTreeSetRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AbstractTreeSetRecordCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AbstractTreeSetRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.DataFrameRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.DataFrameRecordCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.DataFrameRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.DataFrameRecordCursorImpl" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.FilterOnExcludedValuesRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FilterOnExcludedValuesRecordCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRecordCursorImpl" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnExcludedValuesRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.DataFrameRecordCursorImpl" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.FilterOnValuesRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FilterOnValuesRecordCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRecordCursorImpl" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnValuesRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.DataFrameRecordCursorImpl" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.SortedSymbolIndexRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.SortedSymbolIndexRecordCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRecordCursorImpl" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SortedSymbolIndexRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.LatestByValueIndexedFilteredRecordCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByValueIndexedFilteredRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByValueIndexedFilteredRecordCursorFactory::cursor:io.questdb.griffin.engine.table.LatestByValueIndexedFilteredRecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueIndexedFilteredRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByDeferredListValuesFilteredRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByDeferredListValuesFilteredRecordCursorFactory::cursor:io.questdb.griffin.engine.table.LatestByValueListRecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByDeferredListValuesFilteredRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.TelemetryJob" />
			<role name="adaptee" element="io.questdb.TelemetryJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.TelemetryJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cairo.ColumnPurgeJob" />
			<role name="adaptee" element="io.questdb.cairo.ColumnPurgeJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cairo.wal.ApplyWal2TableJob" />
			<role name="adaptee" element="io.questdb.cairo.wal.ApplyWal2TableJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::doRun(int, long, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalPurgeJob" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalPurgeJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.network.AbstractIODispatcher" />
			<role name="adaptee" element="io.questdb.network.AbstractIODispatcher::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.network.AbstractIODispatcher::disconnect(C, int):void" />
			<role name="Request()" element="io.questdb.network.AbstractIODispatcher::registerChannel(C, int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ConcurrentHashMap" />
			<role name="Adapter" element="io.questdb.cairo.pool.AbstractMultiTenantPool" />
			<role name="adaptee" element="io.questdb.cairo.pool.AbstractMultiTenantPool::entries:io.questdb.std.ConcurrentHashMap" />
			<role name="Request()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::releaseAll(long):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ConcurrentHashMap" />
			<role name="Adapter" element="io.questdb.cairo.pool.WriterPool" />
			<role name="adaptee" element="io.questdb.cairo.pool.WriterPool::entries:io.questdb.std.ConcurrentHashMap" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::releaseAll(long):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.SqlExecutionContext" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.date.NowFunctionFactory$Func" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.date.NowFunctionFactory$Func::context:io.questdb.griffin.SqlExecutionContext" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.NowFunctionFactory$Func::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.SqlExecutionContext" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.date.SystimestampFunctionFactory$Func" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.date.SystimestampFunctionFactory$Func::context:io.questdb.griffin.SqlExecutionContext" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.SystimestampFunctionFactory$Func::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Adapter" element="io.questdb.cairo.O3PartitionPurgeJob" />
			<role name="adaptee" element="io.questdb.cairo.O3PartitionPurgeJob::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.O3PartitionPurgeJob::doRun(int, long, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IntStack" />
			<role name="Adapter" element="io.questdb.griffin.SqlExecutionContextImpl" />
			<role name="adaptee" element="io.questdb.griffin.SqlExecutionContextImpl::timestampRequiredStack:io.questdb.std.IntStack" />
			<role name="Request()" element="io.questdb.griffin.SqlExecutionContextImpl::isTimestampRequired():boolean" />
			<role name="Request()" element="io.questdb.griffin.SqlExecutionContextImpl::popTimestampRequiredFlag():void" />
			<role name="Request()" element="io.questdb.griffin.SqlExecutionContextImpl::pushTimestampRequiredFlag(boolean):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.analytic.AnalyticContextImpl" />
			<role name="Adapter" element="io.questdb.griffin.SqlExecutionContextImpl" />
			<role name="adaptee" element="io.questdb.griffin.SqlExecutionContextImpl::analyticContext:io.questdb.griffin.engine.analytic.AnalyticContextImpl" />
			<role name="Request()" element="io.questdb.griffin.SqlExecutionContextImpl::clearAnalyticContext():void" />
			<role name="Request()" element="io.questdb.griffin.SqlExecutionContextImpl::configureAnalyticContext(io.questdb.cairo.sql.VirtualRecord, io.questdb.cairo.RecordSink, io.questdb.cairo.ColumnTypes, boolean, boolean):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoEngine" />
			<role name="Adapter" element="io.questdb.cairo.wal.ApplyWal2TableJob" />
			<role name="adaptee" element="io.questdb.cairo.wal.ApplyWal2TableJob::engine:io.questdb.cairo.CairoEngine" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::doRun(int, long, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoEngine" />
			<role name="Adapter" element="io.questdb.cairo.wal.CheckWalTransactionsJob" />
			<role name="adaptee" element="io.questdb.cairo.wal.CheckWalTransactionsJob::engine:io.questdb.cairo.CairoEngine" />
			<role name="Request()" element="io.questdb.cairo.wal.CheckWalTransactionsJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.DataFrameRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.DataFrameRecordCursorFactory::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.DataFrameRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.FilterOnExcludedValuesRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FilterOnExcludedValuesRecordCursorFactory::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnExcludedValuesRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.FilterOnValuesRecordCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FilterOnValuesRecordCursorFactory::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnValuesRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.pool.WalWriterPool" />
			<role name="Adapter" element="io.questdb.cairo.CairoEngine" />
			<role name="adaptee" element="io.questdb.cairo.CairoEngine::walWriterPool:io.questdb.cairo.pool.WalWriterPool" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getTableWriterAPI(io.questdb.cairo.TableToken, java.lang.String):io.questdb.cairo.TableWriterAPI" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.pool.WriterPool" />
			<role name="Adapter" element="io.questdb.cairo.CairoEngine" />
			<role name="adaptee" element="io.questdb.cairo.CairoEngine::writerPool:io.questdb.cairo.pool.WriterPool" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getTableWriterAPI(io.questdb.cairo.TableToken, java.lang.String):io.questdb.cairo.TableWriterAPI" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.wal.WalWriterMetadata" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalWriter" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalWriter::metadata:io.questdb.cairo.wal.WalWriterMetadata" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::getMetadataVersion():long" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::newRow(long):io.questdb.cairo.TableWriter$Row" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.FilesFacade" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int, int, boolean, boolean, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::detachPartition(long):io.questdb.cairo.AttachDetachStatus" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IntList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursor::columnIndexes:io.questdb.std.IntList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursor::getSymbolTable(int):io.questdb.cairo.sql.StaticSymbolTable" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.DataFrameCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursor::dataFrameCursor:io.questdb.cairo.sql.DataFrameCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursor::getSymbolTable(int):io.questdb.cairo.sql.StaticSymbolTable" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor::orderedSources:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.LongList" />
			<role name="Adapter" element="io.questdb.test.griffin.engine.orderby.LimitedSizeLongTreeChainTest$TestRecordCursor" />
			<role name="adaptee" element="io.questdb.test.griffin.engine.orderby.LimitedSizeLongTreeChainTest$TestRecordCursor::values:io.questdb.std.LongList" />
			<role name="Request()" element="io.questdb.test.griffin.engine.orderby.LimitedSizeLongTreeChainTest$TestRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.test.griffin.engine.orderby.LimitedSizeLongTreeChainTest$TestRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Request()" element="io.questdb.test.griffin.engine.orderby.LimitedSizeLongTreeChainTest$TestRecordCursor::size():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.wal.WalWriter$RowImpl" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalWriter" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalWriter::row:io.questdb.cairo.wal.WalWriter$RowImpl" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::newRow(long):io.questdb.cairo.TableWriter$Row" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableReader" />
			<role name="Adapter" element="io.questdb.cairo.TableReaderRecordCursor" />
			<role name="adaptee" element="io.questdb.cairo.TableReaderRecordCursor::reader:io.questdb.cairo.TableReader" />
			<role name="Request()" element="io.questdb.cairo.TableReaderRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.cairo.TableReaderRecordCursor::size():long" />
			<role name="Request()" element="io.questdb.cairo.TableReaderRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableReader" />
			<role name="Adapter" element="io.questdb.cairo.TableReaderSelectedColumnRecordCursor" />
			<role name="adaptee" element="io.questdb.cairo.TableReaderSelectedColumnRecordCursor::reader:io.questdb.cairo.TableReader" />
			<role name="Request()" element="io.questdb.cairo.TableReaderSelectedColumnRecordCursor::size():long" />
			<role name="Request()" element="io.questdb.cairo.TableReaderSelectedColumnRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableReader" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.ShowColumnsRecordCursorFactory$ShowColumnsCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.ShowColumnsRecordCursorFactory$ShowColumnsCursor::reader:io.questdb.cairo.TableReader" />
			<role name="Request()" element="io.questdb.griffin.engine.table.ShowColumnsRecordCursorFactory$ShowColumnsCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.ShowColumnsRecordCursorFactory$ShowColumnsCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.str.Path" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::path:io.questdb.std.str.Path" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::other:io.questdb.std.str.Path" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int, int, boolean, boolean, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addIndex(java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::detachPartition(long):io.questdb.cairo.AttachDetachStatus" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ConcurrentHashMap" />
			<role name="Adapter" element="io.questdb.cairo.AbstractTableNameRegistry" />
			<role name="adaptee" element="io.questdb.cairo.AbstractTableNameRegistry::nameTokenMap:io.questdb.std.ConcurrentHashMap" />
			<role name="adaptee" element="io.questdb.cairo.AbstractTableNameRegistry::reverseNameTokenMap:io.questdb.std.ConcurrentHashMap" />
			<role name="Request()" element="io.questdb.cairo.AbstractTableNameRegistry::close():void" />
			<role name="Request()" element="io.questdb.cairo.AbstractTableNameRegistry::getTableToken(java.lang.CharSequence):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.AbstractTableNameRegistry::getTableToken(java.lang.String, int):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.AbstractTableNameRegistry::getTableTokenCount(boolean):int" />
			<role name="Request()" element="io.questdb.cairo.AbstractTableNameRegistry::getTableTokens(io.questdb.std.ObjHashSet, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.AbstractTableNameRegistry::getTokenByDirName(java.lang.CharSequence):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.AbstractTableNameRegistry::isTableDropped(io.questdb.cairo.TableToken):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableNameRegistryFileStore" />
			<role name="Adapter" element="io.questdb.cairo.AbstractTableNameRegistry" />
			<role name="adaptee" element="io.questdb.cairo.AbstractTableNameRegistry::nameStore:io.questdb.cairo.TableNameRegistryFileStore" />
			<role name="Request()" element="io.questdb.cairo.AbstractTableNameRegistry::resetMemory():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.MessageBus" />
			<role name="Adapter" element="io.questdb.cairo.sql.async.PageFrameReduceJob" />
			<role name="adaptee" element="io.questdb.cairo.sql.async.PageFrameReduceJob::messageBus:io.questdb.MessageBus" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameReduceJob::run(int, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoEngine" />
			<role name="Adapter" element="io.questdb.test.cutlass.text.SqlExecutionContextStub" />
			<role name="adaptee" element="io.questdb.test.cutlass.text.SqlExecutionContextStub::engine:io.questdb.cairo.CairoEngine" />
			<role name="Request()" element="io.questdb.test.cutlass.text.SqlExecutionContextStub::getSecurityContext():io.questdb.cairo.SecurityContext" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableReader" />
			<role name="Adapter" element="io.questdb.cairo.AbstractFullDataFrameCursor" />
			<role name="adaptee" element="io.questdb.cairo.AbstractFullDataFrameCursor::reader:io.questdb.cairo.TableReader" />
			<role name="Request()" element="io.questdb.cairo.AbstractFullDataFrameCursor::newSymbolTable(int):io.questdb.cairo.sql.StaticSymbolTable" />
			<role name="Request()" element="io.questdb.cairo.AbstractFullDataFrameCursor::reload():boolean" />
			<role name="Request()" element="io.questdb.cairo.AbstractFullDataFrameCursor::size():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableReader" />
			<role name="Adapter" element="io.questdb.cairo.AbstractIntervalDataFrameCursor" />
			<role name="adaptee" element="io.questdb.cairo.AbstractIntervalDataFrameCursor::reader:io.questdb.cairo.TableReader" />
			<role name="Request()" element="io.questdb.cairo.AbstractIntervalDataFrameCursor::newSymbolTable(int):io.questdb.cairo.sql.StaticSymbolTable" />
			<role name="Request()" element="io.questdb.cairo.AbstractIntervalDataFrameCursor::reload():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjStack" />
			<role name="Adapter" element="io.questdb.griffin.BasePlanSink" />
			<role name="adaptee" element="io.questdb.griffin.BasePlanSink::factoryStack:io.questdb.std.ObjStack" />
			<role name="Request()" element="io.questdb.griffin.BasePlanSink::clear():void" />
			<role name="Request()" element="io.questdb.griffin.BasePlanSink::putBaseColumnName(int):io.questdb.griffin.PlanSink" />
			<role name="Request()" element="io.questdb.griffin.BasePlanSink::putBaseColumnNameNoRemap(int):io.questdb.griffin.PlanSink" />
			<role name="Request()" element="io.questdb.griffin.BasePlanSink::putColumnName(int):io.questdb.griffin.PlanSink" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.BasePlanSink$EscapingStringSink" />
			<role name="Adapter" element="io.questdb.griffin.BasePlanSink" />
			<role name="adaptee" element="io.questdb.griffin.BasePlanSink::sink:io.questdb.griffin.BasePlanSink$EscapingStringSink" />
			<role name="Request()" element="io.questdb.griffin.BasePlanSink::clear():void" />
			<role name="Request()" element="io.questdb.griffin.BasePlanSink::val(io.questdb.std.ObjList, int, int):io.questdb.griffin.PlanSink" />
			<role name="Request()" element="io.questdb.griffin.BasePlanSink::valISODate(long):io.questdb.griffin.PlanSink" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Adapter" element="io.questdb.cutlass.line.tcp.TableStructureAdapter" />
			<role name="adaptee" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::cairoConfiguration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::getMaxUncommittedRows():int" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::getO3MaxLag():long" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::getSymbolCacheFlag(int):boolean" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::getSymbolCapacity(int):int" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::isWalEnabled():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Adapter" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter" />
			<role name="adaptee" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::getIndexBlockCapacity(int):int" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::getMaxUncommittedRows():int" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::getO3MaxLag():long" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::getSymbolCapacity(int):int" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::isWalEnabled():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Adapter" element="io.questdb.test.cairo.TableModel" />
			<role name="adaptee" element="io.questdb.test.cairo.TableModel::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.test.cairo.TableModel::getMaxUncommittedRows():int" />
			<role name="Request()" element="io.questdb.test.cairo.TableModel::getO3MaxLag():long" />
			<role name="Request()" element="io.questdb.test.cairo.TableModel::isWalEnabled():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.IndexFrame" />
			<role name="Adapter" element="io.questdb.cairo.BitmapIndexFwdReader$Cursor" />
			<role name="adaptee" element="io.questdb.cairo.BitmapIndexFwdReader$Cursor::indexFrame:io.questdb.cairo.IndexFrame" />
			<role name="Request()" element="io.questdb.cairo.BitmapIndexFwdReader$Cursor::getNext():io.questdb.cairo.IndexFrame" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IntLongPriorityQueue" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.HeapRowCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.HeapRowCursor::heap:io.questdb.std.IntLongPriorityQueue" />
			<role name="Request()" element="io.questdb.griffin.engine.table.HeapRowCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.table.HeapRowCursor::next():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.LatestByValueIndexedRowCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByValueDeferredIndexedRowCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByValueDeferredIndexedRowCursorFactory::cursor:io.questdb.griffin.engine.table.LatestByValueIndexedRowCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueDeferredIndexedRowCursorFactory::getCursor(io.questdb.cairo.sql.DataFrame):io.questdb.cairo.sql.RowCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.LatestByValueIndexedRowCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByValueIndexedRowCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByValueIndexedRowCursorFactory::cursor:io.questdb.griffin.engine.table.LatestByValueIndexedRowCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueIndexedRowCursorFactory::getCursor(io.questdb.cairo.sql.DataFrame):io.questdb.cairo.sql.RowCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.DataFrameBwdRowCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.BwdDataFrameRowCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.BwdDataFrameRowCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameBwdRowCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.BwdDataFrameRowCursorFactory::getCursor(io.questdb.cairo.sql.DataFrame):io.questdb.cairo.sql.RowCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.DataFrameRowCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.DataFrameRowCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.DataFrameRowCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRowCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.DataFrameRowCursorFactory::getCursor(io.questdb.cairo.sql.DataFrame):io.questdb.cairo.sql.RowCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.HeapRowCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.HeapRowCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.HeapRowCursorFactory::cursor:io.questdb.griffin.engine.table.HeapRowCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.HeapRowCursorFactory::getCursor(io.questdb.cairo.sql.DataFrame):io.questdb.cairo.sql.RowCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory$SequentialRowCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory::cursor:io.questdb.griffin.engine.table.SequentialRowCursorFactory$SequentialRowCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory::getCursor(io.questdb.cairo.sql.DataFrame):io.questdb.cairo.sql.RowCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory$ListBasedSymbolIndexRowCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory::cursor:io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory$ListBasedSymbolIndexRowCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory::getCursor(io.questdb.cairo.sql.DataFrame):io.questdb.cairo.sql.RowCursor" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$FieldNameParser" />
			<role name="Adapter" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onFieldName:io.questdb.cutlass.line.udp.LineUdpParserImpl$FieldNameParser" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onEvent(io.questdb.cutlass.line.udp.CachedCharSequence, int, io.questdb.cutlass.line.udp.CharSequenceCache):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$FieldValueParser" />
			<role name="Adapter" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onTagValue:io.questdb.cutlass.line.udp.LineUdpParserImpl$FieldValueParser" />
			<role name="adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onFieldValue:io.questdb.cutlass.line.udp.LineUdpParserImpl$FieldValueParser" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onEvent(io.questdb.cutlass.line.udp.CachedCharSequence, int, io.questdb.cutlass.line.udp.CharSequenceCache):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$LineEndParser" />
			<role name="Adapter" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onLineEnd:io.questdb.cutlass.line.udp.LineUdpParserImpl$LineEndParser" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onLineEnd(io.questdb.cutlass.line.udp.CharSequenceCache):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor$TableReaderPageFrame" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::frame:io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor$TableReaderPageFrame" />
			<role name="Request()" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::getUpdateRowId(long):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor$TableReaderPageFrame" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::frame:io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor$TableReaderPageFrame" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::getUpdateRowId(long):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrameCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrameCursor::pageFrame:io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrameCursor::next():io.questdb.cairo.sql.PageFrame" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cutlass.http.HttpConnectionContext" />
			<role name="Adapter" element="io.questdb.cutlass.http.processors.TextImportProcessor" />
			<role name="adaptee" element="io.questdb.cutlass.http.processors.TextImportProcessor::transientContext:io.questdb.cutlass.http.HttpConnectionContext" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextImportProcessor::onChunk(long, long):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextImportProcessor::onPartBegin(io.questdb.cutlass.http.HttpRequestHeader):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryMARW" />
			<role name="Adapter" element="io.questdb.cairo.SymbolMapWriter" />
			<role name="adaptee" element="io.questdb.cairo.SymbolMapWriter::offsetMem:io.questdb.cairo.vm.api.MemoryMARW" />
			<role name="adaptee" element="io.questdb.cairo.SymbolMapWriter::charMem:io.questdb.cairo.vm.api.MemoryMARW" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::getNullFlag():boolean" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::rollback(int):void" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::sync(boolean):void" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::truncate():void" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::updateCacheFlag(boolean):void" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::updateNullFlag(boolean):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByValuesFilteredRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByValuesFilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValuesFilteredRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.network.NetworkFacade" />
			<role name="Adapter" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel" />
			<role name="adaptee" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::close():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::errno():int" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::receive(long, int):int" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::send(long, int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.network.NetworkFacade" />
			<role name="Adapter" element="io.questdb.cutlass.line.udp.UdpLineChannel" />
			<role name="adaptee" element="io.questdb.cutlass.line.udp.UdpLineChannel::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.UdpLineChannel::close():void" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.UdpLineChannel::errno():int" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.UdpLineChannel::send(long, int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableReader" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::reader:io.questdb.cairo.TableReader" />
			<role name="Request()" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::size():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableReader" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::reader:io.questdb.cairo.TableReader" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::size():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.wal.seq.SequencerMetadata" />
			<role name="Adapter" element="io.questdb.cairo.wal.seq.TableSequencerImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.seq.TableSequencerImpl::metadata:io.questdb.cairo.wal.seq.SequencerMetadata" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::dropTable():void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::getMetadataChangeLog(long):io.questdb.cairo.wal.seq.TableMetadataChangeLog" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::getStructureVersion():long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::getTableId():int" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::getTableMetadata(io.questdb.cairo.wal.seq.TableRecordMetadataSink):long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::isSuspended():boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextStructureTxn(long, io.questdb.cairo.wal.seq.TableMetadataChange):long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextTxn(long, int, int, int):long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::rename(io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::resumeTable():void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::suspendTable():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.MCSequence" />
			<role name="Adapter" element="io.questdb.network.AbstractIODispatcher" />
			<role name="adaptee" element="io.questdb.network.AbstractIODispatcher::ioEventSubSeq:io.questdb.mp.MCSequence" />
			<role name="Request()" element="io.questdb.network.AbstractIODispatcher::processIOQueue(io.questdb.network.IORequestProcessor):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.MPSequence" />
			<role name="Adapter" element="io.questdb.network.AbstractIODispatcher" />
			<role name="adaptee" element="io.questdb.network.AbstractIODispatcher::disconnectPubSeq:io.questdb.mp.MPSequence" />
			<role name="adaptee" element="io.questdb.network.AbstractIODispatcher::interestPubSeq:io.questdb.mp.MPSequence" />
			<role name="Request()" element="io.questdb.network.AbstractIODispatcher::disconnect(C, int):void" />
			<role name="Request()" element="io.questdb.network.AbstractIODispatcher::registerChannel(C, int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.cairo.TableConverter$TableDescriptorImpl" />
			<role name="adaptee" element="io.questdb.cairo.TableConverter$TableDescriptorImpl::columnNames:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.cairo.TableConverter$TableDescriptorImpl::getColumnCount():int" />
			<role name="Request()" element="io.questdb.cairo.TableConverter$TableDescriptorImpl::getColumnName(int):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IntList" />
			<role name="Adapter" element="io.questdb.cairo.TableConverter$TableDescriptorImpl" />
			<role name="adaptee" element="io.questdb.cairo.TableConverter$TableDescriptorImpl::columnTypes:io.questdb.std.IntList" />
			<role name="Request()" element="io.questdb.cairo.TableConverter$TableDescriptorImpl::getColumnType(int):int" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IntList" />
			<role name="Adapter" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::geoHashBitsSizeByColIdx:io.questdb.std.IntList" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onEvent(io.questdb.cutlass.line.udp.CachedCharSequence, int, io.questdb.cutlass.line.udp.CharSequenceCache):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.LongList" />
			<role name="Adapter" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::columnValues:io.questdb.std.LongList" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onEvent(io.questdb.cutlass.line.udp.CachedCharSequence, int, io.questdb.cutlass.line.udp.CharSequenceCache):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.CharSequenceObjHashMap" />
			<role name="Adapter" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::writerCache:io.questdb.std.CharSequenceObjHashMap" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onEvent(io.questdb.cutlass.line.udp.CachedCharSequence, int, io.questdb.cutlass.line.udp.CharSequenceCache):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.text.CairoTextWriter$TableStructureAdapter" />
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="adaptee" element="io.questdb.cutlass.text.CairoTextWriter$TableStructureAdapter::types:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.cutlass.text.CairoTextWriter$TableStructureAdapter::isIndexed(int):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.FanOut$Holder" />
			<role name="Adapter" element="io.questdb.mp.FanOut" />
			<role name="adaptee" element="io.questdb.mp.FanOut::holder:io.questdb.mp.FanOut$Holder" />
			<role name="Request()" element="io.questdb.mp.FanOut::availableIndex(long):long" />
			<role name="Request()" element="io.questdb.mp.FanOut::getWaitStrategy():io.questdb.mp.WaitStrategy" />
			<role name="Request()" element="io.questdb.mp.FanOut::setBarrier(io.questdb.mp.Barrier):void" />
			<role name="Request()" element="io.questdb.mp.FanOut::setCurrent(long):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.UpdateOperatorImpl" />
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="adaptee" element="io.questdb.griffin.UpdateOperatorImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.UpdateOperatorImpl::executeUpdate(io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.engine.ops.UpdateOperation):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$Sequence" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$FixLenFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$FixLenFunction::sequence:io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$Sequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$FixLenFunction::getBin(io.questdb.cairo.sql.Record):io.questdb.std.BinarySequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$FixLenFunction::getBinLen(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$Sequence" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$VarLenFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$VarLenFunction::sequence:io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$Sequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$VarLenFunction::getBin(io.questdb.cairo.sql.Record):io.questdb.std.BinarySequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$VarLenFunction::getBinLen(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.functions.rnd.RndBinFunctionFactory$Sequence" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndBinFunctionFactory$FixLenFunction" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndBinFunctionFactory$FixLenFunction::sequence:io.questdb.griffin.engine.functions.rnd.RndBinFunctionFactory$Sequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndBinFunctionFactory$FixLenFunction::getBinLen(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryCMARW" />
			<role name="Adapter" element="io.questdb.cairo.TxWriter" />
			<role name="adaptee" element="io.questdb.cairo.TxWriter::txMemBase:io.questdb.cairo.vm.api.MemoryCMARW" />
			<role name="Request()" element="io.questdb.cairo.TxWriter::clear():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.IDGenerator" />
			<role name="Adapter" element="io.questdb.cairo.wal.seq.TableSequencerImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.seq.TableSequencerImpl::walIdGenerator:io.questdb.cairo.IDGenerator" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::getNextWalId():int" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.wal.seq.TableTransactionLog" />
			<role name="Adapter" element="io.questdb.cairo.wal.seq.TableSequencerImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.seq.TableSequencerImpl::tableTransactionLog:io.questdb.cairo.wal.seq.TableTransactionLog" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::dropTable():void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::getMetadataChangeLog(long):io.questdb.cairo.wal.seq.TableMetadataChangeLog" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::getTableMetadata(io.questdb.cairo.wal.seq.TableRecordMetadataSink):long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::getTransactionLogCursor(long):io.questdb.cairo.wal.seq.TransactionLogCursor" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::lastTxn():long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextStructureTxn(long, io.questdb.cairo.wal.seq.TableMetadataChange):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.map.CompactMapValue" />
			<role name="Adapter" element="io.questdb.cairo.map.CompactMap" />
			<role name="adaptee" element="io.questdb.cairo.map.CompactMap::value:io.questdb.cairo.map.CompactMapValue" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMap::valueAt(long):io.questdb.cairo.map.MapValue" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryARW" />
			<role name="Adapter" element="io.questdb.cairo.map.CompactMapValue" />
			<role name="adaptee" element="io.questdb.cairo.map.CompactMapValue::entries:io.questdb.cairo.vm.api.MemoryARW" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::addByte(int, byte):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::addDouble(int, double):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::addFloat(int, float):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::addInt(int, int):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::addLong(int, long):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::addLong256(int, io.questdb.std.Long256):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::addShort(int, short):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::getBool(int):boolean" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::getByte(int):byte" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::getChar(int):char" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::getDouble(int):double" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::getFloat(int):float" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::getInt(int):int" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::getLong(int):long" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::getShort(int):short" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::putBool(int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::putByte(int, byte):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::putChar(int, char):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::putDouble(int, double):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::putFloat(int, float):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::putInt(int, int):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::putLong(int, long):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::putLong128(int, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::putLong256(int, io.questdb.std.Long256):void" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapValue::putShort(int, short):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ThreadLocal" />
			<role name="Adapter" element="io.questdb.test.fuzz.FuzzInsertOperation" />
			<role name="adaptee" element="io.questdb.test.fuzz.FuzzInsertOperation::tlIntList:io.questdb.std.ThreadLocal" />
			<role name="adaptee" element="io.questdb.test.fuzz.FuzzInsertOperation::tlBinSeq:io.questdb.std.ThreadLocal" />
			<role name="Request()" element="io.questdb.test.fuzz.FuzzInsertOperation::apply(io.questdb.std.Rnd, io.questdb.cairo.TableWriterAPI, int):boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor" />
			<role name="Adaptee" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor" />
			<role name="Adaptee" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor" />
			<role name="Adaptee" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper" />
			<role name="Adaptee" element="io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::delegate:io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::getRecord():io.questdb.cairo.sql.Record" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::getRecordB():io.questdb.cairo.sql.Record" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::size():long" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.CharSequenceIntHashMap" />
			<role name="Adapter" element="io.questdb.cairo.SymbolMapWriter" />
			<role name="adaptee" element="io.questdb.cairo.SymbolMapWriter::cache:io.questdb.std.CharSequenceIntHashMap" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::put(java.lang.CharSequence, io.questdb.cairo.SymbolValueCountCollector):int" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::rollback(int):void" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::truncate():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.BitmapIndexWriter" />
			<role name="Adapter" element="io.questdb.cairo.SymbolMapWriter" />
			<role name="adaptee" element="io.questdb.cairo.SymbolMapWriter::indexWriter:io.questdb.cairo.BitmapIndexWriter" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::rollback(int):void" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::sync(boolean):void" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::truncate():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.FilesFacade" />
			<role name="Adapter" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn" />
			<role name="adaptee" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::append(long, io.questdb.cairo.frm.FrameColumn, long, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::appendNulls(long, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.FilesFacade" />
			<role name="Adapter" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn" />
			<role name="adaptee" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::append(long, io.questdb.cairo.frm.FrameColumn, long, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::appendNulls(long, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoEngine" />
			<role name="Adapter" element="io.questdb.griffin.engine.ops.OperationFutureImpl" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.OperationFutureImpl::engine:io.questdb.cairo.CairoEngine" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.OperationFutureImpl::await():void" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.OperationFutureImpl::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryMR" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::metaMem:io.questdb.cairo.vm.api.MemoryMR" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int, int, boolean, boolean, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeColumn(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::renameColumn(java.lang.CharSequence, java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryCMR" />
			<role name="Adapter" element="io.questdb.cairo.SymbolMapReaderImpl" />
			<role name="adaptee" element="io.questdb.cairo.SymbolMapReaderImpl::offsetMem:io.questdb.cairo.vm.api.MemoryCMR" />
			<role name="adaptee" element="io.questdb.cairo.SymbolMapReaderImpl::charMem:io.questdb.cairo.vm.api.MemoryCMR" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapReaderImpl::isDeleted():boolean" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapReaderImpl::updateSymbolCount(int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.metrics.MetricsRegistry" />
			<role name="Adapter" element="io.questdb.Metrics" />
			<role name="adaptee" element="io.questdb.Metrics::metricsRegistry:io.questdb.metrics.MetricsRegistry" />
			<role name="Request()" element="io.questdb.Metrics::scrapeIntoPrometheus(io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.metrics.MetricsRegistry" />
			<role name="Adapter" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics" />
			<role name="adaptee" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics::metricsRegistry:io.questdb.metrics.MetricsRegistry" />
			<role name="Request()" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics::scrapeIntoPrometheus(io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cairo.ColumnVersionReader" />
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryCMR" />
			<role name="adaptee" element="io.questdb.cairo.ColumnVersionReader::mem:io.questdb.cairo.vm.api.MemoryCMR" />
			<role name="Request()" element="io.questdb.cairo.ColumnVersionReader::clear():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.line.tcp.SymbolCache" />
			<role name="Adaptee" element="io.questdb.std.ByteCharSequenceIntHashMap" />
			<role name="adaptee" element="io.questdb.cutlass.line.tcp.SymbolCache::symbolValueToKeyMap:io.questdb.std.ByteCharSequenceIntHashMap" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.SymbolCache::keyOf(io.questdb.std.str.DirectByteCharSequence):int" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList" />
			<role name="Adapter" element="io.questdb.griffin.engine.ops.AlterOperation" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.AlterOperation::directExtraStrInfo:io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation::clear():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.ops.AlterOperation$ObjCharSequenceList" />
			<role name="Adapter" element="io.questdb.griffin.engine.ops.AlterOperation" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.AlterOperation::extraStrInfo:io.questdb.griffin.engine.ops.AlterOperation$ObjCharSequenceList" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation::clear():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$RankFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.RecordComparator" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$RankFunction::recordComparator:io.questdb.griffin.engine.RecordComparator" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$RankFunction::pass1(io.questdb.cairo.sql.Record, long, io.questdb.cairo.sql.AnalyticSPI):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$OrderRankFunction" />
			<role name="Adaptee" element="io.questdb.griffin.engine.RecordComparator" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$OrderRankFunction::recordComparator:io.questdb.griffin.engine.RecordComparator" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$OrderRankFunction::pass1(io.questdb.cairo.sql.Record, long, io.questdb.cairo.sql.AnalyticSPI):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryMAR" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::ddlMem:io.questdb.cairo.vm.api.MemoryMAR" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::setMetaMaxUncommittedRows(int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::setMetaO3MaxLag(long):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler" />
			<role name="Adapter" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob" />
			<role name="adaptee" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob::scheduler:io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob::releaseWalTableDetails():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler" />
			<role name="Adapter" element="io.questdb.test.cutlass.line.tcp.BaseLineTcpContextTest$NoNetworkIOJob" />
			<role name="adaptee" element="io.questdb.test.cutlass.line.tcp.BaseLineTcpContextTest$NoNetworkIOJob::scheduler:io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler" />
			<role name="Request()" element="io.questdb.test.cutlass.line.tcp.BaseLineTcpContextTest$NoNetworkIOJob::releaseWalTableDetails():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.metrics.VirtualLongGauge$StatProvider" />
			<role name="Adapter" element="io.questdb.metrics.VirtualLongGauge" />
			<role name="adaptee" element="io.questdb.metrics.VirtualLongGauge::provider:io.questdb.metrics.VirtualLongGauge$StatProvider" />
			<role name="Request()" element="io.questdb.metrics.VirtualLongGauge::getValue():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.cairo.frm.file.ContiguousFileColumnPool$ListPool" />
			<role name="adaptee" element="io.questdb.cairo.frm.file.ContiguousFileColumnPool$ListPool::pool:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileColumnPool$ListPool::put(T):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IntList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::columnCrossIndex:io.questdb.std.IntList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getBitmapIndexReader(int, int):io.questdb.cairo.BitmapIndexReader" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getColumnShiftBits(int):int" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getIndexPageAddress(int):long" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getPageAddress(int):long" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getPageSize(int):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.HeapRowCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.HeapRowCursor::cursors:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.table.HeapRowCursor::next():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableToken" />
			<role name="Adapter" element="io.questdb.cairo.wal.seq.TableSequencerImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.seq.TableSequencerImpl::tableToken:io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextStructureTxn(long, io.questdb.cairo.wal.seq.TableMetadataChange):long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextTxn(long, int, int, int):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.ops.AlterOperation$ObjCharSequenceList" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.AlterOperation$ObjCharSequenceList::strings:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation$ObjCharSequenceList::getStrA(int):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation$ObjCharSequenceList::getStrB(int):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation$ObjCharSequenceList::size():int" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.LongList" />
			<role name="Adapter" element="io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList::offsets:io.questdb.std.LongList" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList::getStrA(int):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList::getStrB(int):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList::size():int" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryMR" />
			<role name="Adapter" element="io.questdb.cairo.AbstractIndexReader" />
			<role name="adaptee" element="io.questdb.cairo.AbstractIndexReader::keyMem:io.questdb.cairo.vm.api.MemoryMR" />
			<role name="adaptee" element="io.questdb.cairo.AbstractIndexReader::valueMem:io.questdb.cairo.vm.api.MemoryMR" />
			<role name="Request()" element="io.questdb.cairo.AbstractIndexReader::getKeyBaseAddress():long" />
			<role name="Request()" element="io.questdb.cairo.AbstractIndexReader::getKeyMemorySize():long" />
			<role name="Request()" element="io.questdb.cairo.AbstractIndexReader::getValueBaseAddress():long" />
			<role name="Request()" element="io.questdb.cairo.AbstractIndexReader::getValueMemorySize():long" />
			<role name="Request()" element="io.questdb.cairo.AbstractIndexReader::isOpen():boolean" />
			<role name="Request()" element="io.questdb.cairo.AbstractIndexReader::of(io.questdb.cairo.CairoConfiguration, io.questdb.std.str.Path, java.lang.CharSequence, long, long):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.client.Sender" />
			<role name="Adapter" element="io.questdb.test.cutlass.line.interop.TestInterop$JsonTestSuiteParser" />
			<role name="adaptee" element="io.questdb.test.cutlass.line.interop.TestInterop$JsonTestSuiteParser::sender:io.questdb.client.Sender" />
			<role name="Request()" element="io.questdb.test.cutlass.line.interop.TestInterop$JsonTestSuiteParser::onEvent(int, java.lang.CharSequence, int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cutlass.http.processors.TextImportProcessor" />
			<role name="adaptee" element="io.questdb.cutlass.http.processors.TextImportProcessor::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextImportProcessor::onPartBegin(io.questdb.cutlass.http.HttpRequestHeader):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextImportProcessor::onPartEnd():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.ops.AlterOperation" />
			<role name="Adapter" element="io.questdb.griffin.CompiledQueryImpl" />
			<role name="adaptee" element="io.questdb.griffin.CompiledQueryImpl::alterOp:io.questdb.griffin.engine.ops.AlterOperation" />
			<role name="Request()" element="io.questdb.griffin.CompiledQueryImpl::execute(io.questdb.griffin.SqlExecutionContext, io.questdb.mp.SCSequence, boolean):io.questdb.cairo.sql.OperationFuture" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.ops.UpdateOperation" />
			<role name="Adapter" element="io.questdb.griffin.CompiledQueryImpl" />
			<role name="adaptee" element="io.questdb.griffin.CompiledQueryImpl::updateOp:io.questdb.griffin.engine.ops.UpdateOperation" />
			<role name="Request()" element="io.questdb.griffin.CompiledQueryImpl::execute(io.questdb.griffin.SqlExecutionContext, io.questdb.mp.SCSequence, boolean):io.questdb.cairo.sql.OperationFuture" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.str.StringSink" />
			<role name="Adapter" element="io.questdb.test.griffin.RpnBuilder" />
			<role name="adaptee" element="io.questdb.test.griffin.RpnBuilder::sink:io.questdb.std.str.StringSink" />
			<role name="Request()" element="io.questdb.test.griffin.RpnBuilder::onNode(io.questdb.griffin.model.ExpressionNode):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::rollback():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int, int, boolean, boolean, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addIndex(java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::detachPartition(long):io.questdb.cairo.AttachDetachStatus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::dropIndex(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeColumn(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::renameColumn(java.lang.CharSequence, java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalWriter" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalWriter::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::commit():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.map.CompactMapRecord" />
			<role name="Adapter" element="io.questdb.cairo.map.CompactMapCursor" />
			<role name="adaptee" element="io.questdb.cairo.map.CompactMapCursor::recordA:io.questdb.cairo.map.CompactMapRecord" />
			<role name="Request()" element="io.questdb.cairo.map.CompactMapCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.map.MapRecord" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::mapRecord:io.questdb.cairo.map.MapRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.map.FastMapRecord" />
			<role name="Adapter" element="io.questdb.cairo.map.FastMapCursor" />
			<role name="adaptee" element="io.questdb.cairo.map.FastMapCursor::recordA:io.questdb.cairo.map.FastMapRecord" />
			<role name="Request()" element="io.questdb.cairo.map.FastMapCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursorFactory" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursorFactory::cursor:io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursorFactory::getSymbolKey():int" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursorFactory::of(int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.LongList" />
			<role name="Adapter" element="io.questdb.griffin.model.RuntimeIntervalModel" />
			<role name="adaptee" element="io.questdb.griffin.model.RuntimeIntervalModel::intervals:io.questdb.std.LongList" />
			<role name="adaptee" element="io.questdb.griffin.model.RuntimeIntervalModel::outIntervals:io.questdb.std.LongList" />
			<role name="Request()" element="io.questdb.griffin.model.RuntimeIntervalModel::calculateIntervals(io.questdb.griffin.SqlExecutionContext):io.questdb.std.LongList" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IOURingFacade" />
			<role name="Adapter" element="io.questdb.std.IOURingImpl" />
			<role name="adaptee" element="io.questdb.std.IOURingImpl::facade:io.questdb.std.IOURingFacade" />
			<role name="Request()" element="io.questdb.std.IOURingImpl::close():void" />
			<role name="Request()" element="io.questdb.std.IOURingImpl::submit():int" />
			<role name="Request()" element="io.questdb.std.IOURingImpl::submitAndWait():int" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cairo.pool.AbstractMultiTenantPool" />
			<role name="adaptee" element="io.questdb.cairo.pool.AbstractMultiTenantPool::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::releaseAll(long):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cairo.pool.WriterPool" />
			<role name="adaptee" element="io.questdb.cairo.pool.WriterPool::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::releaseAll(long):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoEngine" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.TableListRecordCursorFactory$TableListRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.TableListRecordCursorFactory$TableListRecordCursor::engine:io.questdb.cairo.CairoEngine" />
			<role name="Request()" element="io.questdb.griffin.engine.table.TableListRecordCursorFactory$TableListRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.ops.InsertOperationImpl$InsertMethodImpl" />
			<role name="Adapter" element="io.questdb.griffin.engine.ops.InsertOperationImpl" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.InsertOperationImpl::insertMethod:io.questdb.griffin.engine.ops.InsertOperationImpl$InsertMethodImpl" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.InsertOperationImpl::createMethod(io.questdb.griffin.SqlExecutionContext, io.questdb.cairo.pool.WriterSource):io.questdb.cairo.sql.InsertMethod" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor" />
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="adaptee" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::loFunction:io.questdb.cairo.sql.Function" />
			<role name="adaptee" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::hiFunction:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.table.FilteredRecordCursor" />
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilteredRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilteredRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor" />
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator" />
			<role name="Adaptee" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator$AuthState" />
			<role name="adaptee" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::authState:io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator$AuthState" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::handleIO(io.questdb.cutlass.line.tcp.NetworkIOJob):io.questdb.cutlass.line.tcp.LineTcpConnectionContext$IOContextResult" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Adapter" element="io.questdb.cairo.CairoEngine$EngineMaintenanceJob" />
			<role name="adaptee" element="io.questdb.cairo.CairoEngine$EngineMaintenanceJob::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine$EngineMaintenanceJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalPurgeJob" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalPurgeJob::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Adapter" element="io.questdb.log.LogRollingFileWriter" />
			<role name="adaptee" element="io.questdb.log.LogRollingFileWriter::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::bindProperties(io.questdb.log.LogFactory):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.CharSequenceObjHashMap" />
			<role name="Adapter" element="io.questdb.cutlass.http.HttpServer$HttpRequestProcessorSelectorImpl" />
			<role name="adaptee" element="io.questdb.cutlass.http.HttpServer$HttpRequestProcessorSelectorImpl::processorMap:io.questdb.std.CharSequenceObjHashMap" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpServer$HttpRequestProcessorSelectorImpl::close():void" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpServer$HttpRequestProcessorSelectorImpl::select(java.lang.CharSequence):io.questdb.cutlass.http.HttpRequestProcessor" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.http.HttpResponseSink$HttpResponseHeaderImpl" />
			<role name="Adaptee" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="adaptee" element="io.questdb.cutlass.http.HttpResponseSink$HttpResponseHeaderImpl::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpResponseSink$HttpResponseHeaderImpl::status(java.lang.CharSequence, int, java.lang.CharSequence, long):java.lang.String" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.frm.file.RecycleBin" />
			<role name="Adapter" element="io.questdb.cairo.frm.file.PartitionFrame" />
			<role name="adaptee" element="io.questdb.cairo.frm.file.PartitionFrame::frameRecycleBin:io.questdb.cairo.frm.file.RecycleBin" />
			<role name="Request()" element="io.questdb.cairo.frm.file.PartitionFrame::close():void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor" />
			<role name="Adaptee" element="io.questdb.cairo.RecordSink" />
			<role name="adaptee" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::recordSink:io.questdb.cairo.RecordSink" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.SymbolMapReaderImpl" />
			<role name="Adapter" element="io.questdb.cutlass.line.tcp.SymbolCache" />
			<role name="adaptee" element="io.questdb.cutlass.line.tcp.SymbolCache::symbolMapReader:io.questdb.cairo.SymbolMapReaderImpl" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.SymbolCache::keyOf(io.questdb.std.str.DirectByteCharSequence):int" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.wal.WalEventCursor" />
			<role name="Adapter" element="io.questdb.cairo.wal.SymbolMapDiffImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.SymbolMapDiffImpl::cursor:io.questdb.cairo.wal.WalEventCursor" />
			<role name="Request()" element="io.questdb.cairo.wal.SymbolMapDiffImpl::drain():void" />
			<role name="Request()" element="io.questdb.cairo.wal.SymbolMapDiffImpl::nextEntry():io.questdb.cairo.wal.SymbolMapDiffEntry" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.DataFrameCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::dataFrameCursor:io.questdb.cairo.sql.DataFrameCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::next():io.questdb.cairo.sql.PageFrame" />
			<role name="Request()" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.DataFrameCursor" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::dataFrameCursor:io.questdb.cairo.sql.DataFrameCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::next():io.questdb.cairo.sql.PageFrame" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.RecordMetadata" />
			<role name="Adapter" element="io.questdb.cairo.frm.file.PartitionFrame" />
			<role name="adaptee" element="io.questdb.cairo.frm.file.PartitionFrame::metadata:io.questdb.cairo.sql.RecordMetadata" />
			<role name="Request()" element="io.questdb.cairo.frm.file.PartitionFrame::columnCount():int" />
			<role name="Request()" element="io.questdb.cairo.frm.file.PartitionFrame::createColumn(int):io.questdb.cairo.frm.FrameColumn" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.network.EpollFacade" />
			<role name="Adapter" element="io.questdb.network.EventFdSuspendEvent" />
			<role name="adaptee" element="io.questdb.network.EventFdSuspendEvent::epf:io.questdb.network.EpollFacade" />
			<role name="Request()" element="io.questdb.network.EventFdSuspendEvent::_close():void" />
			<role name="Request()" element="io.questdb.network.EventFdSuspendEvent::checkTriggered():boolean" />
			<role name="Request()" element="io.questdb.network.EventFdSuspendEvent::trigger():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.FilesFacade" />
			<role name="Adapter" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl::close():void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl::hasNext():boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl::setPosition():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.griffin.engine.ops.InsertOperationImpl" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.InsertOperationImpl::insertRows:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.InsertOperationImpl::addInsertRow(io.questdb.griffin.InsertRowImpl):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableToken" />
			<role name="Adapter" element="io.questdb.griffin.engine.ops.InsertOperationImpl" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.InsertOperationImpl::tableToken:io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.InsertOperationImpl::createMethod(io.questdb.griffin.SqlExecutionContext, io.questdb.cairo.pool.WriterSource):io.questdb.cairo.sql.InsertMethod" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.ConcurrentBitmapIndexFwdReader" />
			<role name="Adapter" element="io.questdb.cairo.SymbolMapReaderImpl" />
			<role name="adaptee" element="io.questdb.cairo.SymbolMapReaderImpl::indexReader:io.questdb.cairo.ConcurrentBitmapIndexFwdReader" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapReaderImpl::updateSymbolCount(int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.frm.file.RecycleBin" />
			<role name="Adapter" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn" />
			<role name="adaptee" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::recycleBin:io.questdb.cairo.frm.file.RecycleBin" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.frm.file.RecycleBin" />
			<role name="Adapter" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn" />
			<role name="adaptee" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::recycleBin:io.questdb.cairo.frm.file.RecycleBin" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ConcurrentHashMap" />
			<role name="Adapter" element="io.questdb.test.cutlass.pgwire.PGQuerySuspendabilityTest$SuspendingReaderListener" />
			<role name="adaptee" element="io.questdb.test.cutlass.pgwire.PGQuerySuspendabilityTest$SuspendingReaderListener::suspendedPartitions:io.questdb.std.ConcurrentHashMap" />
			<role name="Request()" element="io.questdb.test.cutlass.pgwire.PGQuerySuspendabilityTest$SuspendingReaderListener::onOpenPartition(io.questdb.cairo.TableToken, int):void" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor" />
			<role name="Adaptee" element="io.questdb.cairo.TableReaderSelectedColumnRecord" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor::record:io.questdb.cairo.TableReaderSelectedColumnRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.network.KqueueFacade" />
			<role name="Adapter" element="io.questdb.network.PipeSuspendEvent" />
			<role name="adaptee" element="io.questdb.network.PipeSuspendEvent::kqf:io.questdb.network.KqueueFacade" />
			<role name="Request()" element="io.questdb.network.PipeSuspendEvent::_close():void" />
			<role name="Request()" element="io.questdb.network.PipeSuspendEvent::checkTriggered():boolean" />
			<role name="Request()" element="io.questdb.network.PipeSuspendEvent::trigger():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.ColumnVersionReader" />
			<role name="Adapter" element="io.questdb.cairo.frm.file.PartitionFrame" />
			<role name="adaptee" element="io.questdb.cairo.frm.file.PartitionFrame::crv:io.questdb.cairo.ColumnVersionReader" />
			<role name="Request()" element="io.questdb.cairo.frm.file.PartitionFrame::createColumn(int):io.questdb.cairo.frm.FrameColumn" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.test.cairo.pool.ReaderPoolTest$1Listener" />
			<role name="adaptee" element="io.questdb.test.cairo.pool.ReaderPoolTest$1Listener::names:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.test.cairo.pool.ReaderPoolTest$1Listener::onEvent(byte, long, io.questdb.cairo.TableToken, short, short, short):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.IntList" />
			<role name="Adapter" element="io.questdb.test.cairo.pool.ReaderPoolTest$1Listener" />
			<role name="adaptee" element="io.questdb.test.cairo.pool.ReaderPoolTest$1Listener::events:io.questdb.std.IntList" />
			<role name="Request()" element="io.questdb.test.cairo.pool.ReaderPoolTest$1Listener::onEvent(byte, long, io.questdb.cairo.TableToken, short, short, short):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.MemoryFCRImpl" />
			<role name="Adapter" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl::txnMetaMem:io.questdb.cairo.vm.MemoryFCRImpl" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl::next():io.questdb.cairo.wal.seq.TableMetadataChange" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.CharSequenceObjHashMap" />
			<role name="Adapter" element="io.questdb.cutlass.line.tcp.StaticPublicKeyRepo" />
			<role name="adaptee" element="io.questdb.cutlass.line.tcp.StaticPublicKeyRepo::publicKeyByKeyId:io.questdb.std.CharSequenceObjHashMap" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.StaticPublicKeyRepo::getPublicKey(java.lang.CharSequence):java.security.PublicKey" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.ObjList" />
			<role name="Adapter" element="io.questdb.metrics.MetricsRegistryImpl" />
			<role name="adaptee" element="io.questdb.metrics.MetricsRegistryImpl::metrics:io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.metrics.MetricsRegistryImpl::addScrapable(io.questdb.metrics.Scrapable):void" />
			<role name="Request()" element="io.questdb.metrics.MetricsRegistryImpl::newCounter(java.lang.CharSequence):io.questdb.metrics.Counter" />
			<role name="Request()" element="io.questdb.metrics.MetricsRegistryImpl::newCounter(java.lang.CharSequence, java.lang.CharSequence, java.lang.CharSequence[]):io.questdb.metrics.CounterWithOneLabel" />
			<role name="Request()" element="io.questdb.metrics.MetricsRegistryImpl::newCounter(java.lang.CharSequence, java.lang.CharSequence, java.lang.CharSequence[], java.lang.CharSequence, java.lang.CharSequence[]):io.questdb.metrics.CounterWithTwoLabels" />
			<role name="Request()" element="io.questdb.metrics.MetricsRegistryImpl::newDoubleGauge(java.lang.CharSequence):io.questdb.metrics.DoubleGauge" />
			<role name="Request()" element="io.questdb.metrics.MetricsRegistryImpl::newLongGauge(java.lang.CharSequence):io.questdb.metrics.LongGauge" />
			<role name="Request()" element="io.questdb.metrics.MetricsRegistryImpl::newLongGauge(int):io.questdb.metrics.LongGauge" />
			<role name="Request()" element="io.questdb.metrics.MetricsRegistryImpl::newVirtualGauge(java.lang.CharSequence, io.questdb.metrics.VirtualLongGauge$StatProvider):io.questdb.metrics.LongGauge" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.CharSequenceHashSet" />
			<role name="Adapter" element="io.questdb.metrics.GCMetrics" />
			<role name="adaptee" element="io.questdb.metrics.GCMetrics::majorGCNames:io.questdb.std.CharSequenceHashSet" />
			<role name="adaptee" element="io.questdb.metrics.GCMetrics::minorGCNames:io.questdb.std.CharSequenceHashSet" />
			<role name="Request()" element="io.questdb.metrics.GCMetrics::scrapeIntoPrometheus(io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.mp.SCSequence" />
			<role name="Adapter" element="io.questdb.griffin.engine.ops.OperationFutureImpl" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.OperationFutureImpl::eventSubSeq:io.questdb.mp.SCSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.OperationFutureImpl::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.RecordMetadata" />
			<role name="Adapter" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter" />
			<role name="adaptee" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::metadata:io.questdb.cairo.sql.RecordMetadata" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getSymbolCacheFlag(int):boolean" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getSymbolCapacity(int):int" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cairo.wal.seq.TableSequencerImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.seq.TableSequencerImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextStructureTxn(long, io.questdb.cairo.wal.seq.TableMetadataChange):long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextTxn(long, int, int, int):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cutlass.line.udp.UdpLineChannel" />
			<role name="adaptee" element="io.questdb.cutlass.line.udp.UdpLineChannel::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.UdpLineChannel::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.ops.OperationDispatcher" />
			<role name="Adapter" element="io.questdb.griffin.CompiledQueryImpl" />
			<role name="adaptee" element="io.questdb.griffin.CompiledQueryImpl::updateOperationDispatcher:io.questdb.griffin.engine.ops.OperationDispatcher" />
			<role name="adaptee" element="io.questdb.griffin.CompiledQueryImpl::alterOperationDispatcher:io.questdb.griffin.engine.ops.OperationDispatcher" />
			<role name="Request()" element="io.questdb.griffin.CompiledQueryImpl::execute(io.questdb.griffin.SqlExecutionContext, io.questdb.mp.SCSequence, boolean):io.questdb.cairo.sql.OperationFuture" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator" />
			<role name="Adaptee" element="io.questdb.cairo.security.SecurityContextFactory" />
			<role name="adaptee" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator::securityContextFactory:io.questdb.cairo.security.SecurityContextFactory" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator::processMessage(java.lang.CharSequence, long, long):io.questdb.cutlass.pgwire.PgWireAuthenticator$AuthenticationResult" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.metrics.LongGauge" />
			<role name="Adapter" element="io.questdb.std.AssociativeCache" />
			<role name="adaptee" element="io.questdb.std.AssociativeCache::cachedGauge:io.questdb.metrics.LongGauge" />
			<role name="Request()" element="io.questdb.std.AssociativeCache::clear():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.model.QueryModel" />
			<role name="Adapter" element="io.questdb.griffin.ExpressionTreeBuilder" />
			<role name="adaptee" element="io.questdb.griffin.ExpressionTreeBuilder::model:io.questdb.griffin.model.QueryModel" />
			<role name="Request()" element="io.questdb.griffin.ExpressionTreeBuilder::onNode(io.questdb.griffin.model.ExpressionNode):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.LifecycleManager" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::lifecycleManager:io.questdb.cairo.LifecycleManager" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::close():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.Metrics" />
			<role name="Adapter" element="io.questdb.cairo.TableWriter" />
			<role name="adaptee" element="io.questdb.cairo.TableWriter::metrics:io.questdb.Metrics" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::rollback():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.Metrics" />
			<role name="Adapter" element="io.questdb.cairo.wal.WalWriter" />
			<role name="adaptee" element="io.questdb.cairo.wal.WalWriter::metrics:io.questdb.Metrics" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::commit():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.frm.FrameColumnPool" />
			<role name="Adapter" element="io.questdb.cairo.frm.file.PartitionFrame" />
			<role name="adaptee" element="io.questdb.cairo.frm.file.PartitionFrame::columnPool:io.questdb.cairo.frm.FrameColumnPool" />
			<role name="Request()" element="io.questdb.cairo.frm.file.PartitionFrame::createColumn(int):io.questdb.cairo.frm.FrameColumn" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.CairoEngine" />
			<role name="Adapter" element="io.questdb.cairo.wal.seq.TableSequencerImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.seq.TableSequencerImpl::engine:io.questdb.cairo.CairoEngine" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::dropTable():void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextStructureTxn(long, io.questdb.cairo.wal.seq.TableMetadataChange):long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextTxn(long, int, int, int):long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::resumeTable():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.griffin.engine.ops.DoneOperationFuture" />
			<role name="Adapter" element="io.questdb.griffin.CompiledQueryImpl" />
			<role name="adaptee" element="io.questdb.griffin.CompiledQueryImpl::doneFuture:io.questdb.griffin.engine.ops.DoneOperationFuture" />
			<role name="Request()" element="io.questdb.griffin.CompiledQueryImpl::execute(io.questdb.griffin.SqlExecutionContext, io.questdb.mp.SCSequence, boolean):io.questdb.cairo.sql.OperationFuture" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryR" />
			<role name="Adapter" element="io.questdb.test.cairo.map.CompactMapTest$MockHash" />
			<role name="adaptee" element="io.questdb.test.cairo.map.CompactMapTest$MockHash::mem:io.questdb.cairo.vm.api.MemoryR" />
			<role name="Request()" element="io.questdb.test.cairo.map.CompactMapTest$MockHash::hash(long, long):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.vm.api.MemoryR" />
			<role name="Adapter" element="io.questdb.test.cairo.map.CompactMapTest$MockHash2" />
			<role name="adaptee" element="io.questdb.test.cairo.map.CompactMapTest$MockHash2::mem:io.questdb.cairo.vm.api.MemoryR" />
			<role name="Request()" element="io.questdb.test.cairo.map.CompactMapTest$MockHash2::hash(long, long):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.wal.seq.EmptyOperationCursor" />
			<role name="Adapter" element="io.questdb.cairo.wal.seq.TableSequencerImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.seq.TableSequencerImpl::emptyOperationCursor:io.questdb.cairo.wal.seq.EmptyOperationCursor" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::getMetadataChangeLog(long):io.questdb.cairo.wal.seq.TableMetadataChangeLog" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Adapter" element="io.questdb.cairo.wal.seq.TableSequencerImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.seq.TableSequencerImpl::microClock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::dropTable():void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextStructureTxn(long, io.questdb.cairo.wal.seq.TableMetadataChange):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="adaptee" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onLineEnd(io.questdb.cutlass.line.udp.CharSequenceCache):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cutlass.pgwire.PgWireUserDatabase" />
			<role name="Adapter" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator" />
			<role name="adaptee" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator::userDatabase:io.questdb.cutlass.pgwire.PgWireUserDatabase" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator::processMessage(java.lang.CharSequence, long, long):io.questdb.cutlass.pgwire.PgWireAuthenticator$AuthenticationResult" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.tasks.TelemetryTask" />
			<role name="adaptee" element="io.questdb.tasks.TelemetryTask::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.tasks.TelemetryTask::writeTo(io.questdb.cairo.TableWriter, long):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.tasks.TelemetryWalTask" />
			<role name="adaptee" element="io.questdb.tasks.TelemetryWalTask::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.tasks.TelemetryWalTask::writeTo(io.questdb.cairo.TableWriter, long):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.metrics.Counter" />
			<role name="Adapter" element="io.questdb.metrics.HealthMetricsImpl" />
			<role name="adaptee" element="io.questdb.metrics.HealthMetricsImpl::unhandledErrorCounter:io.questdb.metrics.Counter" />
			<role name="Request()" element="io.questdb.metrics.HealthMetricsImpl::incrementUnhandledErrors():void" />
			<role name="Request()" element="io.questdb.metrics.HealthMetricsImpl::unhandledErrorsCount():long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$Sequence" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$Sequence::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndBinCCCFunctionFactory$Sequence::byteAt(long):byte" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.Rnd" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.rnd.RndBinFunctionFactory$Sequence" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.rnd.RndBinFunctionFactory$Sequence::rnd:io.questdb.std.Rnd" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.rnd.RndBinFunctionFactory$Sequence::byteAt(long):byte" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Adapter" element="io.questdb.log.Logger" />
			<role name="adaptee" element="io.questdb.log.Logger::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.log.Logger::ts():io.questdb.log.LogRecord" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Adapter" element="io.questdb.log.SyncLogger" />
			<role name="adaptee" element="io.questdb.log.SyncLogger::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.log.SyncLogger::ts():io.questdb.log.LogRecord" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.str.DirectCharSequence" />
			<role name="Adapter" element="io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList::strA:io.questdb.std.str.DirectCharSequence" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList::strB:io.questdb.std.str.DirectCharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList::getStrA(int):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation$DirectCharSequenceList::getStrB(int):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.log.Log" />
			<role name="Adapter" element="io.questdb.cairo.AbstractIndexReader" />
			<role name="adaptee" element="io.questdb.cairo.AbstractIndexReader::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.AbstractIndexReader::of(io.questdb.cairo.CairoConfiguration, io.questdb.std.str.Path, java.lang.CharSequence, long, long):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Adapter" element="io.questdb.cairo.AbstractIndexReader" />
			<role name="adaptee" element="io.questdb.cairo.AbstractIndexReader::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cairo.AbstractIndexReader::of(io.questdb.cairo.CairoConfiguration, io.questdb.std.str.Path, java.lang.CharSequence, long, long):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.SymbolValueCountCollector" />
			<role name="Adapter" element="io.questdb.cairo.SymbolMapWriter" />
			<role name="adaptee" element="io.questdb.cairo.SymbolMapWriter::valueCountCollector:io.questdb.cairo.SymbolValueCountCollector" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::rollback(int):void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableWriterAPI" />
			<role name="Adapter" element="io.questdb.griffin.engine.ops.InsertOperationImpl$InsertMethodImpl" />
			<role name="adaptee" element="io.questdb.griffin.engine.ops.InsertOperationImpl$InsertMethodImpl::writer:io.questdb.cairo.TableWriterAPI" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.InsertOperationImpl$InsertMethodImpl::commit():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Adapter" element="io.questdb.griffin.engine.functions.date.SysdateFunctionFactory$Func" />
			<role name="adaptee" element="io.questdb.griffin.engine.functions.date.SysdateFunctionFactory$Func::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.SysdateFunctionFactory$Func::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.Record" />
			<role name="Adapter" element="io.questdb.test.griffin.engine.orderby.LimitedSizeLongTreeChainTest$TestRecordComparator" />
			<role name="adaptee" element="io.questdb.test.griffin.engine.orderby.LimitedSizeLongTreeChainTest$TestRecordComparator::left:io.questdb.cairo.sql.Record" />
			<role name="Request()" element="io.questdb.test.griffin.engine.orderby.LimitedSizeLongTreeChainTest$TestRecordComparator::compare(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Adapter" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor" />
			<role name="Adaptee" element="io.questdb.cairo.sql.Function" />
			<role name="adaptee" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Adapter" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker" />
			<role name="adaptee" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker::checkIfTripped(long, int):boolean" />
			<role name="Request()" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker::resetTimer():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.MemorySerializer" />
			<role name="Adapter" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl" />
			<role name="adaptee" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl::serializer:io.questdb.cairo.MemorySerializer" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl::next():io.questdb.cairo.wal.seq.TableMetadataChange" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.sql.InsertOperation" />
			<role name="Adapter" element="io.questdb.griffin.CompiledQueryImpl" />
			<role name="adaptee" element="io.questdb.griffin.CompiledQueryImpl::insertOp:io.questdb.cairo.sql.InsertOperation" />
			<role name="Request()" element="io.questdb.griffin.CompiledQueryImpl::execute(io.questdb.griffin.SqlExecutionContext, io.questdb.mp.SCSequence, boolean):io.questdb.cairo.sql.OperationFuture" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Adapter" element="io.questdb.griffin.SqlExecutionContextImpl" />
			<role name="adaptee" element="io.questdb.griffin.SqlExecutionContextImpl::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.griffin.SqlExecutionContextImpl::getMicrosecondTimestamp():long" />
			<role name="Request()" element="io.questdb.griffin.SqlExecutionContextImpl::initNow():void" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.cairo.TableToken" />
			<role name="Adapter" element="io.questdb.cairo.AbstractDataFrameCursorFactory" />
			<role name="adaptee" element="io.questdb.cairo.AbstractDataFrameCursorFactory::tableToken:io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.AbstractDataFrameCursorFactory::supportTableRowId(io.questdb.cairo.TableToken):boolean" />
		</instance>
		<instance>
			<role name="Adaptee" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Adapter" element="io.questdb.cutlass.line.tcp.SymbolCache" />
			<role name="adaptee" element="io.questdb.cutlass.line.tcp.SymbolCache::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.SymbolCache::keyOf(io.questdb.std.str.DirectByteCharSequence):int" />
		</instance>
	</pattern>
	<pattern name="Command" />
	<pattern name="Composite" />
	<pattern name="Decorator">
		<instance>
			<role name="Component" element="io.questdb.std.datetime.DateFormat" />
			<role name="Decorator" element="io.questdb.cairo.ptt.IsoDatePartitionFormat" />
			<role name="component" element="io.questdb.cairo.ptt.IsoDatePartitionFormat::baseFormat:io.questdb.std.datetime.DateFormat" />
			<role name="Operation()" element="io.questdb.cairo.ptt.IsoDatePartitionFormat::format(long, io.questdb.std.datetime.DateLocale, java.lang.CharSequence, io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.cairo.sql.PageFrameCursor" />
			<role name="Decorator" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrameCursor" />
			<role name="component" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrameCursor::baseCursor:io.questdb.cairo.sql.PageFrameCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrameCursor::close():void" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrameCursor::getUpdateRowId(long):long" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrameCursor::next():io.questdb.cairo.sql.PageFrame" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrameCursor::size():long" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrameCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.cairo.ColumnTypes" />
			<role name="Decorator" element="io.questdb.cairo.SymbolAsIntTypes" />
			<role name="component" element="io.questdb.cairo.SymbolAsIntTypes::base:io.questdb.cairo.ColumnTypes" />
			<role name="Operation()" element="io.questdb.cairo.SymbolAsIntTypes::getColumnCount():int" />
			<role name="Operation()" element="io.questdb.cairo.SymbolAsIntTypes::getColumnType(int):int" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.cairo.ColumnTypes" />
			<role name="Decorator" element="io.questdb.cairo.SymbolAsStrTypes" />
			<role name="component" element="io.questdb.cairo.SymbolAsStrTypes::base:io.questdb.cairo.ColumnTypes" />
			<role name="Operation()" element="io.questdb.cairo.SymbolAsStrTypes::getColumnCount():int" />
			<role name="Operation()" element="io.questdb.cairo.SymbolAsStrTypes::getColumnType(int):int" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.cairo.sql.RowCursor" />
			<role name="Decorator" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory$SequentialRowCursor" />
			<role name="component" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory$SequentialRowCursor::currentCursor:io.questdb.cairo.sql.RowCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory$SequentialRowCursor::hasNext():boolean" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SequentialRowCursorFactory$SequentialRowCursor::next():long" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.cairo.sql.RowCursor" />
			<role name="Decorator" element="io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory$ListBasedSymbolIndexRowCursor" />
			<role name="component" element="io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory$ListBasedSymbolIndexRowCursor::current:io.questdb.cairo.sql.RowCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory$ListBasedSymbolIndexRowCursor::hasNext():boolean" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory$ListBasedSymbolIndexRowCursor::next():long" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.cairo.sql.RowCursor" />
			<role name="Decorator" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor" />
			<role name="component" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor::rowCursor:io.questdb.cairo.sql.RowCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.AbstractVirtualFunctionRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.AbstractVirtualFunctionRecordCursor::baseCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.AbstractVirtualFunctionRecordCursor::hasNext():boolean" />
			<role name="Operation()" element="io.questdb.griffin.engine.AbstractVirtualFunctionRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.AbstractVirtualFunctionRecordCursor::size():long" />
			<role name="Operation()" element="io.questdb.griffin.engine.AbstractVirtualFunctionRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::base:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::close():void" />
			<role name="Operation()" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::getRecord():io.questdb.cairo.sql.Record" />
			<role name="Operation()" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::getRecordB():io.questdb.cairo.sql.Record" />
			<role name="Operation()" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::hasNext():boolean" />
			<role name="Operation()" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::baseCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::getRecordB():io.questdb.cairo.sql.Record" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::hasNext():boolean" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::baseCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::getRecordB():io.questdb.cairo.sql.Record" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::hasNext():boolean" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.join.RecordAsAFieldRecordCursorFactory$RecordAsAFieldRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.join.RecordAsAFieldRecordCursorFactory$RecordAsAFieldRecordCursor::base:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.join.RecordAsAFieldRecordCursorFactory$RecordAsAFieldRecordCursor::hasNext():boolean" />
			<role name="Operation()" element="io.questdb.griffin.engine.join.RecordAsAFieldRecordCursorFactory$RecordAsAFieldRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.join.RecordAsAFieldRecordCursorFactory$RecordAsAFieldRecordCursor::size():long" />
			<role name="Operation()" element="io.questdb.griffin.engine.join.RecordAsAFieldRecordCursorFactory$RecordAsAFieldRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursor::base:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursor::getRecordB():io.questdb.cairo.sql.Record" />
			<role name="Operation()" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.orderby.RecordTreeChain$TreeCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.orderby.RecordTreeChain$TreeCursor::base:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.orderby.RecordTreeChain$TreeCursor::size():long" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.orderby.SortedLightRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.orderby.SortedLightRecordCursor::base:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.orderby.SortedLightRecordCursor::getRecordB():io.questdb.cairo.sql.Record" />
			<role name="Operation()" element="io.questdb.griffin.engine.orderby.SortedLightRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.orderby.SortedLightRecordCursor::size():long" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.orderby.SortedRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.orderby.SortedRecordCursor::base:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.orderby.SortedRecordCursor::size():long" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.table.FilteredRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.table.FilteredRecordCursor::base:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.FilteredRecordCursor::getRecordB():io.questdb.cairo.sql.Record" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.FilteredRecordCursor::hasNext():boolean" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.FilteredRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.FilteredRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::baseCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::mapCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::getRecordB():io.questdb.cairo.sql.Record" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::hasNext():boolean" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::size():long" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.table.SelectedRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.griffin.engine.table.SelectedRecordCursor::baseCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursor::close():void" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursor::hasNext():boolean" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursor::size():long" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.test.griffin.CompiledFilterRegressionTest$CountingRecordCursor" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="component" element="io.questdb.test.griffin.CompiledFilterRegressionTest$CountingRecordCursor::delegate:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.test.griffin.CompiledFilterRegressionTest$CountingRecordCursor::close():void" />
			<role name="Operation()" element="io.questdb.test.griffin.CompiledFilterRegressionTest$CountingRecordCursor::getRecord():io.questdb.cairo.sql.Record" />
			<role name="Operation()" element="io.questdb.test.griffin.CompiledFilterRegressionTest$CountingRecordCursor::getRecordB():io.questdb.cairo.sql.Record" />
			<role name="Operation()" element="io.questdb.test.griffin.CompiledFilterRegressionTest$CountingRecordCursor::hasNext():boolean" />
			<role name="Operation()" element="io.questdb.test.griffin.CompiledFilterRegressionTest$CountingRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Operation()" element="io.questdb.test.griffin.CompiledFilterRegressionTest$CountingRecordCursor::size():long" />
			<role name="Operation()" element="io.questdb.test.griffin.CompiledFilterRegressionTest$CountingRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Decorator" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper" />
			<role name="component" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::conf:io.questdb.cairo.CairoConfiguration" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getCopyIDSupplier():java.util.function.LongSupplier" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::enableTestFactories():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getAllowTableRegistrySharedWrite():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getAnalyticColumnPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getAttachPartitionSuffix():java.lang.String" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getBackupDirTimestampFormat():io.questdb.std.datetime.DateFormat" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getBackupMkDirMode():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getBackupRoot():java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getBackupTempDirName():java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getBinaryEncodingMaxLength():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getBindVariablePoolSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getBuildInformation():io.questdb.BuildInformation" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getCircuitBreakerConfiguration():io.questdb.cairo.sql.SqlExecutionCircuitBreakerConfiguration" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getColumnCastModelPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getColumnIndexerQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getColumnPurgeQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getColumnPurgeRetryDelay():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getColumnPurgeRetryDelayLimit():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getColumnPurgeRetryDelayMultiplier():double" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getColumnPurgeTaskPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getCommitMode():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getConfRoot():java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getCopyPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getCreateAsSelectRetryCount():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getCreateTableModelPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getDataAppendPageSize():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getDataIndexKeyAppendPageSize():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getDataIndexValueAppendPageSize():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getDatabaseIdHi():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getDatabaseIdLo():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getDbDirectory():java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getDefaultDateLocale():io.questdb.std.datetime.DateLocale" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getDefaultMapType():java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getDefaultSymbolCacheFlag():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getDefaultSymbolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getDoubleToStrCastScale():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getExplainPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getFactoryProvider():io.questdb.FactoryProvider" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getFileOperationRetryCount():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getFilesFacade():io.questdb.std.FilesFacade" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getFloatToStrCastScale():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getGroupByMapCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getGroupByPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getIdleCheckInterval():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getInactiveReaderMaxOpenPartitions():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getInactiveReaderTTL():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getInactiveWalWriterTTL():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getInactiveWriterTTL():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getIndexValueBlockSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getInsertPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getLatestByQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getMaxCrashFiles():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getMaxFileNameLength():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getO3LastPartitionMaxSplits():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getMaxSwapFileCount():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getMaxSymbolNotEqualsCount():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getMaxUncommittedRows():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getMetadataPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getMiscAppendPageSize():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getMkDirMode():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getO3CallbackQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getO3ColumnMemorySize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getO3CopyQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getO3LagCalculationWindowsSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getO3MaxLag():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getO3MemMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getO3MinLag():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getO3OpenColumnQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getO3PartitionQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getO3PurgeDiscoveryQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getPageFrameReduceColumnListCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getPageFrameReduceQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getPageFrameReduceRowIdListCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getPageFrameReduceShardCount():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getPageFrameReduceTaskPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getParallelIndexThreshold():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getPartitionO3SplitMinSize():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getPartitionPurgeListCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getQueryCacheEventQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getReaderPoolMaxSegments():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getRenameTableModelPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getRepeatMigrationsFromVersion():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getRndFunctionMemoryMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getRndFunctionMemoryPageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getRoot():java.lang.String" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSampleByIndexSearchPageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSimulateCrashEnabled():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSnapshotInstanceId():java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSnapshotRoot():java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSpinLockTimeout():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlAnalyticRowIdMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlAnalyticRowIdPageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlAnalyticStoreMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlAnalyticStorePageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlAnalyticTreeKeyMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlAnalyticTreeKeyPageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlCharacterStoreCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlCharacterStoreSequencePoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlColumnPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlCompactMapLoadFactor():double" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlCopyBufferSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlCopyInputRoot():java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlCopyInputWorkRoot():java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlCopyLogRetentionDays():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlCopyMaxIndexChunkSize():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlCopyQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlDistinctTimestampKeyCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlDistinctTimestampLoadFactor():double" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlExpressionPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlFastMapLoadFactor():double" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlHashJoinLightValueMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlHashJoinLightValuePageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlHashJoinValueMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlHashJoinValuePageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlJitBindVarsMemoryMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlJitBindVarsMemoryPageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlJitIRMemoryMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlJitIRMemoryPageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlJitMode():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlJitPageAddressCacheThreshold():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlJitRowsThreshold():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlJoinContextPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlJoinMetadataMaxResizes():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlJoinMetadataPageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlLatestByRowCount():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlLexerPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlMapKeyCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlMapMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlMapMaxResizes():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlMapPageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlMaxNegativeLimit():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlModelPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlPageFrameMaxRows():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlPageFrameMinRows():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlSmallMapKeyCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlSmallMapPageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlSortKeyMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlSortKeyPageSize():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlSortLightValueMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlSortLightValuePageSize():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlSortValueMaxPages():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSqlSortValuePageSize():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getStrFunctionMaxBufferLength():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getSystemTableNamePrefix():java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getTableRegistryAutoReloadFrequency():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getTableRegistryCompactionThreshold():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getTelemetryConfiguration():io.questdb.TelemetryConfiguration" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getTextConfiguration():io.questdb.cutlass.text.TextConfiguration" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getTxnScoreboardEntryCount():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getVectorAggregateQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getVolumeDefinitions():io.questdb.VolumeDefinitions" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWalApplyLookAheadTransactionCount():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWalApplyTableTimeQuota():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWalDataAppendPageSize():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWalEnabledDefault():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWalPurgeInterval():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWalRecreateDistressedSequencerAttempts():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWalSegmentRolloverRowCount():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWalSquashUncommittedRowsMultiplier():double" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWalTxnNotificationQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWithClauseModelPoolCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWorkStealTimeoutNanos():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWriterAsyncCommandBusyWaitTimeout():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWriterAsyncCommandMaxTimeout():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWriterCommandQueueCapacity():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWriterCommandQueueSlotSize():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWriterFileOpenOpts():long" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::getWriterTickRowsCountMod():int" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::isIOURingEnabled():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::isO3QuickSortEnabled():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::isParallelIndexingEnabled():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::isReadOnlyInstance():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::isSnapshotRecoveryEnabled():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::isSqlJitDebugEnabled():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::isSqlParallelFilterEnabled():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::isSqlParallelFilterPreTouchEnabled():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::isTableTypeConversionEnabled():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::isWalSupported():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::isWriterMixedIOEnabled():boolean" />
			<role name="Operation()" element="io.questdb.test.cutlass.text.CairoConfigurationWrapper::mangleTableDirNames():boolean" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.LimitRecordCursorFactory" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="component" element="io.questdb.griffin.engine.LimitRecordCursorFactory::base:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.LimitRecordCursorFactory::recordCursorSupportsRandomAccess():boolean" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="component" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory::base:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory::recordCursorSupportsRandomAccess():boolean" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="component" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory::base:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory::recordCursorSupportsRandomAccess():boolean" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.join.RecordAsAFieldRecordCursorFactory" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="component" element="io.questdb.griffin.engine.join.RecordAsAFieldRecordCursorFactory::base:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.join.RecordAsAFieldRecordCursorFactory::recordCursorSupportsRandomAccess():boolean" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursorFactory" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="component" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursorFactory::base:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursorFactory::recordCursorSupportsRandomAccess():boolean" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.table.FilteredRecordCursorFactory" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="component" element="io.questdb.griffin.engine.table.FilteredRecordCursorFactory::base:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.FilteredRecordCursorFactory::recordCursorSupportsRandomAccess():boolean" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="component" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory::base:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory::recordCursorSupportsRandomAccess():boolean" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="component" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory::base:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory::recordCursorSupportsRandomAccess():boolean" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="component" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory::base:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory::recordCursorSupportsRandomAccess():boolean" />
		</instance>
		<instance>
			<role name="Decorator" element="io.questdb.griffin.engine.union.AbstractSetRecordCursorFactory" />
			<role name="Component" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="component" element="io.questdb.griffin.engine.union.AbstractSetRecordCursorFactory::factoryA:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="component" element="io.questdb.griffin.engine.union.AbstractSetRecordCursorFactory::factoryB:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.union.AbstractSetRecordCursorFactory::recordCursorSupportsRandomAccess():boolean" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.griffin.engine.functions.SymbolFunction" />
			<role name="Decorator" element="io.questdb.griffin.engine.functions.groupby.FirstSymbolGroupByFunction" />
			<role name="component" element="io.questdb.griffin.engine.functions.groupby.FirstSymbolGroupByFunction::arg:io.questdb.griffin.engine.functions.SymbolFunction" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.groupby.FirstSymbolGroupByFunction::isSymbolTableStatic():boolean" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.cairo.sql.SymbolTable" />
			<role name="Decorator" element="io.questdb.griffin.engine.functions.columns.SymbolColumn" />
			<role name="component" element="io.questdb.griffin.engine.functions.columns.SymbolColumn::symbolTable:io.questdb.cairo.sql.SymbolTable" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.columns.SymbolColumn::valueBOf(int):java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.columns.SymbolColumn::valueOf(int):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.cairo.sql.SymbolTable" />
			<role name="Decorator" element="io.questdb.griffin.engine.groupby.MapSymbolColumn" />
			<role name="component" element="io.questdb.griffin.engine.groupby.MapSymbolColumn::symbolTable:io.questdb.cairo.sql.SymbolTable" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.MapSymbolColumn::valueBOf(int):java.lang.CharSequence" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.MapSymbolColumn::valueOf(int):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.griffin.engine.functions.GroupByFunction" />
			<role name="Decorator" element="io.questdb.griffin.engine.functions.groupby.InterpolationGroupByFunction" />
			<role name="component" element="io.questdb.griffin.engine.functions.groupby.InterpolationGroupByFunction::wrappedFunction:io.questdb.griffin.engine.functions.GroupByFunction" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.groupby.InterpolationGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.groupby.InterpolationGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.groupby.InterpolationGroupByFunction::pushValueTypes(io.questdb.cairo.ArrayColumnTypes):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.groupby.InterpolationGroupByFunction::setNull(io.questdb.cairo.map.MapValue):void" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Decorator" element="io.questdb.griffin.engine.table.LatestBySubQueryRecordCursorFactory$DataFrameRecordCursorWrapper" />
			<role name="component" element="io.questdb.griffin.engine.table.LatestBySubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::delegate:io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.LatestBySubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::getColumnIndexes():io.questdb.std.IntList" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.LatestBySubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::getDataFrameCursor():io.questdb.cairo.sql.DataFrameCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.LatestBySubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::getSymbolTable(int):io.questdb.cairo.sql.StaticSymbolTable" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.LatestBySubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::of(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.griffin.FunctionFactory" />
			<role name="Decorator" element="io.questdb.griffin.engine.functions.NegatingFunctionFactory" />
			<role name="component" element="io.questdb.griffin.engine.functions.NegatingFunctionFactory::delegate:io.questdb.griffin.FunctionFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.NegatingFunctionFactory::newInstance(int, io.questdb.std.ObjList, io.questdb.std.IntList, io.questdb.cairo.CairoConfiguration, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.Function" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.griffin.FunctionFactory" />
			<role name="Decorator" element="io.questdb.griffin.engine.functions.SwappingArgsFunctionFactory" />
			<role name="component" element="io.questdb.griffin.engine.functions.SwappingArgsFunctionFactory::delegate:io.questdb.griffin.FunctionFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.SwappingArgsFunctionFactory::newInstance(int, io.questdb.std.ObjList, io.questdb.std.IntList, io.questdb.cairo.CairoConfiguration, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.Function" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.cutlass.line.LineChannel" />
			<role name="Decorator" element="io.questdb.cutlass.line.tcp.DelegatingTlsChannel" />
			<role name="component" element="io.questdb.cutlass.line.tcp.DelegatingTlsChannel::delegate:io.questdb.cutlass.line.LineChannel" />
			<role name="Operation()" element="io.questdb.cutlass.line.tcp.DelegatingTlsChannel::errno():int" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.mp.Barrier" />
			<role name="Decorator" element="io.questdb.mp.FanOut" />
			<role name="component" element="io.questdb.mp.FanOut::barrier:io.questdb.mp.Barrier" />
			<role name="Operation()" element="io.questdb.mp.FanOut::availableIndex(long):long" />
			<role name="Operation()" element="io.questdb.mp.FanOut::current():long" />
			<role name="Operation()" element="io.questdb.mp.FanOut::root():io.questdb.mp.Barrier" />
			<role name="Operation()" element="io.questdb.mp.FanOut::setBarrier(io.questdb.mp.Barrier):void" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.log.Log" />
			<role name="Decorator" element="io.questdb.log.LogFactory$DeferredLogger" />
			<role name="component" element="io.questdb.log.LogFactory$DeferredLogger::delegate:io.questdb.log.Log" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::advisory():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::advisoryW():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::critical():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::criticalW():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::debug():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::debugW():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::error():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::errorW():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::info():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::infoW():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::xDebugW():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::xInfoW():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::xadvisory():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::xcritical():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::xdebug():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::xerror():io.questdb.log.LogRecord" />
			<role name="Operation()" element="io.questdb.log.LogFactory$DeferredLogger::xinfo():io.questdb.log.LogRecord" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.cairo.sql.PageFrame" />
			<role name="Decorator" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame" />
			<role name="component" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::baseFrame:io.questdb.cairo.sql.PageFrame" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getBitmapIndexReader(int, int):io.questdb.cairo.BitmapIndexReader" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getColumnShiftBits(int):int" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getIndexPageAddress(int):long" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getPageAddress(int):long" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getPageSize(int):long" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getPartitionHi():long" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getPartitionIndex():int" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.SelectedRecordCursorFactory$SelectedPageFrame::getPartitionLo():long" />
		</instance>
		<instance>
			<role name="Component" element="io.questdb.metrics.MetricsRegistry" />
			<role name="Decorator" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry" />
			<role name="component" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::delegate:io.questdb.metrics.MetricsRegistry" />
			<role name="Operation()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::addScrapable(io.questdb.metrics.Scrapable):void" />
			<role name="Operation()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newCounter(java.lang.CharSequence):io.questdb.metrics.Counter" />
			<role name="Operation()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newCounter(java.lang.CharSequence, java.lang.CharSequence, java.lang.CharSequence[]):io.questdb.metrics.CounterWithOneLabel" />
			<role name="Operation()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newCounter(java.lang.CharSequence, java.lang.CharSequence, java.lang.CharSequence[], java.lang.CharSequence, java.lang.CharSequence[]):io.questdb.metrics.CounterWithTwoLabels" />
			<role name="Operation()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newDoubleGauge(java.lang.CharSequence):io.questdb.metrics.DoubleGauge" />
			<role name="Operation()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newLongGauge(java.lang.CharSequence):io.questdb.metrics.LongGauge" />
			<role name="Operation()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newLongGauge(int):io.questdb.metrics.LongGauge" />
			<role name="Operation()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newVirtualGauge(java.lang.CharSequence, io.questdb.metrics.VirtualLongGauge$StatProvider):io.questdb.metrics.LongGauge" />
		</instance>
	</pattern>
	<pattern name="Observer" />
	<pattern name="State">
		<instance>
			<role name="State" element="io.questdb.cairo.PartitionBy$PartitionFloorMethod" />
			<role name="Context" element="io.questdb.cairo.TxReader" />
			<role name="state" element="io.questdb.cairo.TxReader::partitionFloorMethod:io.questdb.cairo.PartitionBy$PartitionFloorMethod" />
			<role name="Request()" element="io.questdb.cairo.TxReader::getNextPartitionTimestamp(long):long" />
			<role name="Request()" element="io.questdb.cairo.TxReader::getPartitionFloor(long):long" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.griffin.InsertRowImpl$RowFactory" />
			<role name="Context" element="io.questdb.griffin.InsertRowImpl" />
			<role name="state" element="io.questdb.griffin.InsertRowImpl::rowFactory:io.questdb.griffin.InsertRowImpl$RowFactory" />
			<role name="Request()" element="io.questdb.griffin.InsertRowImpl::append(io.questdb.cairo.TableWriterAPI):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.griffin.RecordToRowCopier" />
			<role name="Context" element="io.questdb.griffin.InsertRowImpl" />
			<role name="state" element="io.questdb.griffin.InsertRowImpl::copier:io.questdb.griffin.RecordToRowCopier" />
			<role name="Request()" element="io.questdb.griffin.InsertRowImpl::append(io.questdb.cairo.TableWriterAPI):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.TableWriter$ExtensionListener" />
			<role name="Context" element="io.questdb.cairo.TxWriter" />
			<role name="state" element="io.questdb.cairo.TxWriter::extensionListener:io.questdb.cairo.TableWriter$ExtensionListener" />
			<role name="Request()" element="io.questdb.cairo.TxWriter::switchPartitions(long):void" />
			<role name="Request()" element="io.questdb.cairo.TxWriter::insertPartitionSizeByTimestamp(int, long, long, long):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.Numbers$LongHexAppender" />
			<role name="Context" element="io.questdb.std.Numbers" />
			<role name="state" element="io.questdb.std.Numbers::longHexAppenderPad64:io.questdb.std.Numbers$LongHexAppender[]" />
			<role name="state" element="io.questdb.std.Numbers::longHexAppender:io.questdb.std.Numbers$LongHexAppender[]" />
			<role name="Request()" element="io.questdb.std.Numbers::appendHex(io.questdb.std.str.CharSink, long, boolean):void" />
			<role name="Request()" element="io.questdb.std.Numbers::appendHexPadded(io.questdb.std.str.CharSink, long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.SerialCsvFileImporter" />
			<role name="State" element="io.questdb.cutlass.text.ParallelCsvFileImporter$PhaseStatusReporter" />
			<role name="state" element="io.questdb.cutlass.text.SerialCsvFileImporter::statusReporter:io.questdb.cutlass.text.ParallelCsvFileImporter$PhaseStatusReporter" />
			<role name="Request()" element="io.questdb.cutlass.text.SerialCsvFileImporter::updateImportStatus(byte, long, long, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.mp.Worker" />
			<role name="State" element="io.questdb.mp.WorkerCleaner" />
			<role name="state" element="io.questdb.mp.Worker::cleaner:io.questdb.mp.WorkerCleaner" />
			<role name="Request()" element="io.questdb.mp.Worker::run():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$SymbolInCursorFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$SymbolInCursorFunction::cursorArg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$SymbolInCursorFunction::init(io.questdb.cairo.sql.SymbolTableSource, io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.array.StrArrayDereferenceFunctionFactory$StrArrayDereferenceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.array.StrArrayDereferenceFunctionFactory$StrArrayDereferenceFunction::arrayFunction:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.array.StrArrayDereferenceFunctionFactory$StrArrayDereferenceFunction::indexFunction:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.array.StrArrayDereferenceFunctionFactory$StrArrayDereferenceFunction::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.array.StrArrayDereferenceFunctionFactory$StrArrayDereferenceFunction::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.array.StrArrayDereferenceFunctionFactory$StrArrayDereferenceFunction::getStrLen(io.questdb.cairo.sql.Record, int):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bind.CompiledFilterSymbolBindVariable" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bind.CompiledFilterSymbolBindVariable::symbolFunction:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bind.CompiledFilterSymbolBindVariable::getInt(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bind.CompiledFilterSymbolBindVariable::getSymbol(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bind.CompiledFilterSymbolBindVariable::getSymbolB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bind.NamedParameterLinkFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bind.NamedParameterLinkFunction::base:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bind.NamedParameterLinkFunction::init(io.questdb.cairo.sql.SymbolTableSource, io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.AllNotEqStrFunctionFactory$AllNotEqualStrFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.AllNotEqStrFunctionFactory$AllNotEqualStrFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.AllNotEqStrFunctionFactory$AllNotEqualStrFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.AndFunctionFactory$AndBooleanFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.AndFunctionFactory$AndBooleanFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.AndFunctionFactory$AndBooleanFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.AndFunctionFactory$AndBooleanFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.BetweenTimestampFunctionFactory$ConstFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.BetweenTimestampFunctionFactory$ConstFunc::left:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.BetweenTimestampFunctionFactory$ConstFunc::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.BetweenTimestampFunctionFactory$VarBetweenFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.BetweenTimestampFunctionFactory$VarBetweenFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.BetweenTimestampFunctionFactory$VarBetweenFunction::from:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.BetweenTimestampFunctionFactory$VarBetweenFunction::to:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.BetweenTimestampFunctionFactory$VarBetweenFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InCharFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InCharFunctionFactory$Func::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InStrFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InStrFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InStrFunctionFactory$Func::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$StrInCursorFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$StrInCursorFunction::valueArg:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$StrInCursorFunction::cursorArg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$StrInCursorFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$StrInCursorFunction::init(io.questdb.cairo.sql.SymbolTableSource, io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InTimestampStrFunctionFactory$EqTimestampStrConstantFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InTimestampStrFunctionFactory$EqTimestampStrConstantFunction::left:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InTimestampStrFunctionFactory$EqTimestampStrConstantFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InTimestampStrFunctionFactory$EqTimestampStrFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InTimestampStrFunctionFactory$EqTimestampStrFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InTimestampStrFunctionFactory$EqTimestampStrFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InTimestampStrFunctionFactory$EqTimestampStrFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InTimestampTimestampFunctionFactory$InTimestampConstFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InTimestampTimestampFunctionFactory$InTimestampConstFunction::tsFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InTimestampTimestampFunctionFactory$InTimestampConstFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InUuidFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InUuidFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InUuidFunctionFactory$Func::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.NotFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.NotFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.NotFunctionFactory$Func::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.OrFunctionFactory$MyBooleanFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.OrFunctionFactory$MyBooleanFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.OrFunctionFactory$MyBooleanFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.OrFunctionFactory$MyBooleanFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastBooleanToByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastBooleanToByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastBooleanToByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastBooleanToCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastBooleanToCharFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastBooleanToCharFunctionFactory$Func::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastBooleanToDateFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastBooleanToDateFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastBooleanToDateFunctionFactory$Func::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastBooleanToDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastBooleanToDoubleFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastBooleanToDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastBooleanToFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastBooleanToFloatFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastBooleanToFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastBooleanToShortFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastBooleanToShortFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastBooleanToShortFunctionFactory$Func::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastBooleanToSymbolFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastBooleanToSymbolFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastBooleanToSymbolFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastBooleanToSymbolFunctionFactory$Func::getSymbol(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastBooleanToSymbolFunctionFactory$Func::getSymbolB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastByteToCharFunctionFactory$CastByteToCharFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastByteToCharFunctionFactory$CastByteToCharFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastByteToCharFunctionFactory$CastByteToCharFunction::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastByteToDateFunctionFactory$CastByteToDateFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastByteToDateFunctionFactory$CastByteToDateFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastByteToDateFunctionFactory$CastByteToDateFunction::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastByteToDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastByteToDoubleFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastByteToDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastByteToFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastByteToFloatFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastByteToFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastByteToShortFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastByteToShortFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastByteToShortFunctionFactory$Func::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastCharToByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastCharToByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastCharToByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastCharToDateFunctionFactory$CastCharToDateFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastCharToDateFunctionFactory$CastCharToDateFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastCharToDateFunctionFactory$CastCharToDateFunction::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastCharToDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastCharToDoubleFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastCharToDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastCharToFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastCharToFloatFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastCharToFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastCharToShortFunctionFactory$CastCharToShortFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastCharToShortFunctionFactory$CastCharToShortFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastCharToShortFunctionFactory$CastCharToShortFunction::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDateToByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDateToByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDateToByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDateToCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDateToCharFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDateToCharFunctionFactory$Func::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDateToDoubleFunctionFactory$CastDateToDoubleFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDateToDoubleFunctionFactory$CastDateToDoubleFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDateToDoubleFunctionFactory$CastDateToDoubleFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDateToFloatFunctionFactory$CastDateToFloatFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDateToFloatFunctionFactory$CastDateToFloatFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDateToFloatFunctionFactory$CastDateToFloatFunction::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDateToShortFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDateToShortFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDateToShortFunctionFactory$Func::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDateToSymbolFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDateToSymbolFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDateToSymbolFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDateToSymbolFunctionFactory$Func::getSymbol(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDoubleToByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDoubleToByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDoubleToByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDoubleToCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDoubleToCharFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDoubleToCharFunctionFactory$Func::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDoubleToDateFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDoubleToDateFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDoubleToDateFunctionFactory$Func::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDoubleToFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDoubleToFloatFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDoubleToFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDoubleToShortFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDoubleToShortFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDoubleToShortFunctionFactory$Func::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastDoubleToSymbolFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastDoubleToSymbolFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDoubleToSymbolFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastDoubleToSymbolFunctionFactory$Func::getSymbol(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastFloatToByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastFloatToByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastFloatToByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastFloatToCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastFloatToCharFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastFloatToCharFunctionFactory$Func::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastFloatToDateFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastFloatToDateFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastFloatToDateFunctionFactory$Func::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastFloatToDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastFloatToDoubleFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastFloatToDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastFloatToShortFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastFloatToShortFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastFloatToShortFunctionFactory$Func::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastByteFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastByteFunc::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastByteFunc::getGeoByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastGeoIntToGeoShortFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastGeoIntToGeoShortFunction::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastGeoIntToGeoShortFunction::getGeoShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastGeoLongToGeoShortFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastGeoLongToGeoShortFunction::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastGeoLongToGeoShortFunction::getGeoShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastGeoShortFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastGeoShortFunction::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastGeoShortFunction::getGeoShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastIntFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastIntFunc::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastIntFunc::getGeoInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastIntToByteFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastIntToByteFunc::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastIntToByteFunc::getGeoByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastLongFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastLongFunc::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastLongFunc::getGeoLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastLongToByteFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastLongToByteFunc::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastLongToByteFunc::getGeoByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastLongToIntFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastLongToIntFunc::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastLongToIntFunc::getGeoInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastShortToByteFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastShortToByteFunc::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$CastShortToByteFunc::getGeoByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastIntToByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastIntToByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastIntToByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastIntToCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastIntToCharFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastIntToCharFunctionFactory$Func::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastIntToDateFunctionFactory$CastIntToDateFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastIntToDateFunctionFactory$CastIntToDateFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastIntToDateFunctionFactory$CastIntToDateFunction::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastIntToDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastIntToDoubleFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastIntToDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastIntToFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastIntToFloatFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastIntToFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastIntToShortFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastIntToShortFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastIntToShortFunctionFactory$Func::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLong256ToStrFunctionFactory$CastLong256ToStrFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLong256ToStrFunctionFactory$CastLong256ToStrFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLong256ToStrFunctionFactory$CastLong256ToStrFunction::toSink(io.questdb.cairo.sql.Record, io.questdb.std.str.StringSink):io.questdb.std.str.StringSink" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLongToByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLongToByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLongToCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLongToCharFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToCharFunctionFactory$Func::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLongToDateFunctionFactory$CastLongToDateFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLongToDateFunctionFactory$CastLongToDateFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToDateFunctionFactory$CastLongToDateFunction::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLongToDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLongToDoubleFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLongToFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLongToFloatFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoByteFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoByteFunc::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoByteFunc::getGeoByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoIntFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoIntFunc::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoIntFunc::getGeoInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoLongFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoLongFunc::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoLongFunc::getGeoLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoShortFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoShortFunc::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToGeoHashFunctionFactory$CastGeoShortFunc::getGeoShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLongToShortFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLongToShortFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToShortFunctionFactory$Func::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastLongToSymbolFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastLongToSymbolFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToSymbolFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastLongToSymbolFunctionFactory$Func::getSymbol(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastShortToByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastShortToByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastShortToByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastShortToCharFunctionFactory$CastShortToCharFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastShortToCharFunctionFactory$CastShortToCharFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastShortToCharFunctionFactory$CastShortToCharFunction::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastShortToDateFunctionFactory$CastShortToDateFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastShortToDateFunctionFactory$CastShortToDateFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastShortToDateFunctionFactory$CastShortToDateFunction::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastShortToDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastShortToDoubleFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastShortToDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastShortToFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastShortToFloatFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastShortToFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastStrToByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastStrToByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastStrToCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastStrToCharFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToCharFunctionFactory$Func::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastStrToDateFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastStrToDateFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToDateFunctionFactory$Func::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastStrToDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastStrToDoubleFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastStrToFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastStrToFloatFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastStrToGeoHashFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastStrToGeoHashFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToGeoHashFunctionFactory$Func::getGeoHashLong0(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastStrToRegClassFunctionFactory$CastStrToRegClassFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastStrToRegClassFunctionFactory$CastStrToRegClassFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToRegClassFunctionFactory$CastStrToRegClassFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastStrToShortFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastStrToShortFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToShortFunctionFactory$Func::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastStrToSymbolFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastStrToSymbolFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToSymbolFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToSymbolFunctionFactory$Func::getSymbol(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToSymbolFunctionFactory$Func::getSymbolB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastStrToUuidFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastStrToUuidFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToUuidFunctionFactory$Func::getLong128Hi(io.questdb.cairo.sql.Record):long" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastStrToUuidFunctionFactory$Func::getLong128Lo(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastSymbolToByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastSymbolToByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastSymbolToByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastSymbolToCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastSymbolToCharFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastSymbolToCharFunctionFactory$Func::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastSymbolToDateFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastSymbolToDateFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastSymbolToDateFunctionFactory$Func::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastSymbolToDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastSymbolToDoubleFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastSymbolToDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastSymbolToFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastSymbolToFloatFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastSymbolToFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastSymbolToShortFunctionFactory$CastSymbolToShortFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastSymbolToShortFunctionFactory$CastSymbolToShortFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastSymbolToShortFunctionFactory$CastSymbolToShortFunction::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastTimestampToByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastTimestampToByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastTimestampToByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastTimestampToCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastTimestampToCharFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastTimestampToCharFunctionFactory$Func::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastTimestampToDateFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastTimestampToDateFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastTimestampToDateFunctionFactory$Func::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastTimestampToDoubleFunctionFactory$CastTimestampToDoubleFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastTimestampToDoubleFunctionFactory$CastTimestampToDoubleFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastTimestampToDoubleFunctionFactory$CastTimestampToDoubleFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastTimestampToFloatFunctionFactory$CastTimestampToFloatFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastTimestampToFloatFunctionFactory$CastTimestampToFloatFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastTimestampToFloatFunctionFactory$CastTimestampToFloatFunction::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastTimestampToShortFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastTimestampToShortFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastTimestampToShortFunctionFactory$Func::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.cast.CastTimestampToSymbolFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.cast.CastTimestampToSymbolFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastTimestampToSymbolFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.cast.CastTimestampToSymbolFunctionFactory$Func::getSymbol(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.catalogue.CursorDereferenceFunctionFactory$IntColumnFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.catalogue.CursorDereferenceFunctionFactory$IntColumnFunction::cursorFunction:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.CursorDereferenceFunctionFactory$IntColumnFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoDateCoalesceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoDateCoalesceFunction::args0:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoDateCoalesceFunction::args1:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoDateCoalesceFunction::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoDoubleCoalesceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoDoubleCoalesceFunction::args0:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoDoubleCoalesceFunction::args1:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoDoubleCoalesceFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoFloatCoalesceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoFloatCoalesceFunction::args0:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoFloatCoalesceFunction::args1:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoFloatCoalesceFunction::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoIntCoalesceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoIntCoalesceFunction::args0:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoIntCoalesceFunction::args1:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoIntCoalesceFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoLong256CoalesceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoLong256CoalesceFunction::args0:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoLong256CoalesceFunction::args1:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoLong256CoalesceFunction::getLong256(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoLong256CoalesceFunction::getLong256A(io.questdb.cairo.sql.Record):io.questdb.std.Long256" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoLong256CoalesceFunction::getLong256B(io.questdb.cairo.sql.Record):io.questdb.std.Long256" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoLongCoalesceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoLongCoalesceFunction::args0:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoLongCoalesceFunction::args1:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoLongCoalesceFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoStrCoalesceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoStrCoalesceFunction::args0:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoStrCoalesceFunction::args1:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoStrCoalesceFunction::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoStrCoalesceFunction::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoSymCoalesceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoSymCoalesceFunction::args0:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoSymCoalesceFunction::args1:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoSymCoalesceFunction::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoSymCoalesceFunction::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoSymStrCoalesceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoSymStrCoalesceFunction::args0:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoSymStrCoalesceFunction::args1:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoSymStrCoalesceFunction::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoSymStrCoalesceFunction::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoTimestampCoalesceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoTimestampCoalesceFunction::args0:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoTimestampCoalesceFunction::args1:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoTimestampCoalesceFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoUuidCoalesceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoUuidCoalesceFunction::args0:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoUuidCoalesceFunction::args1:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoUuidCoalesceFunction::getLong128Hi(io.questdb.cairo.sql.Record):long" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CoalesceFunctionFactory$TwoUuidCoalesceFunction::getLong128Lo(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.NullIfCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.NullIfCharFunctionFactory$Func::chrFunc1:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.NullIfCharFunctionFactory$Func::chrFunc2:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.NullIfCharFunctionFactory$Func::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.NullIfIntFunctionFactory$NullIfIntFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.NullIfIntFunctionFactory$NullIfIntFunction::intFunc1:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.NullIfIntFunctionFactory$NullIfIntFunction::intFunc2:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.NullIfIntFunctionFactory$NullIfIntFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.NullIfLongFunctionFactory$NullIfLongFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.NullIfLongFunctionFactory$NullIfLongFunction::longFunc1:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.NullIfLongFunctionFactory$NullIfLongFunction::longFunc2:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.NullIfLongFunctionFactory$NullIfLongFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.NullIfStrFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.NullIfStrFunctionFactory$Func::strFunc1:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.NullIfStrFunctionFactory$Func::strFunc2:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.NullIfStrFunctionFactory$Func::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.NullIfStrFunctionFactory$Func::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.AddLongToTimestampFunctionFactory$AddLongFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.AddLongToTimestampFunctionFactory$AddLongFunc::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.AddLongToTimestampFunctionFactory$AddLongFunc::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.AddLongToTimestampFunctionFactory$AddLongFunc::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.DayOfMonthFunctionFactory$DayOfMonthFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.DayOfMonthFunctionFactory$DayOfMonthFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.DayOfMonthFunctionFactory$DayOfMonthFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.DayOfWeekFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.DayOfWeekFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.DayOfWeekFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.DayOfWeekSundayFirstFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.DayOfWeekSundayFirstFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.DayOfWeekSundayFirstFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.DaysPerMonthFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.DaysPerMonthFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.DaysPerMonthFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.HourOfDayFunctionFactory$HourOfDayFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.HourOfDayFunctionFactory$HourOfDayFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.HourOfDayFunctionFactory$HourOfDayFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.IsLeapYearFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.IsLeapYearFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.IsLeapYearFunctionFactory$Func::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.MicrosOfSecondFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.MicrosOfSecondFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.MicrosOfSecondFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.MillisOfSecondFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.MillisOfSecondFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.MillisOfSecondFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.MinuteOfHourFunctionFactory$MinuteFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.MinuteOfHourFunctionFactory$MinuteFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.MinuteOfHourFunctionFactory$MinuteFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.MonthOfYearFunctionFactory$MonthOfYearFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.MonthOfYearFunctionFactory$MonthOfYearFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.MonthOfYearFunctionFactory$MonthOfYearFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.OffsetTimestampFunctionFromOffset" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.OffsetTimestampFunctionFromOffset::timestamp:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.OffsetTimestampFunctionFromOffset::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.OffsetTimestampFunctionFromRules" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.OffsetTimestampFunctionFromRules::timestamp:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.OffsetTimestampFunctionFromRules::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.SecondOfMinuteFunctionFactory$SecondOfMinuteFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.SecondOfMinuteFunctionFactory$SecondOfMinuteFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.SecondOfMinuteFunctionFactory$SecondOfMinuteFunc::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarConstFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarConstFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarConstFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarVarFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarVarFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarVarFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarVarFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$DateAddFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$DateAddFunc::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$DateAddFunc::center:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$DateAddFunc::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$DateAddFunc::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DateDiffFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DateDiffFunc::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DateDiffFunc::center:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DateDiffFunc::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DateDiffFunc::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarConstFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarConstFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarConstFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarVarFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarVarFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarVarFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarVarFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampSequenceFunctionFactory$TimestampSequenceFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampSequenceFunctionFactory$TimestampSequenceFunction::longIncrement:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampSequenceFunctionFactory$TimestampSequenceFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampSequenceFunctionFactory$TimestampSequenceVariableFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampSequenceFunctionFactory$TimestampSequenceVariableFunction::longIncrement:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampSequenceFunctionFactory$TimestampSequenceVariableFunction::start:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampSequenceFunctionFactory$TimestampSequenceVariableFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToDateFunctionFactory$ToDateFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToDateFunctionFactory$ToDateFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToDateFunctionFactory$ToDateFunction::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToPgDateFunctionFactory$ToPgDateFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToPgDateFunctionFactory$ToPgDateFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToPgDateFunctionFactory$ToPgDateFunction::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToStrDateFunctionFactory$ToCharDateVCFFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToStrDateFunctionFactory$ToCharDateVCFFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToStrDateFunctionFactory$ToCharDateVCFFunc::getStr(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToStrDateFunctionFactory$ToCharDateVCFFunc::getStrLen(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToStrDateFunctionFactory$ToCharDateVCFFunc::toSink(io.questdb.cairo.sql.Record, io.questdb.std.str.StringSink):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToStrTimestampFunctionFactory$ToCharDateFFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToStrTimestampFunctionFactory$ToCharDateFFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToStrTimestampFunctionFactory$ToCharDateFFunc::getStr(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToStrTimestampFunctionFactory$ToCharDateFFunc::getStrLen(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToStrTimestampFunctionFactory$ToCharDateFFunc::toSink(io.questdb.cairo.sql.Record, io.questdb.std.str.StringSink):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToTimestampFunctionFactory$ToTimestampFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToTimestampFunctionFactory$ToTimestampFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToTimestampFunctionFactory$ToTimestampFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToTimestampVCFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToTimestampVCFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToTimestampVCFunctionFactory$Func::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToTimezoneTimestampFunctionFactory$ToTimezoneFunctionVar" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToTimezoneTimestampFunctionFactory$ToTimezoneFunctionVar::timestamp:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToTimezoneTimestampFunctionFactory$ToTimezoneFunctionVar::timezone:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToTimezoneTimestampFunctionFactory$ToTimezoneFunctionVar::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToUTCTimestampFunctionFactory$ToTimezoneFunctionVar" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToUTCTimestampFunctionFactory$ToTimezoneFunctionVar::timestamp:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToUTCTimestampFunctionFactory$ToTimezoneFunctionVar::timezone:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToUTCTimestampFunctionFactory$ToTimezoneFunctionVar::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.WeekOfYearFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.WeekOfYearFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.WeekOfYearFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.YearFunctionFactory$YearFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.YearFunctionFactory$YearFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.YearFunctionFactory$YearFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.EqBooleanCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.EqBooleanCharFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.EqBooleanCharFunctionFactory$Func::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.EqIntStrCFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.EqIntStrCFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.EqIntStrCFunctionFactory$Func::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.EqLong256StrFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.EqLong256StrFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.EqLong256StrFunctionFactory$Func::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.EqStrCharFunctionFactory$ConstChrFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.EqStrCharFunctionFactory$ConstChrFunc::strFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.EqStrCharFunctionFactory$ConstChrFunc::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.EqStrCharFunctionFactory$ConstStrFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.EqStrCharFunctionFactory$ConstStrFunc::chrFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.EqStrCharFunctionFactory$ConstStrFunc::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.EqStrFunctionFactory$ConstCheckFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.EqStrFunctionFactory$ConstCheckFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.EqStrFunctionFactory$ConstCheckFunc::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.EqStrFunctionFactory$NullCheckFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.EqStrFunctionFactory$NullCheckFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.EqStrFunctionFactory$NullCheckFunc::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.EqSymCharFunctionFactory$ConstCheckFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.EqSymCharFunctionFactory$ConstCheckFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.EqSymCharFunctionFactory$ConstCheckFunc::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.EqSymStrFunctionFactory$NullCheckFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.EqSymStrFunctionFactory$NullCheckFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.EqSymStrFunctionFactory$NullCheckFunc::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.EqUuidFunctionFactory$ConstCheckFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.EqUuidFunctionFactory$ConstCheckFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.EqUuidFunctionFactory$ConstCheckFunc::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.UuidEqUtils$ConstStrFun" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.UuidEqUtils$ConstStrFun::fun:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.UuidEqUtils$ConstStrFun::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.eq.UuidEqUtils$ConstUuidFun" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.eq.UuidEqUtils$ConstUuidFun::fun:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.eq.UuidEqUtils$ConstUuidFun::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.geohash.GeoHashFromCoordinatesFunctionFactory$FromCoordinatesFixedBitsFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.geohash.GeoHashFromCoordinatesFunctionFactory$FromCoordinatesFixedBitsFunction::lon:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.geohash.GeoHashFromCoordinatesFunctionFactory$FromCoordinatesFixedBitsFunction::lat:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.geohash.GeoHashFromCoordinatesFunctionFactory$FromCoordinatesFixedBitsFunction::getLongValue(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.AvgDoubleGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.AvgDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.AvgDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.AvgDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctIntGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLong256GroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctLongGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctStringGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctSymbolGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.CountDistinctUuidGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstByteGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstByteGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstByteGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstCharGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstCharGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstCharGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstDateGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstDateGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstDateGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstDoubleGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstFloatGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstFloatGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstFloatGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionByte" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionByte::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionByte::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionInt" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionInt::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionInt::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionLong" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionLong::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionLong::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionShort" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionShort::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstGeoHashGroupByFunctionShort::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstIntGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstIntGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstIntGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstLongGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstLongGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstLongGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstShortGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstShortGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstShortGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstTimestampGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstTimestampGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstTimestampGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.FirstUuidGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.FirstUuidGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.FirstUuidGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction::latDegree:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction::lonDegree:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction::timestamp:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.HaversineDistDegreeGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.IsLongOrderedGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.IsLongOrderedGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.IsLongOrderedGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.IsLongOrderedGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.KSumDoubleGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.KSumDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.KSumDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.KSumDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MaxCharGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MaxCharGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxCharGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxCharGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MaxDateGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MaxDateGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxDateGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxDateGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MaxDoubleGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MaxDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MaxFloatGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MaxFloatGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxFloatGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxFloatGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MaxIntGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MaxIntGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxIntGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxIntGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MaxLongGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MaxLongGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxLongGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxLongGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MaxStrGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MaxStrGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxStrGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxStrGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MaxTimestampGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MaxTimestampGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxTimestampGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MaxTimestampGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MinCharGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MinCharGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinCharGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinCharGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MinDateGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MinDateGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinDateGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinDateGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MinDoubleGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MinDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MinFloatGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MinFloatGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinFloatGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinFloatGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MinIntGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MinIntGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinIntGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinIntGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MinLongGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MinLongGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinLongGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinLongGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MinStrGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MinStrGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinStrGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinStrGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.MinTimestampGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.MinTimestampGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinTimestampGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.MinTimestampGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.NSumDoubleGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.NSumDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.NSumDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.NSumDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.StdDevSampleDoubleGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.StdDevSampleDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.StdDevSampleDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.StdDevSampleDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.StringAggGroupByFunctionFactory$StringAggGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.StringAggGroupByFunctionFactory$StringAggGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.StringAggGroupByFunctionFactory$StringAggGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.StringAggGroupByFunctionFactory$StringAggGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.SumDoubleGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.SumDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.SumFloatGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.SumFloatGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumFloatGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumFloatGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.SumIntGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.SumIntGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumIntGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumIntGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.SumLong256GroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.SumLong256GroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumLong256GroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumLong256GroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.groupby.SumLongGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.groupby.SumLongGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumLongGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.groupby.SumLongGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.long128.LongsToLong128FunctionFactory$LongsToLong128Function" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.long128.LongsToLong128FunctionFactory$LongsToLong128Function::hi:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.long128.LongsToLong128FunctionFactory$LongsToLong128Function::lo:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.long128.LongsToLong128FunctionFactory$LongsToLong128Function::getLong128Hi(io.questdb.cairo.sql.Record):long" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.long128.LongsToLong128FunctionFactory$LongsToLong128Function::getLong128Lo(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.lt.LtCharFunctionFactory$LtCharFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtCharFunctionFactory$LtCharFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtCharFunctionFactory$LtCharFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.lt.LtCharFunctionFactory$LtCharFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.lt.LtDoubleVVFunctionFactory$FuncVV" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtDoubleVVFunctionFactory$FuncVV::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtDoubleVVFunctionFactory$FuncVV::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.lt.LtDoubleVVFunctionFactory$FuncVV::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.lt.LtIntFunctionFactory$LtIntFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtIntFunctionFactory$LtIntFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtIntFunctionFactory$LtIntFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.lt.LtIntFunctionFactory$LtIntFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.lt.LtLong256FunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtLong256FunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtLong256FunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.lt.LtLong256FunctionFactory$Func::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.lt.LtLongFunctionFactory$LtLongFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtLongFunctionFactory$LtLongFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtLongFunctionFactory$LtLongFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.lt.LtLongFunctionFactory$LtLongFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.lt.LtTimestampFunctionFactory$LtTimestampFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtTimestampFunctionFactory$LtTimestampFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.lt.LtTimestampFunctionFactory$LtTimestampFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.lt.LtTimestampFunctionFactory$LtTimestampFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.AbsDoubleFunctionFactory$AbsFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AbsDoubleFunctionFactory$AbsFunction::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AbsDoubleFunctionFactory$AbsFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.AbsIntFunctionFactory$AbsIntFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AbsIntFunctionFactory$AbsIntFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AbsIntFunctionFactory$AbsIntFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.AbsShortFunctionFactory$AbsFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AbsShortFunctionFactory$AbsFunction::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AbsShortFunctionFactory$AbsFunction::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.AcosDoubleFunctionFactory$AcosFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AcosDoubleFunctionFactory$AcosFunction::x:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AcosDoubleFunctionFactory$AcosFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.AddDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AddDoubleFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AddDoubleFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AddDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.AddFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AddFloatFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AddFloatFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AddFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.AddIntFunctionFactory$AddIntFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AddIntFunctionFactory$AddIntFunc::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AddIntFunctionFactory$AddIntFunc::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AddIntFunctionFactory$AddIntFunc::getInt(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AddIntFunctionFactory$AddIntFunc::isConstant():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.AddLong256FunctionFactory$AddLong256Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AddLong256FunctionFactory$AddLong256Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AddLong256FunctionFactory$AddLong256Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AddLong256FunctionFactory$AddLong256Func::getLong256A(io.questdb.cairo.sql.Record):io.questdb.std.Long256" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AddLong256FunctionFactory$AddLong256Func::getLong256B(io.questdb.cairo.sql.Record):io.questdb.std.Long256" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.AddLongFunctionFactory$AddLongFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AddLongFunctionFactory$AddLongFunc::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AddLongFunctionFactory$AddLongFunc::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AddLongFunctionFactory$AddLongFunc::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.AsinDoubleFunctionFactory$AsinFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AsinDoubleFunctionFactory$AsinFunction::x:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AsinDoubleFunctionFactory$AsinFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.Atan2DoubleFunctionFactory$Atan2Function" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.Atan2DoubleFunctionFactory$Atan2Function::y:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.Atan2DoubleFunctionFactory$Atan2Function::x:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.Atan2DoubleFunctionFactory$Atan2Function::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.AtanDoubleFunctionFactory$AtanFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.AtanDoubleFunctionFactory$AtanFunction::x:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.AtanDoubleFunctionFactory$AtanFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.BitwiseAndIntFunctionFactory$BitAndIntFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseAndIntFunctionFactory$BitAndIntFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseAndIntFunctionFactory$BitAndIntFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.BitwiseAndIntFunctionFactory$BitAndIntFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.BitwiseAndLongFunctionFactory$BitAndLongFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseAndLongFunctionFactory$BitAndLongFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseAndLongFunctionFactory$BitAndLongFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.BitwiseAndLongFunctionFactory$BitAndLongFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.BitwiseNotIntFunctionFactory$BitNotIntFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseNotIntFunctionFactory$BitNotIntFunction::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.BitwiseNotIntFunctionFactory$BitNotIntFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.BitwiseNotLongFunctionFactory$BitNotLongFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseNotLongFunctionFactory$BitNotLongFunction::value:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.BitwiseNotLongFunctionFactory$BitNotLongFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.BitwiseOrIntFunctionFactory$BitOrIntFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseOrIntFunctionFactory$BitOrIntFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseOrIntFunctionFactory$BitOrIntFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.BitwiseOrIntFunctionFactory$BitOrIntFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.BitwiseOrLongFunctionFactory$BitOrLongFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseOrLongFunctionFactory$BitOrLongFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseOrLongFunctionFactory$BitOrLongFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.BitwiseOrLongFunctionFactory$BitOrLongFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.BitwiseXorIntFunctionFactory$BitXorIntFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseXorIntFunctionFactory$BitXorIntFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseXorIntFunctionFactory$BitXorIntFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.BitwiseXorIntFunctionFactory$BitXorIntFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.BitwiseXorLongFunctionFactory$BitXorLongFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseXorLongFunctionFactory$BitXorLongFunction::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.BitwiseXorLongFunctionFactory$BitXorLongFunction::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.BitwiseXorLongFunctionFactory$BitXorLongFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.CeilDoubleFunctionFactory$CeilFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.CeilDoubleFunctionFactory$CeilFunction::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.CeilDoubleFunctionFactory$CeilFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.CeilFloatFunctionFactory$CeilFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.CeilFloatFunctionFactory$CeilFunction::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.CeilFloatFunctionFactory$CeilFunction::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.CosDoubleFunctionFactory$CosFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.CosDoubleFunctionFactory$CosFunction::angleRad:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.CosDoubleFunctionFactory$CosFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.CotDoubleFunctionFactory$CotFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.CotDoubleFunctionFactory$CotFunction::angleRad:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.CotDoubleFunctionFactory$CotFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.DegreesDoubleFunctionFactory$FromRadians" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.DegreesDoubleFunctionFactory$FromRadians::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.DegreesDoubleFunctionFactory$FromRadians::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.DivDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.DivDoubleFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.DivDoubleFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.DivDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.DivFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.DivFloatFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.DivFloatFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.DivFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.DivIntFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.DivIntFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.DivIntFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.DivIntFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.DivLongFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.DivLongFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.DivLongFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.DivLongFunctionFactory$Func::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.FloorDoubleFunctionFactory$FloorFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.FloorDoubleFunctionFactory$FloorFunction::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.FloorDoubleFunctionFactory$FloorFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.FloorFloatFunctionFactory$FloorFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.FloorFloatFunctionFactory$FloorFunction::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.FloorFloatFunctionFactory$FloorFunction::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.LnDoubleFunctionFactory$LnFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.LnDoubleFunctionFactory$LnFunction::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.LnDoubleFunctionFactory$LnFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.LogDoubleFunctionFactory$LogFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.LogDoubleFunctionFactory$LogFunction::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.LogDoubleFunctionFactory$LogFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.MulDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.MulDoubleFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.MulDoubleFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.MulDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.MulFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.MulFloatFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.MulFloatFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.MulFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.MulIntFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.MulIntFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.MulIntFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.MulIntFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.MulLongFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.MulLongFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.MulLongFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.MulLongFunctionFactory$Func::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.NegByteFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.NegByteFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.NegByteFunctionFactory$Func::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.NegDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.NegDoubleFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.NegDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.NegFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.NegFloatFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.NegFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.NegIntFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.NegIntFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.NegIntFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.NegLongFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.NegLongFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.NegLongFunctionFactory$Func::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.NegShortFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.NegShortFunctionFactory$Func::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.NegShortFunctionFactory$Func::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.PowDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.PowDoubleFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.PowDoubleFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.PowDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RadiansDoubleFunctionFactory$Radians" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RadiansDoubleFunctionFactory$Radians::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RadiansDoubleFunctionFactory$Radians::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RemDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RemDoubleFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RemDoubleFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RemDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RemFloatFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RemFloatFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RemFloatFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RemFloatFunctionFactory$Func::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RemIntFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RemIntFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RemIntFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RemIntFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RemLongFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RemLongFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RemLongFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RemLongFunctionFactory$Func::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundDoubleFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundDoubleFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundDoubleFunctionFactory$FuncNegConst" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundDoubleFunctionFactory$FuncNegConst::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundDoubleFunctionFactory$FuncNegConst::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundDoubleFunctionFactory$FuncPosConst" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundDoubleFunctionFactory$FuncPosConst::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundDoubleFunctionFactory$FuncPosConst::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundDoubleZeroScaleFunctionFactory$RoundDoubleZeroScaleFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundDoubleZeroScaleFunctionFactory$RoundDoubleZeroScaleFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundDoubleZeroScaleFunctionFactory$RoundDoubleZeroScaleFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundDownDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundDownDoubleFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundDownDoubleFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundDownDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundDownDoubleFunctionFactory$FuncNegConst" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundDownDoubleFunctionFactory$FuncNegConst::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundDownDoubleFunctionFactory$FuncNegConst::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundDownDoubleFunctionFactory$FuncPosConst" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundDownDoubleFunctionFactory$FuncPosConst::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundDownDoubleFunctionFactory$FuncPosConst::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundHalfEvenDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundHalfEvenDoubleFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundHalfEvenDoubleFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundHalfEvenDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundHalfEvenDoubleFunctionFactory$FuncNegConst" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundHalfEvenDoubleFunctionFactory$FuncNegConst::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundHalfEvenDoubleFunctionFactory$FuncNegConst::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundHalfEvenDoubleFunctionFactory$FuncPosConst" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundHalfEvenDoubleFunctionFactory$FuncPosConst::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundHalfEvenDoubleFunctionFactory$FuncPosConst::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundUpDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundUpDoubleFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundUpDoubleFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundUpDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundUpDoubleFunctionFactory$FuncNegConst" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundUpDoubleFunctionFactory$FuncNegConst::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundUpDoubleFunctionFactory$FuncNegConst::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.RoundUpDoubleFunctionFactory$FuncPosConst" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.RoundUpDoubleFunctionFactory$FuncPosConst::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.RoundUpDoubleFunctionFactory$FuncPosConst::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.SinDoubleFunctionFactory$SinFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.SinDoubleFunctionFactory$SinFunction::angleRad:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.SinDoubleFunctionFactory$SinFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.SqrtDoubleFunctionFactory$SqrtFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.SqrtDoubleFunctionFactory$SqrtFunction::function:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.SqrtDoubleFunctionFactory$SqrtFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.SubDoubleFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.SubDoubleFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.SubDoubleFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.SubDoubleFunctionFactory$Func::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.SubIntFunctionFactory$SubtractIntVVFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.SubIntFunctionFactory$SubtractIntVVFunc::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.SubIntFunctionFactory$SubtractIntVVFunc::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.SubIntFunctionFactory$SubtractIntVVFunc::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.SubLongFunctionFactory$SubtractIntVVFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.SubLongFunctionFactory$SubtractIntVVFunc::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.SubLongFunctionFactory$SubtractIntVVFunc::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.SubLongFunctionFactory$SubtractIntVVFunc::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.SubTimestampFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.SubTimestampFunctionFactory$Func::left:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.SubTimestampFunctionFactory$Func::right:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.SubTimestampFunctionFactory$Func::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.math.TanDoubleFunctionFactory$TanFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.math.TanDoubleFunctionFactory$TanFunction::angleRad:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.math.TanDoubleFunctionFactory$TanFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.regex.AbstractLikeStrFunctionFactory$BindLikeStrFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.regex.AbstractLikeStrFunctionFactory$BindLikeStrFunction::value:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.regex.AbstractLikeStrFunctionFactory$BindLikeStrFunction::pattern:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.regex.AbstractLikeStrFunctionFactory$BindLikeStrFunction::init(io.questdb.cairo.sql.SymbolTableSource, io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.regex.RegexpReplaceStrFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.regex.RegexpReplaceStrFunctionFactory$Func::value:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.regex.RegexpReplaceStrFunctionFactory$Func::pattern:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.regex.RegexpReplaceStrFunctionFactory$Func::replacement:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.regex.RegexpReplaceStrFunctionFactory$Func::getStr(io.questdb.cairo.sql.Record, io.questdb.griffin.engine.functions.regex.RegexpReplaceStrFunctionFactory$StringBufferSink):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.regex.RegexpReplaceStrFunctionFactory$Func::init(io.questdb.cairo.sql.SymbolTableSource, io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.LPadFunctionFactory$LPadFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.LPadFunctionFactory$LPadFunc::strFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.LPadFunctionFactory$LPadFunc::lenFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LPadFunctionFactory$LPadFunc::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LPadFunctionFactory$LPadFunc::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LPadFunctionFactory$LPadFunc::getStrLen(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.LPadStrFunctionFactory$LPadStrFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.LPadStrFunctionFactory$LPadStrFunc::strFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.LPadStrFunctionFactory$LPadStrFunc::lenFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.LPadStrFunctionFactory$LPadStrFunc::fillTextFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LPadStrFunctionFactory$LPadStrFunc::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LPadStrFunctionFactory$LPadStrFunc::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LPadStrFunctionFactory$LPadStrFunc::getStrLen(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.LeftFunctionFactory$LeftStrConstCountFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.LeftFunctionFactory$LeftStrConstCountFunction::strFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LeftFunctionFactory$LeftStrConstCountFunction::getStr(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LeftFunctionFactory$LeftStrConstCountFunction::getStrLen(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LeftFunctionFactory$LeftStrConstCountFunction::getStr0(io.questdb.cairo.sql.Record, io.questdb.std.str.StringSink):io.questdb.std.str.StringSink" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.LeftFunctionFactory$LeftStrFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.LeftFunctionFactory$LeftStrFunction::strFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.LeftFunctionFactory$LeftStrFunction::countFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LeftFunctionFactory$LeftStrFunction::getStr(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LeftFunctionFactory$LeftStrFunction::getStrLen(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LeftFunctionFactory$LeftStrFunction::getStr0(io.questdb.cairo.sql.Record, io.questdb.std.str.StringSink):io.questdb.std.str.StringSink" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.LengthBinFunctionFactory$LengthFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.LengthBinFunctionFactory$LengthFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LengthBinFunctionFactory$LengthFunc::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.LengthStrFunctionFactory$LengthStrVFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.LengthStrFunctionFactory$LengthStrVFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LengthStrFunctionFactory$LengthStrVFunc::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.LengthSymbolFunctionFactory$LengthSymbolVFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.LengthSymbolFunctionFactory$LengthSymbolVFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.LengthSymbolFunctionFactory$LengthSymbolVFunc::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.RPadFunctionFactory$RPadFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.RPadFunctionFactory$RPadFunc::strFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.RPadFunctionFactory$RPadFunc::lenFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RPadFunctionFactory$RPadFunc::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RPadFunctionFactory$RPadFunc::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RPadFunctionFactory$RPadFunc::getStrLen(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.RPadStrFunctionFactory$RPadStrFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.RPadStrFunctionFactory$RPadStrFunc::strFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.RPadStrFunctionFactory$RPadStrFunc::lenFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.RPadStrFunctionFactory$RPadStrFunc::fillTextFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RPadStrFunctionFactory$RPadStrFunc::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RPadStrFunctionFactory$RPadStrFunc::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RPadStrFunctionFactory$RPadStrFunc::getStrLen(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.ReplaceStrFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.ReplaceStrFunctionFactory$Func::value:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.ReplaceStrFunctionFactory$Func::oldSubStr:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.ReplaceStrFunctionFactory$Func::newSubStr:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.ReplaceStrFunctionFactory$Func::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.ReplaceStrFunctionFactory$Func::getStr(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.ReplaceStrFunctionFactory$Func::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.RightFunctionFactory$RightStrConstCountFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.RightFunctionFactory$RightStrConstCountFunction::strFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RightFunctionFactory$RightStrConstCountFunction::getStr(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RightFunctionFactory$RightStrConstCountFunction::getStrLen(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RightFunctionFactory$RightStrConstCountFunction::getStr0(io.questdb.cairo.sql.Record, io.questdb.std.str.StringSink):io.questdb.std.str.StringSink" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.RightFunctionFactory$RightStrFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.RightFunctionFactory$RightStrFunction::strFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.RightFunctionFactory$RightStrFunction::countFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RightFunctionFactory$RightStrFunction::getStr(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RightFunctionFactory$RightStrFunction::getStrLen(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.RightFunctionFactory$RightStrFunction::getStr0(io.questdb.cairo.sql.Record, io.questdb.std.str.StringSink):io.questdb.std.str.StringSink" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.SizePrettyFunctionFactory$SizePretty" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.SizePrettyFunctionFactory$SizePretty::size:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.SizePrettyFunctionFactory$SizePretty::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.SizePrettyFunctionFactory$SizePretty::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.StartsWithStrFunctionFactory$StartsWithStrFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.StartsWithStrFunctionFactory$StartsWithStrFunction::strFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.StartsWithStrFunctionFactory$StartsWithStrFunction::prefixFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.StartsWithStrFunctionFactory$StartsWithStrFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.StrPosCharFunctionFactory$ConstFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.StrPosCharFunctionFactory$ConstFunc::strFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.StrPosCharFunctionFactory$ConstFunc::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.StrPosCharFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.StrPosCharFunctionFactory$Func::strFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.StrPosCharFunctionFactory$Func::substrFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.StrPosCharFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.StrPosFunctionFactory$ConstFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.StrPosFunctionFactory$ConstFunc::strFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.StrPosFunctionFactory$ConstFunc::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.StrPosFunctionFactory$Func" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.StrPosFunctionFactory$Func::strFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.StrPosFunctionFactory$Func::substrFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.StrPosFunctionFactory$Func::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.SubStringFunctionFactory$SubStringFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.SubStringFunctionFactory$SubStringFunc::strFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.SubStringFunctionFactory$SubStringFunc::startFunc:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.SubStringFunctionFactory$SubStringFunc::lenFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.SubStringFunctionFactory$SubStringFunc::getStrLen(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.SubStringFunctionFactory$SubStringFunc::getStr0(io.questdb.cairo.sql.Record, io.questdb.std.str.StringSink):io.questdb.std.str.StringSink" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.ToCharBinFunctionFactory$ToCharBinFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.ToCharBinFunctionFactory$ToCharBinFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.ToCharBinFunctionFactory$ToCharBinFunc::getStr(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.ToCharBinFunctionFactory$ToCharBinFunc::getStrLen(io.questdb.cairo.sql.Record):int" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.ToCharBinFunctionFactory$ToCharBinFunc::toSink(io.questdb.cairo.sql.Record, io.questdb.std.str.StringSink):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.ToLowercaseFunctionFactory$ToLowercaseFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.ToLowercaseFunctionFactory$ToLowercaseFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.ToLowercaseFunctionFactory$ToLowercaseFunc::getStrLen(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.ToUppercaseFunctionFactory$ToUppercaseFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.ToUppercaseFunctionFactory$ToUppercaseFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.ToUppercaseFunctionFactory$ToUppercaseFunc::getStrLen(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.str.TrimFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.str.TrimFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.str.TrimFunction::getStrLen(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.table.TouchTableFunctionFactory$TouchTableFunc" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.table.TouchTableFunctionFactory$TouchTableFunc::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.table.TouchTableFunctionFactory$TouchTableFunc::touchTable():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.test.TestSumDoubleGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.test.TestSumDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.test.TestSumStringGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.test.TestSumStringGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumStringGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumStringGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.test.TestSumTDoubleGroupByFunction" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.test.TestSumTDoubleGroupByFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumTDoubleGroupByFunction::computeFirst(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestSumTDoubleGroupByFunction::computeNext(io.questdb.cairo.map.MapValue, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.ApplyWal2TableJob" />
			<role name="State" element="io.questdb.cairo.wal.ApplyWal2TableJob$TelemetryFacade" />
			<role name="state" element="io.questdb.cairo.wal.ApplyWal2TableJob::telemetryFacade:io.questdb.cairo.wal.ApplyWal2TableJob$TelemetryFacade" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::applyWAL(io.questdb.cairo.TableToken, io.questdb.cairo.CairoEngine, io.questdb.cairo.wal.OperationCompiler, io.questdb.mp.Job$RunStatus):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.ApplyWal2TableJob" />
			<role name="State" element="io.questdb.cairo.wal.ApplyWal2TableJob$WalTelemetryFacade" />
			<role name="state" element="io.questdb.cairo.wal.ApplyWal2TableJob::walTelemetryFacade:io.questdb.cairo.wal.ApplyWal2TableJob$WalTelemetryFacade" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::applyOutstandingWalTransactions(io.questdb.cairo.TableToken, io.questdb.cairo.TableWriter, io.questdb.cairo.CairoEngine, io.questdb.cairo.wal.OperationCompiler, io.questdb.std.str.Path, io.questdb.mp.Job$RunStatus):boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::processWalCommit(io.questdb.cairo.TableWriter, int, io.questdb.std.str.Path, long, io.questdb.cairo.wal.OperationCompiler, long, long):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumLong256VectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.AvgLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.KSumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MaxTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.MinTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.NSumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumDateVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumDoubleVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumIntVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumLongVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction::distinctFunc:io.questdb.griffin.engine.groupby.vect.DistinctFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction::keyValueFunc:io.questdb.griffin.engine.groupby.vect.KeyValueFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.SumTimestampVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.BinCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.BinCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.BinCaseFunction::getBin(io.questdb.cairo.sql.Record):io.questdb.std.BinarySequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.BinCaseFunction::getBinLen(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.BooleanCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.BooleanCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.BooleanCaseFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.ByteCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.ByteCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.ByteCaseFunction::getByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.CharCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.CharCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.CharCaseFunction::getChar(io.questdb.cairo.sql.Record):char" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.DateCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.DateCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.DateCaseFunction::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.DoubleCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.DoubleCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.DoubleCaseFunction::getDouble(io.questdb.cairo.sql.Record):double" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.FloatCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.FloatCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.FloatCaseFunction::getFloat(io.questdb.cairo.sql.Record):float" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.GeoByteCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.GeoByteCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.GeoByteCaseFunction::getGeoByte(io.questdb.cairo.sql.Record):byte" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.GeoIntCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.GeoIntCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.GeoIntCaseFunction::getGeoInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.GeoLongCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.GeoLongCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.GeoLongCaseFunction::getGeoLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.GeoShortCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.GeoShortCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.GeoShortCaseFunction::getGeoShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.IntCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.IntCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.IntCaseFunction::getInt(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.Long128CaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.Long128CaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.Long128CaseFunction::getLong128Hi(io.questdb.cairo.sql.Record):long" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.Long128CaseFunction::getLong128Lo(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.Long256CaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.Long256CaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.Long256CaseFunction::getLong256(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.Long256CaseFunction::getLong256A(io.questdb.cairo.sql.Record):io.questdb.std.Long256" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.Long256CaseFunction::getLong256B(io.questdb.cairo.sql.Record):io.questdb.std.Long256" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.LongCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.LongCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.LongCaseFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.ShortCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.ShortCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.ShortCaseFunction::getShort(io.questdb.cairo.sql.Record):short" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.StrCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.StrCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.StrCaseFunction::getStr(io.questdb.cairo.sql.Record, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.StrCaseFunction::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.StrCaseFunction::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.StrCaseFunction::getStrLen(io.questdb.cairo.sql.Record):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.TimestampCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.TimestampCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.TimestampCaseFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.conditional.UuidCaseFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="state" element="io.questdb.griffin.engine.functions.conditional.UuidCaseFunction::picker:io.questdb.griffin.engine.functions.conditional.CaseFunctionPicker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.UuidCaseFunction::getLong128Hi(io.questdb.cairo.sql.Record):long" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.conditional.UuidCaseFunction::getLong128Lo(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarConstFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$LongAddIntFunction" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarConstFunction::func:io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$LongAddIntFunction" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarConstFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarVarFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$LongAddIntFunction" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarVarFunction::func:io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$LongAddIntFunction" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampAddFunctionFactory$AddLongIntVarVarFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarConstFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$LongDiffFunction" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarConstFunction::func:io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$LongDiffFunction" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarConstFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarVarFunction" />
			<role name="State" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$LongDiffFunction" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarVarFunction::func:io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$LongDiffFunction" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.TimestampDiffFunctionFactory$DiffVarVarFunction::getLong(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.CountVectorAggregateFunction" />
			<role name="State" element="io.questdb.griffin.engine.groupby.vect.CountVectorAggregateFunction$CountFunc" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.CountVectorAggregateFunction::countFunc:io.questdb.griffin.engine.groupby.vect.CountVectorAggregateFunction$CountFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.CountVectorAggregateFunction::aggregate(long, long, long, long, int, int):boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="Context" element="io.questdb.griffin.SqlCompiler" />
			<role name="state" element="io.questdb.griffin.SqlCompiler::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::createTable(io.questdb.griffin.model.ExecutionModel, io.questdb.griffin.SqlExecutionContext):io.questdb.griffin.CompiledQuery" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="Context" element="io.questdb.cutlass.text.SerialCsvFileImporter" />
			<role name="state" element="io.questdb.cutlass.text.SerialCsvFileImporter::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cutlass.text.SerialCsvFileImporter::process(io.questdb.cairo.SecurityContext):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="Context" element="io.questdb.cairo.wal.WalReader" />
			<role name="state" element="io.questdb.cairo.wal.WalReader::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.wal.WalReader::openSegment():long" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="Context" element="io.questdb.cairo.wal.WalEventReader" />
			<role name="state" element="io.questdb.cairo.wal.WalEventReader::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.wal.WalEventReader::of(io.questdb.std.str.Path, int, long):io.questdb.cairo.wal.WalEventCursor" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="Context" element="io.questdb.cairo.VacuumColumnVersions" />
			<role name="state" element="io.questdb.cairo.VacuumColumnVersions::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.VacuumColumnVersions::run(io.questdb.cairo.TableReader):void" />
			<role name="Request()" element="io.questdb.cairo.VacuumColumnVersions::visitTablePartition(long, int):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="Context" element="io.questdb.cairo.wal.WalWriterEvents" />
			<role name="state" element="io.questdb.cairo.wal.WalWriterEvents::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriterEvents::close():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriterEvents::appendIndex(long):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriterEvents::openEventFile(io.questdb.std.str.Path, int):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriterEvents::sync():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="Context" element="io.questdb.griffin.DatabaseSnapshotAgent" />
			<role name="state" element="io.questdb.griffin.DatabaseSnapshotAgent::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.griffin.DatabaseSnapshotAgent::completeSnapshot():void" />
			<role name="Request()" element="io.questdb.griffin.DatabaseSnapshotAgent::prepareSnapshot(io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="Context" element="io.questdb.griffin.DropIndexOperator" />
			<role name="state" element="io.questdb.griffin.DropIndexOperator::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.griffin.DropIndexOperator::executeDropIndex(java.lang.CharSequence, int):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="Context" element="io.questdb.cairo.ColumnPurgeOperator" />
			<role name="state" element="io.questdb.cairo.ColumnPurgeOperator::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::closePurgeLogCompleteFile():void" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::purge0(io.questdb.tasks.ColumnPurgeTask, io.questdb.cairo.ColumnPurgeOperator$ScoreboardUseMode):boolean" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::readTableId(io.questdb.std.str.Path):int" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::setCompletionTimestamp(io.questdb.std.LongList, long):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="Context" element="io.questdb.cutlass.text.CopyTask$PhaseBoundaryCheck" />
			<role name="state" element="io.questdb.cutlass.text.CopyTask$PhaseBoundaryCheck::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyTask$PhaseBoundaryCheck::run(long, long):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="Context" element="io.questdb.griffin.PurgingOperator" />
			<role name="state" element="io.questdb.griffin.PurgingOperator::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.griffin.PurgingOperator::purge(io.questdb.std.str.Path, io.questdb.cairo.TableToken, int, boolean, io.questdb.cairo.sql.TableRecordMetadata, long, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.catalogue.TypeOfFunctionFactory" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.functions.catalogue.TypeOfFunctionFactory::NULL:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.TypeOfFunctionFactory::newInstance(int, io.questdb.std.ObjList, io.questdb.std.IntList, io.questdb.cairo.CairoConfiguration, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.Function" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Context" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState" />
			<role name="state" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::recordCursorFactory:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::of(io.questdb.cairo.sql.RecordCursorFactory, boolean, io.questdb.griffin.SqlExecutionContextImpl):boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Context" element="io.questdb.cutlass.pgwire.PGConnectionContext" />
			<role name="state" element="io.questdb.cutlass.pgwire.PGConnectionContext::currentFactory:io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::resumeCursorExecute(boolean):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::resumeCursorQuery0(boolean):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::sendCursor(int, io.questdb.cutlass.pgwire.PGConnectionContext$PGResumeProcessor, io.questdb.cutlass.pgwire.PGConnectionContext$PGResumeProcessor):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.FunctionFactoryDescriptor" />
			<role name="State" element="io.questdb.griffin.FunctionFactory" />
			<role name="state" element="io.questdb.griffin.FunctionFactoryDescriptor::factory:io.questdb.griffin.FunctionFactory" />
			<role name="Request()" element="io.questdb.griffin.FunctionFactoryDescriptor::getName():java.lang.String" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.griffin.AbstractO3Test" />
			<role name="State" element="io.questdb.griffin.RecordToRowCopier" />
			<role name="state" element="io.questdb.test.griffin.AbstractO3Test::copier:io.questdb.griffin.RecordToRowCopier" />
			<role name="Request()" element="io.questdb.test.griffin.AbstractO3Test::insertUncommitted(io.questdb.griffin.SqlCompiler, io.questdb.griffin.SqlExecutionContext, java.lang.String, io.questdb.cairo.TableWriter):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.ParallelCsvFileImporter" />
			<role name="State" element="io.questdb.cairo.sql.RecordMetadata" />
			<role name="state" element="io.questdb.cutlass.text.ParallelCsvFileImporter::metadata:io.questdb.cairo.sql.RecordMetadata" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::initWriterAndOverrideImportMetadata(io.questdb.std.ObjList, io.questdb.std.ObjList, io.questdb.cutlass.text.types.TypeManager):void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::phaseBuildSymbolIndex():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::phaseSymbolTableMerge():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::phaseUpdateSymbolKeys():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::prepareTable(io.questdb.std.ObjList, io.questdb.std.ObjList, io.questdb.std.str.Path, io.questdb.cutlass.text.types.TypeManager):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CairoTextWriter" />
			<role name="State" element="io.questdb.cairo.sql.RecordMetadata" />
			<role name="state" element="io.questdb.cutlass.text.CairoTextWriter::metadata:io.questdb.cairo.sql.RecordMetadata" />
			<role name="Request()" element="io.questdb.cutlass.text.CairoTextWriter::initWriterAndOverrideImportTypes(io.questdb.cairo.TableToken, io.questdb.std.ObjList, io.questdb.std.ObjList, io.questdb.cutlass.text.types.TypeManager):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.jit.CompiledFilterIRSerializer" />
			<role name="State" element="io.questdb.cairo.sql.RecordMetadata" />
			<role name="state" element="io.questdb.jit.CompiledFilterIRSerializer::metadata:io.questdb.cairo.sql.RecordMetadata" />
			<role name="Request()" element="io.questdb.jit.CompiledFilterIRSerializer::isBooleanColumn(io.questdb.griffin.model.ExpressionNode):boolean" />
			<role name="Request()" element="io.questdb.jit.CompiledFilterIRSerializer::serializeColumn(int, java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Context" element="io.questdb.griffin.SqlCompiler" />
			<role name="state" element="io.questdb.griffin.SqlCompiler::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::alterTableAddColumn(int, io.questdb.cairo.TableToken, io.questdb.cairo.sql.TableRecordMetadata):io.questdb.griffin.CompiledQuery" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::alterTableColumnAddIndex(io.questdb.cairo.SecurityContext, int, io.questdb.cairo.TableToken, int, java.lang.CharSequence, io.questdb.cairo.sql.TableRecordMetadata, int):io.questdb.griffin.CompiledQuery" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::alterTableRenameColumn(io.questdb.cairo.SecurityContext, int, io.questdb.cairo.TableToken, io.questdb.cairo.sql.TableRecordMetadata):io.questdb.griffin.CompiledQuery" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::alterTableSetType(io.questdb.griffin.SqlExecutionContext, int, io.questdb.cairo.TableToken, byte):io.questdb.griffin.CompiledQuery" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::compileUsingModel(io.questdb.griffin.SqlExecutionContext):io.questdb.griffin.CompiledQuery" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::copyTableDataAndUnlock(io.questdb.cairo.SecurityContext, io.questdb.cairo.TableToken, boolean, io.questdb.cairo.sql.RecordCursor, io.questdb.cairo.sql.RecordMetadata, int, io.questdb.cairo.sql.SqlExecutionCircuitBreaker):void" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::copyTableReaderMetadataToCreateTableModel(io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.model.CreateTableModel):void" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::createTable(io.questdb.griffin.model.ExecutionModel, io.questdb.griffin.SqlExecutionContext):io.questdb.griffin.CompiledQuery" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::createTableWithRetries(io.questdb.griffin.model.ExecutionModel, io.questdb.griffin.SqlExecutionContext):io.questdb.griffin.CompiledQuery" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::reindexTable(io.questdb.griffin.SqlExecutionContext):io.questdb.griffin.CompiledQuery" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Context" element="io.questdb.griffin.SqlParser" />
			<role name="state" element="io.questdb.griffin.SqlParser::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.griffin.SqlParser::parseCopy(io.questdb.std.GenericLexer):io.questdb.griffin.model.ExecutionModel" />
			<role name="Request()" element="io.questdb.griffin.SqlParser::parseCreateTable(io.questdb.std.GenericLexer, io.questdb.griffin.SqlExecutionContext):io.questdb.griffin.model.ExecutionModel" />
			<role name="Request()" element="io.questdb.griffin.SqlParser::parseCreateTableAsSelect(io.questdb.std.GenericLexer, io.questdb.griffin.model.CreateTableModel, io.questdb.griffin.SqlExecutionContext):void" />
			<role name="Request()" element="io.questdb.griffin.SqlParser::parseCreateTableCastDef(io.questdb.std.GenericLexer, io.questdb.griffin.model.CreateTableModel):void" />
			<role name="Request()" element="io.questdb.griffin.SqlParser::parseCreateTableColumns(io.questdb.std.GenericLexer, io.questdb.griffin.model.CreateTableModel):void" />
			<role name="Request()" element="io.questdb.griffin.SqlParser::parseCreateTableIndexDef(io.questdb.std.GenericLexer, io.questdb.griffin.model.CreateTableModel):void" />
			<role name="Request()" element="io.questdb.griffin.SqlParser::parseCreateTableInlineIndexDef(io.questdb.std.GenericLexer, io.questdb.griffin.model.CreateTableModel):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Context" element="io.questdb.griffin.DatabaseSnapshotAgent" />
			<role name="state" element="io.questdb.griffin.DatabaseSnapshotAgent::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.griffin.DatabaseSnapshotAgent::completeSnapshot():void" />
			<role name="Request()" element="io.questdb.griffin.DatabaseSnapshotAgent::prepareSnapshot(io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Context" element="io.questdb.cairo.IDGenerator" />
			<role name="state" element="io.questdb.cairo.IDGenerator::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.IDGenerator::close():void" />
			<role name="Request()" element="io.questdb.cairo.IDGenerator::open(io.questdb.std.str.Path):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Context" element="io.questdb.cairo.TableNameRegistryFileStore" />
			<role name="state" element="io.questdb.cairo.TableNameRegistryFileStore::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryFileStore::close():void" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryFileStore::lock():boolean" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryFileStore::resetMemory():void" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryFileStore::compactTableNameFile(java.util.Map, java.util.Map, int, io.questdb.std.FilesFacade, io.questdb.std.str.Path, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryFileStore::readTableId(io.questdb.std.str.Path, java.lang.CharSequence, io.questdb.std.FilesFacade):int" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryFileStore::reloadFromRootDirectory(io.questdb.std.ConcurrentHashMap, io.questdb.std.ConcurrentHashMap):void" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryFileStore::reloadFromTablesFile(io.questdb.std.ConcurrentHashMap, io.questdb.std.ConcurrentHashMap, io.questdb.std.ObjList):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Context" element="io.questdb.cutlass.text.CopyTask$PhaseSymbolTableMerge" />
			<role name="state" element="io.questdb.cutlass.text.CopyTask$PhaseSymbolTableMerge::cfg:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyTask$PhaseSymbolTableMerge::run(io.questdb.std.str.Path):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashJoinRecordCursorFactory$HashJoinRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashJoinRecordCursorFactory$HashJoinRecordCursor::joinKeyMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashJoinRecordCursorFactory$HashJoinRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashJoinRecordCursorFactory$HashJoinRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashJoinRecordCursorFactory$HashJoinRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredRecordCursorFactory$HashOuterJoinRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredRecordCursorFactory$HashOuterJoinRecordCursor::joinKeyMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredRecordCursorFactory$HashOuterJoinRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredRecordCursorFactory$HashOuterJoinRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredRecordCursorFactory$HashOuterJoinRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashOuterJoinRecordCursorFactory$HashOuterJoinRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashOuterJoinRecordCursorFactory$HashOuterJoinRecordCursor::joinKeyMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinRecordCursorFactory$HashOuterJoinRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinRecordCursorFactory$HashOuterJoinRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinRecordCursorFactory$HashOuterJoinRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashJoinLightRecordCursorFactory$HashJoinRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashJoinLightRecordCursorFactory$HashJoinRecordCursor::joinKeyMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashJoinLightRecordCursorFactory$HashJoinRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashJoinLightRecordCursorFactory$HashJoinRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashJoinLightRecordCursorFactory$HashJoinRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredLightRecordCursorFactory$HashOuterJoinLightRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredLightRecordCursorFactory$HashOuterJoinLightRecordCursor::joinKeyMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredLightRecordCursorFactory$HashOuterJoinLightRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredLightRecordCursorFactory$HashOuterJoinLightRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredLightRecordCursorFactory$HashOuterJoinLightRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashOuterJoinLightRecordCursorFactory$HashOuterJoinLightRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashOuterJoinLightRecordCursorFactory$HashOuterJoinLightRecordCursor::joinKeyMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinLightRecordCursorFactory$HashOuterJoinLightRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinLightRecordCursorFactory$HashOuterJoinLightRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinLightRecordCursorFactory$HashOuterJoinLightRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::latestByMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::buildMap():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor::buildMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor::updateValueWhenClockMovesBack(io.questdb.cairo.map.MapValue):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.join.AsOfJoinLightRecordCursorFactory$AsOfLightJoinRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.AsOfJoinLightRecordCursorFactory$AsOfLightJoinRecordCursor::joinKeyMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.join.AsOfJoinLightRecordCursorFactory$AsOfLightJoinRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.AsOfJoinLightRecordCursorFactory$AsOfLightJoinRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.join.AsOfJoinRecordCursorFactory$AsOfJoinRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.AsOfJoinRecordCursorFactory$AsOfJoinRecordCursor::joinKeyMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.join.AsOfJoinRecordCursorFactory$AsOfJoinRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.AsOfJoinRecordCursorFactory$AsOfJoinRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.join.AsOfJoinRecordCursorFactory$AsOfJoinRecordCursor::of(io.questdb.cairo.sql.RecordCursor, io.questdb.cairo.sql.RecordCursor):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.join.LtJoinLightRecordCursorFactory$LtJoinLightRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.LtJoinLightRecordCursorFactory$LtJoinLightRecordCursor::joinKeyMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.join.LtJoinLightRecordCursorFactory$LtJoinLightRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.LtJoinLightRecordCursorFactory$LtJoinLightRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.join.LtJoinRecordCursorFactory$LtJoinRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.LtJoinRecordCursorFactory$LtJoinRecordCursor::joinKeyMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.join.LtJoinRecordCursorFactory$LtJoinRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.LtJoinRecordCursorFactory$LtJoinRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.join.LtJoinRecordCursorFactory$LtJoinRecordCursor::of(io.questdb.cairo.sql.RecordCursor, io.questdb.cairo.sql.RecordCursor):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.join.SpliceJoinLightRecordCursorFactory$SpliceJoinLightRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.SpliceJoinLightRecordCursorFactory$SpliceJoinLightRecordCursor::joinKeyMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.join.SpliceJoinLightRecordCursorFactory$SpliceJoinLightRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.SpliceJoinLightRecordCursorFactory$SpliceJoinLightRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.join.SpliceJoinLightRecordCursorFactory$SpliceJoinLightRecordCursor::masterRecordLeads():void" />
			<role name="Request()" element="io.questdb.griffin.engine.join.SpliceJoinLightRecordCursorFactory$SpliceJoinLightRecordCursor::slaveRecordLeads():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.union.UnionRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.union.UnionRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.union.UnionRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.union.UnionRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory" />
			<role name="State" element="io.questdb.cairo.sql.DelegatingRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory::cursor:io.questdb.cairo.sql.DelegatingRecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory::getCursor(io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.GenericRecordCursorFactory" />
			<role name="State" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.functions.GenericRecordCursorFactory::cursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.GenericRecordCursorFactory::getCursor(io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.pgwire.PGConnectionContext" />
			<role name="State" element="io.questdb.cutlass.pgwire.PGConnectionContext$PGResumeProcessor" />
			<role name="state" element="io.questdb.cutlass.pgwire.PGConnectionContext::resumeProcessor:io.questdb.cutlass.pgwire.PGConnectionContext$PGResumeProcessor" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::handleClientOperation(io.questdb.griffin.SqlCompiler, io.questdb.std.AssociativeCache, io.questdb.std.WeakSelfReturningObjectPool, io.questdb.std.AssociativeCache, io.questdb.std.WeakSelfReturningObjectPool, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CopyTask$PhaseBuildSymbolIndex" />
			<role name="State" element="io.questdb.cairo.sql.RecordMetadata" />
			<role name="state" element="io.questdb.cutlass.text.CopyTask$PhaseBuildSymbolIndex::metadata:io.questdb.cairo.sql.RecordMetadata" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyTask$PhaseBuildSymbolIndex::run():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.jit.CompiledFilterIRSerializerTest$TestIRSerializer" />
			<role name="State" element="io.questdb.cairo.sql.RecordMetadata" />
			<role name="state" element="io.questdb.test.jit.CompiledFilterIRSerializerTest$TestIRSerializer::metadata:io.questdb.cairo.sql.RecordMetadata" />
			<role name="Request()" element="io.questdb.test.jit.CompiledFilterIRSerializerTest$TestIRSerializer::appendColumn(int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InSymbolFunctionFactory$Func" />
			<role name="State" element="io.questdb.griffin.engine.functions.bool.InSymbolFunctionFactory$TestFunc" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InSymbolFunctionFactory$Func::testFunc:io.questdb.griffin.engine.functions.bool.InSymbolFunctionFactory$TestFunc" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InSymbolFunctionFactory$Func::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::dataMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::dataMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::checkIfNotDupe():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::latestByMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::buildMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::buildMapForOrderedSubQuery():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::buildMapForUnorderedSubQuery():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.GroupByRecordCursorFactory$GroupByRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.GroupByRecordCursorFactory$GroupByRecordCursor::dataMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.GroupByRecordCursorFactory$GroupByRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::recordKeyMap:io.questdb.cairo.map.Map" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::dataMap:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::of(io.questdb.cairo.sql.RecordCursor, io.questdb.griffin.SqlExecutionContext):void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::buildMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::fillGaps(long, long):void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::fillMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::findDataMapValue(io.questdb.cairo.sql.Record, long):io.questdb.cairo.map.MapValue" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::findDataMapValue2(io.questdb.cairo.sql.Record, long):io.questdb.cairo.map.MapValue" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::findDataMapValue3(io.questdb.cairo.sql.Record, long):io.questdb.cairo.map.MapValue" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::initMap():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::nullifyRange(long, long, io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.union.ExceptCastRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.union.ExceptCastRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.union.ExceptCastRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.union.ExceptCastRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.union.ExceptCastRecordCursor::hashCursorB():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.union.ExceptRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.union.ExceptRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.union.ExceptRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.union.ExceptRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.union.ExceptRecordCursor::hashCursorB():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.union.IntersectCastRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.union.IntersectCastRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.union.IntersectCastRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.union.IntersectCastRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.union.IntersectCastRecordCursor::hashCursorB():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.union.IntersectRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.union.IntersectRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.union.IntersectRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.union.IntersectRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.union.IntersectRecordCursor::hashCursorB():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.GroupByRecordCursorFactory$GroupByRecordCursor" />
			<role name="State" element="io.questdb.griffin.engine.groupby.GroupByFunctionsUpdater" />
			<role name="state" element="io.questdb.griffin.engine.groupby.GroupByRecordCursorFactory$GroupByRecordCursor::groupByFunctionsUpdater:io.questdb.griffin.engine.groupby.GroupByFunctionsUpdater" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.GroupByRecordCursorFactory$GroupByRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.union.UnionAllRecordCursor" />
			<role name="State" element="io.questdb.griffin.engine.union.UnionAllRecordCursor$NextMethod" />
			<role name="state" element="io.questdb.griffin.engine.union.UnionAllRecordCursor::nextMethod:io.questdb.griffin.engine.union.UnionAllRecordCursor$NextMethod" />
			<role name="state" element="io.questdb.griffin.engine.union.UnionAllRecordCursor::nextB:io.questdb.griffin.engine.union.UnionAllRecordCursor$NextMethod" />
			<role name="Request()" element="io.questdb.griffin.engine.union.UnionAllRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.union.UnionAllRecordCursor::switchToSlaveCursor():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.union.UnionRecordCursor" />
			<role name="State" element="io.questdb.griffin.engine.union.UnionRecordCursor$NextMethod" />
			<role name="state" element="io.questdb.griffin.engine.union.UnionRecordCursor::nextMethod:io.questdb.griffin.engine.union.UnionRecordCursor$NextMethod" />
			<role name="state" element="io.questdb.griffin.engine.union.UnionRecordCursor::nextB:io.questdb.griffin.engine.union.UnionRecordCursor$NextMethod" />
			<role name="Request()" element="io.questdb.griffin.engine.union.UnionRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.union.UnionRecordCursor::switchToCursorB():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.CountRecordCursorFactory$CountRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.CountRecordCursorFactory$CountRecordCursor::baseCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.CountRecordCursorFactory$CountRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.CountRecordCursorFactory$CountRecordCursor::of(io.questdb.cairo.sql.RecordCursor, io.questdb.cairo.sql.SqlExecutionCircuitBreaker):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.GroupByNotKeyedRecordCursorFactory$GroupByNotKeyedRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.GroupByNotKeyedRecordCursorFactory$GroupByNotKeyedRecordCursor::baseCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.GroupByNotKeyedRecordCursorFactory$GroupByNotKeyedRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor::mapCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByFillPrevRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByFillPrevRecordCursor::mapCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillPrevRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByFillValueRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByFillValueRecordCursor::mapCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillValueRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::baseCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::of(io.questdb.cairo.sql.RecordCursor, io.questdb.cairo.RecordSink, io.questdb.std.DirectLongList, long, io.questdb.cairo.sql.SqlExecutionCircuitBreaker):void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::toTop():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::buildMap():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.TableUpdateDetails$ThreadLocalDetails" />
			<role name="State" element="io.questdb.cairo.sql.TableRecordMetadata" />
			<role name="state" element="io.questdb.cutlass.line.tcp.TableUpdateDetails$ThreadLocalDetails::latestKnownMetadata:io.questdb.cairo.sql.TableRecordMetadata" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails$ThreadLocalDetails::getMetadataVersion():long" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails$ThreadLocalDetails::resetStateIfNecessary():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CopyTask$PhaseBuildSymbolIndex" />
			<role name="State" element="io.questdb.cairo.TableStructure" />
			<role name="state" element="io.questdb.cutlass.text.CopyTask$PhaseBuildSymbolIndex::tableStructure:io.questdb.cairo.TableStructure" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyTask$PhaseBuildSymbolIndex::run():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CopyTask$PhasePartitionImport" />
			<role name="State" element="io.questdb.cairo.TableStructure" />
			<role name="state" element="io.questdb.cutlass.text.CopyTask$PhasePartitionImport::targetTableStructure:io.questdb.cairo.TableStructure" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyTask$PhasePartitionImport::run(io.questdb.cutlass.text.TextLexerWrapper, long, long, io.questdb.std.str.DirectCharSink, io.questdb.std.DirectLongList, io.questdb.std.str.Path, io.questdb.std.str.Path):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CopyTask$PhaseUpdateSymbolKeys" />
			<role name="State" element="io.questdb.cairo.TableStructure" />
			<role name="state" element="io.questdb.cutlass.text.CopyTask$PhaseUpdateSymbolKeys::tableStructure:io.questdb.cairo.TableStructure" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyTask$PhaseUpdateSymbolKeys::run(io.questdb.std.str.Path):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$TableStructureAdapter" />
			<role name="State" element="io.questdb.cutlass.line.udp.CharSequenceCache" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$TableStructureAdapter::cache:io.questdb.cutlass.line.udp.CharSequenceCache" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$TableStructureAdapter::getColumnName(int):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$TableStructureAdapter::getTableName():java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.griffin.SqlCompiler" />
			<role name="state" element="io.questdb.griffin.SqlCompiler::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::compileBatch(java.lang.CharSequence, io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.BatchCallback):void" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::alterTable(io.questdb.griffin.SqlExecutionContext):io.questdb.griffin.CompiledQuery" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::alterTableResume(int, io.questdb.cairo.TableToken, long, io.questdb.griffin.SqlExecutionContext):io.questdb.griffin.CompiledQuery" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::compileUsingModel(io.questdb.griffin.SqlExecutionContext):io.questdb.griffin.CompiledQuery" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::copyTableDataAndUnlock(io.questdb.cairo.SecurityContext, io.questdb.cairo.TableToken, boolean, io.questdb.cairo.sql.RecordCursor, io.questdb.cairo.sql.RecordMetadata, int, io.questdb.cairo.sql.SqlExecutionCircuitBreaker):void" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::createTable(io.questdb.griffin.model.ExecutionModel, io.questdb.griffin.SqlExecutionContext):io.questdb.griffin.CompiledQuery" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::createTableFromCursorExecutor(io.questdb.griffin.model.CreateTableModel, io.questdb.griffin.SqlExecutionContext, int, java.lang.CharSequence):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler::truncateTables(io.questdb.griffin.SqlExecutionContext):io.questdb.griffin.CompiledQuery" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cutlass.text.CopyTask" />
			<role name="state" element="io.questdb.cutlass.text.CopyTask::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyTask::run(io.questdb.cutlass.text.TextLexerWrapper, io.questdb.cutlass.text.CsvFileIndexer, io.questdb.std.str.DirectCharSink, io.questdb.std.DirectLongList, long, long, io.questdb.std.str.Path, io.questdb.std.str.Path):boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.sql.async.PageFrameSequence" />
			<role name="state" element="io.questdb.cairo.sql.async.PageFrameSequence::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::await():void" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::clear():void" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::toTop():void" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::buildAddressCache():void" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::dispatch():boolean" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::workLocally():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.mp.Worker" />
			<role name="state" element="io.questdb.mp.Worker::log:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.mp.Worker::run():void" />
			<role name="Request()" element="io.questdb.mp.Worker::onError(int, java.lang.Throwable):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cutlass.text.types.InputFormatConfiguration" />
			<role name="state" element="io.questdb.cutlass.text.types.InputFormatConfiguration::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.types.InputFormatConfiguration::openStream(java.lang.Class, java.lang.String, java.lang.String):java.io.InputStream" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementEvent" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementEvent::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementEvent::append():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.Telemetry" />
			<role name="state" element="io.questdb.Telemetry::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.Telemetry::init(io.questdb.cairo.CairoEngine, io.questdb.griffin.SqlCompiler, io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cutlass.text.SerialCsvFileImporter" />
			<role name="state" element="io.questdb.cutlass.text.SerialCsvFileImporter::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.SerialCsvFileImporter::process(io.questdb.cairo.SecurityContext):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.wal.WalReader" />
			<role name="state" element="io.questdb.cairo.wal.WalReader::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.wal.WalReader::close():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalReader::openSegment():long" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cutlass.line.tcp.TableUpdateDetails" />
			<role name="state" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::addReference(int):void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::closeLocals():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::closeNoLock():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::commit(boolean):void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::removeReference(int):void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::handleCommitException(java.lang.Throwable):void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::commitIfMaxUncommittedRowsCountReached():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::releaseWriter(boolean):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.VacuumColumnVersions" />
			<role name="state" element="io.questdb.cairo.VacuumColumnVersions::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.VacuumColumnVersions::run(io.questdb.cairo.TableReader):void" />
			<role name="Request()" element="io.questdb.cairo.VacuumColumnVersions::queueColumnVersionPurge(io.questdb.tasks.ColumnPurgeTask, io.questdb.cairo.CairoEngine):void" />
			<role name="Request()" element="io.questdb.cairo.VacuumColumnVersions::visitTableFiles(long, int):void" />
			<role name="Request()" element="io.questdb.cairo.VacuumColumnVersions::visitTablePartition(long, int):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpParser" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpParser::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpParser::parseMeasurement(long):io.questdb.cutlass.line.tcp.LineTcpParser$ParseResult" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cutlass.line.tcp.IOTableUpdateDetailsPool" />
			<role name="state" element="io.questdb.cutlass.line.tcp.IOTableUpdateDetailsPool::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.IOTableUpdateDetailsPool::closeIdle(long, long):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.griffin.DatabaseSnapshotAgent" />
			<role name="state" element="io.questdb.griffin.DatabaseSnapshotAgent::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.DatabaseSnapshotAgent::recoverSnapshot(io.questdb.cairo.CairoEngine):void" />
			<role name="Request()" element="io.questdb.griffin.DatabaseSnapshotAgent::completeSnapshot():void" />
			<role name="Request()" element="io.questdb.griffin.DatabaseSnapshotAgent::prepareSnapshot(io.questdb.griffin.SqlExecutionContext):void" />
			<role name="Request()" element="io.questdb.griffin.DatabaseSnapshotAgent::lambda$recoverSnapshot$0(io.questdb.std.FilesFacade, io.questdb.std.str.Path, int, io.questdb.std.str.Path, int, java.util.concurrent.atomic.AtomicInteger, java.util.concurrent.atomic.AtomicInteger, java.util.concurrent.atomic.AtomicInteger, io.questdb.cairo.vm.api.MemoryCMARW, java.util.concurrent.atomic.AtomicInteger, long, int):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.griffin.DropIndexOperator" />
			<role name="state" element="io.questdb.griffin.DropIndexOperator::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.DropIndexOperator::executeDropIndex(java.lang.CharSequence, int):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.Bootstrap" />
			<role name="state" element="io.questdb.Bootstrap::log:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.Bootstrap::extractSite():void" />
			<role name="Request()" element="io.questdb.Bootstrap::loadProperties():java.util.Properties" />
			<role name="Request()" element="io.questdb.Bootstrap::extractSite0(java.lang.String, byte[], java.lang.String):void" />
			<role name="Request()" element="io.questdb.Bootstrap::reportValidateConfig():void" />
			<role name="Request()" element="io.questdb.Bootstrap::verifyFileSystem(io.questdb.std.str.Path, java.lang.CharSequence, java.lang.String):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.TelemetryConfigLogger" />
			<role name="state" element="io.questdb.TelemetryConfigLogger::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.TelemetryConfigLogger::appendConfigRow(io.questdb.griffin.SqlCompiler, io.questdb.cairo.TableWriter, io.questdb.std.Long256, boolean):void" />
			<role name="Request()" element="io.questdb.TelemetryConfigLogger::tryAddColumn(io.questdb.griffin.SqlCompiler, io.questdb.griffin.SqlExecutionContext, java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.TelemetryConfigLogger::updateTelemetryConfig(io.questdb.griffin.SqlCompiler, io.questdb.griffin.SqlExecutionContextImpl, io.questdb.cairo.TableToken):io.questdb.cairo.TableWriter" />
			<role name="Request()" element="io.questdb.TelemetryConfigLogger::init(io.questdb.griffin.SqlCompiler, io.questdb.griffin.SqlExecutionContextImpl):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.ColumnPurgeOperator" />
			<role name="state" element="io.questdb.cairo.ColumnPurgeOperator::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::purge(io.questdb.tasks.ColumnPurgeTask):boolean" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::purge(io.questdb.tasks.ColumnPurgeTask, io.questdb.cairo.TableReader):boolean" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::purgeExclusive(io.questdb.tasks.ColumnPurgeTask):void" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::couldNotRemove(io.questdb.std.FilesFacade, io.questdb.std.str.Path):boolean" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::checkScoreboardHasReadersBeforeUpdate(long, io.questdb.tasks.ColumnPurgeTask):boolean" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::closePurgeLogCompleteFile():void" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::openScoreboardAndTxn(io.questdb.tasks.ColumnPurgeTask, io.questdb.cairo.ColumnPurgeOperator$ScoreboardUseMode):boolean" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::purge0(io.questdb.tasks.ColumnPurgeTask, io.questdb.cairo.ColumnPurgeOperator$ScoreboardUseMode):boolean" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::reopenPurgeLogPartition(int, long):void" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::setCompletionTimestamp(io.questdb.std.LongList, long):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.DebugUtils" />
			<role name="state" element="io.questdb.cairo.DebugUtils::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.DebugUtils::reconcileColumnTops(int, io.questdb.std.LongList, io.questdb.cairo.ColumnVersionReader, io.questdb.cairo.TableReader):boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.O3Utils" />
			<role name="state" element="io.questdb.cairo.O3Utils::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.O3Utils::close(io.questdb.std.FilesFacade, int):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.TableConverter" />
			<role name="state" element="io.questdb.cairo.TableConverter::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.TableConverter::convertTables(io.questdb.cairo.CairoConfiguration, io.questdb.cairo.wal.seq.TableSequencerAPI):io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.cairo.TableConverter::removeWalPersistence(io.questdb.std.str.Path, int, io.questdb.std.FilesFacade, java.lang.String):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.TableNameRegistryFileStore" />
			<role name="state" element="io.questdb.cairo.TableNameRegistryFileStore::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryFileStore::compactTableNameFile(java.util.Map, java.util.Map, int, io.questdb.std.FilesFacade, io.questdb.std.str.Path, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryFileStore::readTableId(io.questdb.std.str.Path, java.lang.CharSequence, io.questdb.std.FilesFacade):int" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryFileStore::reloadFromRootDirectory(io.questdb.std.ConcurrentHashMap, io.questdb.std.ConcurrentHashMap):void" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryFileStore::reloadFromTablesFile(io.questdb.std.ConcurrentHashMap, io.questdb.std.ConcurrentHashMap, io.questdb.std.ObjList):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.TableUtils" />
			<role name="state" element="io.questdb.cairo.TableUtils::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.TableUtils::createTable(io.questdb.std.FilesFacade, java.lang.CharSequence, int, io.questdb.cairo.vm.api.MemoryMARW, io.questdb.std.str.Path, java.lang.CharSequence, io.questdb.cairo.TableStructure, int, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableUtils::createTableInVolume(io.questdb.std.FilesFacade, java.lang.CharSequence, int, io.questdb.cairo.vm.api.MemoryMARW, io.questdb.std.str.Path, java.lang.CharSequence, io.questdb.cairo.TableStructure, int, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableUtils::handleMetadataLoadException(java.lang.CharSequence, long, io.questdb.cairo.CairoException, io.questdb.std.datetime.millitime.MillisecondClock, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableUtils::lock(io.questdb.std.FilesFacade, io.questdb.std.str.Path, boolean):int" />
			<role name="Request()" element="io.questdb.cairo.TableUtils::readTableName(io.questdb.std.str.Path, int, io.questdb.cairo.vm.api.MemoryCMR, io.questdb.std.FilesFacade):java.lang.String" />
			<role name="Request()" element="io.questdb.cairo.TableUtils::safeReadTxn(io.questdb.cairo.TxReader, io.questdb.std.datetime.millitime.MillisecondClock, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableUtils::openMetaSwapFile(io.questdb.std.FilesFacade, io.questdb.cairo.vm.api.MemoryMA, io.questdb.std.str.Path, int, int):int" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.mig.EngineMigration" />
			<role name="state" element="io.questdb.cairo.mig.EngineMigration::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.mig.EngineMigration::migrateEngineTo(io.questdb.cairo.CairoEngine, int, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.mig.EngineMigration::upgradeTables(io.questdb.cairo.mig.MigrationContext, int, int):void" />
			<role name="Request()" element="io.questdb.cairo.mig.EngineMigration::backupFile(io.questdb.std.FilesFacade, io.questdb.std.str.Path, io.questdb.std.str.Path, java.lang.String, int):void" />
			<role name="Request()" element="io.questdb.cairo.mig.EngineMigration::lambda$upgradeTables$0(io.questdb.std.FilesFacade, io.questdb.std.str.Path, int, io.questdb.std.str.Path, io.questdb.cairo.mig.MigrationContext, long, int, int, long, int):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.mig.Mig607" />
			<role name="state" element="io.questdb.cairo.mig.Mig607::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.mig.Mig607::readColumnTop(io.questdb.std.FilesFacade, io.questdb.std.str.Path, java.lang.CharSequence, int, boolean):long" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.mig.Mig609" />
			<role name="state" element="io.questdb.cairo.mig.Mig609::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.mig.Mig609::migrate(io.questdb.cairo.mig.MigrationContext):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.mig.Mig614" />
			<role name="state" element="io.questdb.cairo.mig.Mig614::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.mig.Mig614::migrate(io.questdb.cairo.mig.MigrationContext):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.mig.Mig620" />
			<role name="state" element="io.questdb.cairo.mig.Mig620::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.mig.Mig620::openRO(io.questdb.std.FilesFacade, io.questdb.std.str.LPSZ):int" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.mig.Mig702" />
			<role name="state" element="io.questdb.cairo.mig.Mig702::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.mig.Mig702::migrate(io.questdb.cairo.mig.MigrationContext):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cutlass.http.processors.QueryCache" />
			<role name="state" element="io.questdb.cutlass.http.processors.QueryCache::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.QueryCache::clear():void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.QueryCache::close():void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.QueryCache::log(java.lang.CharSequence, java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cutlass.line.udp.LineUdpParserSupport" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpParserSupport::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserSupport::getValueType(java.lang.CharSequence, short, short):int" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserSupport::putValue(io.questdb.cairo.TableWriter$Row, int, int, int, java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cutlass.text.TextDelimiterScanner" />
			<role name="state" element="io.questdb.cutlass.text.TextDelimiterScanner::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.TextDelimiterScanner::scan(long, long):byte" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.griffin.PurgingOperator" />
			<role name="state" element="io.questdb.griffin.PurgingOperator::log:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.PurgingOperator::purge(io.questdb.std.str.Path, io.questdb.cairo.TableToken, int, boolean, io.questdb.cairo.sql.TableRecordMetadata, long, long):void" />
			<role name="Request()" element="io.questdb.griffin.PurgingOperator::purgeColumnVersionAsync(io.questdb.cairo.TableToken, java.lang.CharSequence, int, int, int, int, long, io.questdb.std.LongList):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.log.LogAlertSocket" />
			<role name="state" element="io.questdb.log.LogAlertSocket::log:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.log.LogAlertSocket::logResponse(int):void" />
			<role name="Request()" element="io.questdb.log.LogAlertSocket::send(int, java.lang.Runnable):boolean" />
			<role name="Request()" element="io.questdb.log.LogAlertSocket::logNetworkConnectError(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.log.LogAlertSocket::setDefaultHostPort():void" />
			<role name="Request()" element="io.questdb.log.LogAlertSocket::setHostPort(int, int, int):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.std.BytecodeAssembler" />
			<role name="state" element="io.questdb.std.BytecodeAssembler::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.std.BytecodeAssembler::endMethodCode():void" />
			<role name="Request()" element="io.questdb.std.BytecodeAssembler::newInstance():java.lang.Object" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.test.TestListener" />
			<role name="state" element="io.questdb.test.TestListener::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.test.TestListener::testAssumptionFailure(org.junit.runner.notification.Failure):void" />
			<role name="Request()" element="io.questdb.test.TestListener::testFinished(org.junit.runner.Description):void" />
			<role name="Request()" element="io.questdb.test.TestListener::testStarted(org.junit.runner.Description):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder" />
			<role name="state" element="io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder::executeExplicit(java.lang.String, int, java.lang.CharSequence, int, long, io.questdb.test.cutlass.http.HttpClientStateListener):void" />
			<role name="Request()" element="io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder::executeUntilDisconnect(java.lang.String, int, int, long, io.questdb.test.cutlass.http.HttpClientStateListener):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.test.log.MockAlertTarget" />
			<role name="state" element="io.questdb.test.log.MockAlertTarget::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.test.log.MockAlertTarget::run():void" />
			<role name="Request()" element="io.questdb.test.log.MockAlertTarget::safeClose(java.io.Closeable):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="Context" element="io.questdb.std.datetime.microtime.TimestampFormatUtils" />
			<role name="state" element="io.questdb.std.datetime.microtime.TimestampFormatUtils::UTC_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.std.datetime.microtime.TimestampFormatUtils::USEC_UTC_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.std.datetime.microtime.TimestampFormatUtils::HTTP_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.std.datetime.microtime.TimestampFormatUtils::NANOS_UTC_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.std.datetime.microtime.TimestampFormatUtils::FORMATS:io.questdb.std.datetime.DateFormat[]" />
			<role name="Request()" element="io.questdb.std.datetime.microtime.TimestampFormatUtils::appendDateTime(io.questdb.std.str.CharSink, long):void" />
			<role name="Request()" element="io.questdb.std.datetime.microtime.TimestampFormatUtils::appendDateTimeUSec(io.questdb.std.str.CharSink, long):void" />
			<role name="Request()" element="io.questdb.std.datetime.microtime.TimestampFormatUtils::formatHTTP(io.questdb.std.str.CharSink, long):void" />
			<role name="Request()" element="io.questdb.std.datetime.microtime.TimestampFormatUtils::parseDateTime(java.lang.CharSequence):long" />
			<role name="Request()" element="io.questdb.std.datetime.microtime.TimestampFormatUtils::parseTimestamp(java.lang.CharSequence, int, int):long" />
			<role name="Request()" element="io.questdb.std.datetime.microtime.TimestampFormatUtils::parseUTCTimestamp(java.lang.CharSequence):long" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="Context" element="io.questdb.std.datetime.millitime.DateFormatUtils" />
			<role name="state" element="io.questdb.std.datetime.millitime.DateFormatUtils::UTC_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.std.datetime.millitime.DateFormatUtils::HTTP_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.std.datetime.millitime.DateFormatUtils::appendDateTime(io.questdb.std.str.CharSink, long):void" />
			<role name="Request()" element="io.questdb.std.datetime.millitime.DateFormatUtils::formatHTTP(io.questdb.std.str.CharSink, long):void" />
			<role name="Request()" element="io.questdb.std.datetime.millitime.DateFormatUtils::parseUTCDate(java.lang.CharSequence):long" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="Context" element="io.questdb.cairo.PartitionBy" />
			<role name="state" element="io.questdb.cairo.PartitionBy::PARTITION_DAY_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.cairo.PartitionBy::PARTITION_MONTH_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.cairo.PartitionBy::PARTITION_YEAR_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.cairo.PartitionBy::PARTITION_HOUR_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.cairo.PartitionBy::PARTITION_WEEK_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.cairo.PartitionBy::DEFAULT_FORMAT:io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.cairo.PartitionBy::parsePartitionDirName(java.lang.CharSequence, int, int, int):long" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="Context" element="io.questdb.griffin.SqlUtil" />
			<role name="state" element="io.questdb.griffin.SqlUtil::DATE_FORMATS:io.questdb.std.datetime.DateFormat[]" />
			<role name="state" element="io.questdb.griffin.SqlUtil::DATE_FORMATS_FOR_TIMESTAMP:io.questdb.std.datetime.DateFormat[]" />
			<role name="Request()" element="io.questdb.griffin.SqlUtil::implicitCastStrAsDate(java.lang.CharSequence):long" />
			<role name="Request()" element="io.questdb.griffin.SqlUtil::implicitCastStrAsTimestamp(java.lang.CharSequence):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.pgwire.PGWireServer" />
			<role name="State" element="io.questdb.network.IODispatcher" />
			<role name="state" element="io.questdb.cutlass.pgwire.PGWireServer::dispatcher:io.questdb.network.IODispatcher" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGWireServer::getPort():int" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.map.Map" />
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByAllRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByAllRecordCursor::map:io.questdb.cairo.map.Map" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.vm.api.MemoryMARW" />
			<role name="Context" element="io.questdb.cairo.BitmapIndexWriter" />
			<role name="state" element="io.questdb.cairo.BitmapIndexWriter::keyMem:io.questdb.cairo.vm.api.MemoryMARW" />
			<role name="state" element="io.questdb.cairo.BitmapIndexWriter::valueMem:io.questdb.cairo.vm.api.MemoryMARW" />
			<role name="Request()" element="io.questdb.cairo.BitmapIndexWriter::of(io.questdb.cairo.CairoConfiguration, int, int, boolean, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.InsertRowImpl" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.InsertRowImpl::timestampFunction:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.InsertRowImpl::getRowWithStringTimestamp(io.questdb.cairo.TableWriterAPI):io.questdb.cairo.TableWriter$Row" />
			<role name="Request()" element="io.questdb.griffin.InsertRowImpl::getRowWithTimestamp(io.questdb.cairo.TableWriterAPI):io.questdb.cairo.TableWriter$Row" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation::function1:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation::function2:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation::andAssert(boolean):void" />
			<role name="Request()" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation::andAssert(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation::andAssert(int):void" />
			<role name="Request()" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation::andAssert(long):void" />
			<role name="Request()" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation::andAssert(double, double):void" />
			<role name="Request()" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation::andAssertDate(long):void" />
			<role name="Request()" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation::andAssertLong256(io.questdb.std.Long256):void" />
			<role name="Request()" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation::andAssertOnlyColumnValues(boolean):void" />
			<role name="Request()" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest$Invocation::andAssertTimestamp(long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.log.LogAlertSocket" />
			<role name="State" element="io.questdb.network.NetworkFacade" />
			<role name="state" element="io.questdb.log.LogAlertSocket::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.log.LogAlertSocket::connect():void" />
			<role name="Request()" element="io.questdb.log.LogAlertSocket::send(int, java.lang.Runnable):boolean" />
			<role name="Request()" element="io.questdb.log.LogAlertSocket::freeSocketAndAddress():void" />
			<role name="Request()" element="io.questdb.log.LogAlertSocket::logNetworkConnectError(java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder" />
			<role name="State" element="io.questdb.network.NetworkFacade" />
			<role name="state" element="io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder::connectAndSendRequest(java.lang.String):int" />
			<role name="Request()" element="io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder::execute(java.lang.String, java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder::executeExplicit(java.lang.String, int, java.lang.CharSequence, int, long, io.questdb.test.cutlass.http.HttpClientStateListener):void" />
			<role name="Request()" element="io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder::executeMany(io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder$RequestAction):void" />
			<role name="Request()" element="io.questdb.test.cutlass.http.SendAndReceiveRequestBuilder::executeUntilDisconnect(java.lang.String, int, int, long, io.questdb.test.cutlass.http.HttpClientStateListener):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.join.AsOfJoinRecordCursorFactory$AsOfJoinRecordCursor" />
			<role name="State" element="io.questdb.cairo.map.RecordValueSink" />
			<role name="state" element="io.questdb.griffin.engine.join.AsOfJoinRecordCursorFactory$AsOfJoinRecordCursor::valueSink:io.questdb.cairo.map.RecordValueSink" />
			<role name="Request()" element="io.questdb.griffin.engine.join.AsOfJoinRecordCursorFactory$AsOfJoinRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.join.LtJoinRecordCursorFactory$LtJoinRecordCursor" />
			<role name="State" element="io.questdb.cairo.map.RecordValueSink" />
			<role name="state" element="io.questdb.griffin.engine.join.LtJoinRecordCursorFactory$LtJoinRecordCursor::valueSink:io.questdb.cairo.map.RecordValueSink" />
			<role name="Request()" element="io.questdb.griffin.engine.join.LtJoinRecordCursorFactory$LtJoinRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.GroupByNotKeyedRecordCursorFactory$GroupByNotKeyedRecordCursor" />
			<role name="State" element="io.questdb.griffin.engine.groupby.GroupByFunctionsUpdater" />
			<role name="state" element="io.questdb.griffin.engine.groupby.GroupByNotKeyedRecordCursorFactory$GroupByNotKeyedRecordCursor::groupByFunctionsUpdater:io.questdb.griffin.engine.groupby.GroupByFunctionsUpdater" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.GroupByNotKeyedRecordCursorFactory$GroupByNotKeyedRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.ParallelCsvFileImporter" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cutlass.text.ParallelCsvFileImporter::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::parseStructure(int):void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::process():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::createWorkDir():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::movePartitions():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::removeWorkDir():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::lambda$movePartitions$2(io.questdb.std.str.Path, int, java.lang.CharSequence, io.questdb.std.str.Path, int, long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CsvFileIndexer" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cutlass.text.CsvFileIndexer::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::clear():void" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::index(long, long, long, io.questdb.std.LongList, long, long):void" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::sort(int, long):void" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::prepareTargetFile(long):io.questdb.cutlass.text.CsvFileIndexer$IndexOutputFile" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::openInputFile():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableReaderMetadata" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.TableReaderMetadata::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.TableReaderMetadata::load():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.BitmapIndexWriter" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.BitmapIndexWriter::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.BitmapIndexWriter::of(io.questdb.std.str.Path, java.lang.CharSequence, long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TxnScoreboard" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.TxnScoreboard::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.TxnScoreboard::close():void" />
			<role name="Request()" element="io.questdb.cairo.TxnScoreboard::ofRO(io.questdb.std.str.Path):io.questdb.cairo.TxnScoreboard" />
			<role name="Request()" element="io.questdb.cairo.TxnScoreboard::ofRW(io.questdb.std.str.Path):io.questdb.cairo.TxnScoreboard" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.mp.Sequence" />
			<role name="Context" element="io.questdb.test.mp.ConcurrentTest$BusyConsumer" />
			<role name="state" element="io.questdb.test.mp.ConcurrentTest$BusyConsumer::sequence:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.test.mp.ConcurrentTest$BusyConsumer::run():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.mp.Sequence" />
			<role name="Context" element="io.questdb.test.mp.ConcurrentTest$BusyProducer" />
			<role name="state" element="io.questdb.test.mp.ConcurrentTest$BusyProducer::sequence:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.test.mp.ConcurrentTest$BusyProducer::run():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.mp.Sequence" />
			<role name="Context" element="io.questdb.test.mp.ConcurrentTest$BusyProducerConsumer" />
			<role name="state" element="io.questdb.test.mp.ConcurrentTest$BusyProducerConsumer::producerSequence:io.questdb.mp.Sequence" />
			<role name="state" element="io.questdb.test.mp.ConcurrentTest$BusyProducerConsumer::consumerSequence:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.test.mp.ConcurrentTest$BusyProducerConsumer::run():void" />
			<role name="Request()" element="io.questdb.test.mp.ConcurrentTest$BusyProducerConsumer::consume():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.mp.Sequence" />
			<role name="Context" element="io.questdb.test.mp.ConcurrentTest$WaitingConsumer" />
			<role name="state" element="io.questdb.test.mp.ConcurrentTest$WaitingConsumer::sequence:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.test.mp.ConcurrentTest$WaitingConsumer::run():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.mp.Sequence" />
			<role name="Context" element="io.questdb.test.mp.OneToOnePerformanceTest$BusyConsumer" />
			<role name="state" element="io.questdb.test.mp.OneToOnePerformanceTest$BusyConsumer::sequence:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.test.mp.OneToOnePerformanceTest$BusyConsumer::run():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.mp.Sequence" />
			<role name="Context" element="io.questdb.test.mp.WorkerPoolOneToThreePerformanceTest$BusyConsumer" />
			<role name="state" element="io.questdb.test.mp.WorkerPoolOneToThreePerformanceTest$BusyConsumer::sequence:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.test.mp.WorkerPoolOneToThreePerformanceTest$BusyConsumer::run():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.cairo.CairoTestConfiguration" />
			<role name="State" element="io.questdb.test.cairo.ConfigurationOverrides" />
			<role name="state" element="io.questdb.test.cairo.CairoTestConfiguration::overrides:io.questdb.test.cairo.ConfigurationOverrides" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::attachPartitionCopy():boolean" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getAttachPartitionSuffix():java.lang.String" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getBackupDirTimestampFormat():io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getBackupRoot():java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getBinaryEncodingMaxLength():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getCircuitBreakerConfiguration():io.questdb.cairo.sql.SqlExecutionCircuitBreakerConfiguration" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getColumnPurgeQueueCapacity():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getColumnPurgeRetryDelay():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getColumnPurgeTaskPoolCapacity():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getCopyPoolCapacity():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getDataAppendPageSize():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getDefaultMapType():java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getFactoryProvider():io.questdb.FactoryProvider" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getFilesFacade():io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getInactiveReaderMaxOpenPartitions():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getMaxFileNameLength():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getMaxUncommittedRows():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getMicrosecondClock():io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getO3ColumnMemorySize():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getO3MaxLag():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getO3MinLag():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getO3LastPartitionMaxSplits():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getPageFrameReduceQueueCapacity():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getPageFrameReduceShardCount():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getQueryCacheEventQueueCapacity():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getRepeatMigrationsFromVersion():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getRndFunctionMemoryMaxPages():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getRndFunctionMemoryPageSize():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getRostiAllocFacade():io.questdb.std.RostiAllocFacade" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getSampleByIndexSearchPageSize():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getSnapshotInstanceId():java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getSpinLockTimeout():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getSqlCopyBufferSize():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getSqlCopyInputRoot():java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getSqlCopyInputWorkRoot():java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getSqlCopyLogRetentionDays():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getSqlJitMode():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getSqlJoinMetadataMaxResizes():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getSqlJoinMetadataPageSize():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getSqlPageFrameMaxRows():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getTableRegistryCompactionThreshold():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getWalApplyTableTimeQuota():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getWalEnabledDefault():boolean" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getWalPurgeInterval():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getWalRecreateDistressedSequencerAttempts():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getWalSegmentRolloverRowCount():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getWalTxnNotificationQueueCapacity():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getPartitionO3SplitMinSize():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getWriterAsyncCommandBusyWaitTimeout():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getWriterAsyncCommandMaxTimeout():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getWriterCommandQueueCapacity():int" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::getWriterCommandQueueSlotSize():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::isIOURingEnabled():boolean" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::isO3QuickSortEnabled():boolean" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::isSnapshotRecoveryEnabled():boolean" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::isSqlParallelFilterEnabled():boolean" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::isSqlParallelFilterPreTouchEnabled():boolean" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::isWriterMixedIOEnabled():boolean" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::mangleTableDirNames():boolean" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::lambda$getNanosecondClock$1():long" />
			<role name="Request()" element="io.questdb.test.cairo.CairoTestConfiguration::lambda$getMillisecondClock$0():long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.ColumnPurgeJob" />
			<role name="State" element="io.questdb.mp.Sequence" />
			<role name="state" element="io.questdb.cairo.ColumnPurgeJob::inSubSequence:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeJob::processInQueue():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.WaitProcessor" />
			<role name="State" element="io.questdb.mp.Sequence" />
			<role name="state" element="io.questdb.cutlass.http.WaitProcessor::outSubSequence:io.questdb.mp.Sequence" />
			<role name="state" element="io.questdb.cutlass.http.WaitProcessor::inSubSequence:io.questdb.mp.Sequence" />
			<role name="state" element="io.questdb.cutlass.http.WaitProcessor::inPubSequence:io.questdb.mp.Sequence" />
			<role name="state" element="io.questdb.cutlass.http.WaitProcessor::outPubSequence:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.cutlass.http.WaitProcessor::getNextRerun():io.questdb.cutlass.http.Retry" />
			<role name="Request()" element="io.questdb.cutlass.http.WaitProcessor::processInQueue():boolean" />
			<role name="Request()" element="io.questdb.cutlass.http.WaitProcessor::reschedule(io.questdb.cutlass.http.Retry, int, long):void" />
			<role name="Request()" element="io.questdb.cutlass.http.WaitProcessor::sendToOutQueue(io.questdb.cutlass.http.Retry):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob" />
			<role name="State" element="io.questdb.mp.Sequence" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob::sequence:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob::drainQueue():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CopyRequestJob" />
			<role name="State" element="io.questdb.mp.Sequence" />
			<role name="state" element="io.questdb.cutlass.text.CopyRequestJob::requestSubSeq:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyRequestJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.SqlCodeGenerator" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.griffin.SqlCodeGenerator::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.griffin.SqlCodeGenerator::generateCastFunctions(io.questdb.cairo.sql.RecordMetadata, io.questdb.cairo.sql.RecordMetadata, int):io.questdb.std.ObjList" />
			<role name="Request()" element="io.questdb.griffin.SqlCodeGenerator::generateFilter0(io.questdb.cairo.sql.RecordCursorFactory, io.questdb.griffin.model.QueryModel, io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.model.ExpressionNode):io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Request()" element="io.questdb.griffin.SqlCodeGenerator::generateSampleBy(io.questdb.griffin.model.QueryModel, io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.model.ExpressionNode, io.questdb.griffin.model.ExpressionNode):io.questdb.cairo.sql.RecordCursorFactory" />
			<role name="Request()" element="io.questdb.griffin.SqlCodeGenerator::generateTableQuery0(io.questdb.griffin.model.QueryModel, io.questdb.griffin.SqlExecutionContext, io.questdb.std.ObjList, boolean, io.questdb.cairo.TableReader, io.questdb.cairo.sql.TableRecordMetadata):io.questdb.cairo.sql.RecordCursorFactory" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.ParallelCsvFileImporter" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cutlass.text.ParallelCsvFileImporter::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::of(java.lang.CharSequence, java.lang.CharSequence, long, int, byte, java.lang.CharSequence, java.lang.CharSequence, boolean, io.questdb.cairo.sql.ExecutionCircuitBreaker, int):void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::createWorkDir():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::isOneOfMainDirectories(java.lang.CharSequence):boolean" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::movePartitions():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::prepareTable(io.questdb.std.ObjList, io.questdb.std.ObjList, io.questdb.std.str.Path, io.questdb.cutlass.text.types.TypeManager):void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::lambda$movePartitions$2(io.questdb.std.str.Path, int, java.lang.CharSequence, io.questdb.std.str.Path, int, long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableReaderMetadata" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cairo.TableReaderMetadata::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.TableReaderMetadata::load():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.DynamicTableReaderMetadata" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cairo.DynamicTableReaderMetadata::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.DynamicTableReaderMetadata::readTxnSlow(long):void" />
			<role name="Request()" element="io.questdb.cairo.DynamicTableReaderMetadata::reloadMetadata(long, long):boolean" />
			<role name="Request()" element="io.questdb.cairo.DynamicTableReaderMetadata::reloadSlow():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.BitmapIndexWriter" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cairo.BitmapIndexWriter::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.BitmapIndexWriter::commit():void" />
			<role name="Request()" element="io.questdb.cairo.BitmapIndexWriter::of(io.questdb.std.str.Path, java.lang.CharSequence, long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.ColumnVersionWriter" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cairo.ColumnVersionWriter::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.ColumnVersionWriter::doCommit():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TxWriter" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cairo.TxWriter::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.TxWriter::commit(io.questdb.std.ObjList):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.SqlCodeGenerator" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.griffin.SqlCodeGenerator::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.SqlCodeGenerator::canBeOptimized(io.questdb.griffin.model.QueryModel, io.questdb.griffin.SqlExecutionContext, io.questdb.cairo.sql.Function, io.questdb.cairo.sql.Function):boolean" />
			<role name="Request()" element="io.questdb.griffin.SqlCodeGenerator::generateFilter0(io.questdb.cairo.sql.RecordCursorFactory, io.questdb.griffin.model.QueryModel, io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.model.ExpressionNode):io.questdb.cairo.sql.RecordCursorFactory" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.ParallelCsvFileImporter" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.text.ParallelCsvFileImporter::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::createTable(io.questdb.std.FilesFacade, int, java.lang.CharSequence, java.lang.CharSequence, java.lang.CharSequence, io.questdb.cairo.TableStructure, int):void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::process():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::createWorkDir():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::logTypeError(int, int):void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::movePartitions():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::normalize(java.lang.CharSequence):java.lang.String" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::phaseEpilogue(byte):void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::phasePrologue(byte):void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::removeWorkDir():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CairoTextWriter" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.text.CairoTextWriter::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.CairoTextWriter::logError(long, int, io.questdb.std.str.DirectByteCharSequence):void" />
			<role name="Request()" element="io.questdb.cutlass.text.CairoTextWriter::logTypeError(int):void" />
			<role name="Request()" element="io.questdb.cutlass.text.CairoTextWriter::prepareTable(io.questdb.cairo.SecurityContext, io.questdb.std.ObjList, io.questdb.std.ObjList, io.questdb.std.str.Path, io.questdb.cutlass.text.types.TypeManager, io.questdb.cutlass.text.types.TimestampAdapter):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.TextMetadataDetector" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.text.TextMetadataDetector::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.TextMetadataDetector::evaluateResults(long, long):void" />
			<role name="Request()" element="io.questdb.cutlass.text.TextMetadataDetector::stashPossibleHeader(io.questdb.std.ObjList, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.pgwire.PGConnectionContext" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.pgwire.PGConnectionContext::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::getInt(long, long, java.lang.CharSequence):int" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::getShort(long, long, java.lang.CharSequence):short" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::getStringLength(long, long, java.lang.CharSequence):long" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::setCharBindVariable(int, long, int):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::setStrBindVariable(int, long, int):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::bindParameterFormats(long, long, short, io.questdb.std.IntList):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::ensureValueLength(int, int, int):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::appendSingleRecord(io.questdb.cairo.sql.Record, int):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::assertTrue(boolean, java.lang.String):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::bindValuesAsStrings(long, long, short):long" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::bindValuesUsingSetters(long, long, short):long" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::compileQuery(io.questdb.griffin.SqlCompiler):boolean" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::configureContextFromNamedStatement(java.lang.CharSequence, io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::configurePortal(java.lang.CharSequence, java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::configurePreparedStatement(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::doSendWithRetries(int, int):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::executeInsert(io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::executeTag():void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::executeUpdate(io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::getString(long, long, java.lang.CharSequence):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::parse(long, int, io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::parseQueryText(long, long, io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::prepareDescribePortalResponse():void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::prepareEmptyQueryResponse():void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::prepareError(io.questdb.cairo.CairoException):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::prepareForNewBatchQuery():void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::prepareNonCriticalError(int, java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::prepareQueryCanceled(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::processBind(long, long, io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::processClose(long, long):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::processCompiledQuery(io.questdb.griffin.CompiledQuery):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::processDescribe(long, long, io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::processExec(long, long, io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::processExecute(int, io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::processInitialMessage(long, int):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::processParse(long, long, long, io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::processQuery(long, long, io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::setupFactoryAndCursor(io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::setupVariableSettersFromWrapper(io.questdb.cutlass.pgwire.PGConnectionContext$NamedStatementWrapper, io.questdb.griffin.SqlCompiler):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::shiftReceiveBuffer(long):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::validateParameterCounts(short, short, int):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::prepareCommandComplete(boolean):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::prepareReadyForQuery():void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::prepareSuspended():void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::recv():int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.TextMetadataParser" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.text.TextMetadataParser::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.TextMetadataParser::onEvent(int, java.lang.CharSequence, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.TextLoader" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.text.TextLoader::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.TextLoader::configureDestination(java.lang.CharSequence, boolean, int, int, java.lang.CharSequence, java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cutlass.text.TextLoader::setState(int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.FunctionParser" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.griffin.FunctionParser::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.FunctionParser::checkAndCreateFunction(io.questdb.griffin.FunctionFactory, io.questdb.std.ObjList, io.questdb.std.IntList, io.questdb.griffin.model.ExpressionNode, io.questdb.cairo.CairoConfiguration):io.questdb.cairo.sql.Function" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CsvFileIndexer" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.text.CsvFileIndexer::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::index(long, long, long, io.questdb.std.LongList, long, long):void" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::indexLine(long, long):void" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::parseLast():void" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::fitsInBuffer(int):boolean" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::parseTimestamp():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::critical():io.questdb.log.LogRecord" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::error():io.questdb.log.LogRecord" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::info():io.questdb.log.LogRecord" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::onNoMoreData():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.std.ObjectPool" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.std.ObjectPool::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.std.ObjectPool::expand():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.HttpConnectionContext" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.http.HttpConnectionContext::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::clear():void" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::close():void" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::fail(io.questdb.cutlass.http.HttpRequestProcessorSelector, io.questdb.cutlass.http.HttpException):void" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::tryRerun(io.questdb.cutlass.http.HttpRequestProcessorSelector, io.questdb.cutlass.http.RescheduleContext):boolean" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::completeRequest(io.questdb.cutlass.http.HttpRequestProcessor, io.questdb.cutlass.http.RescheduleContext):void" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::consumeMultipart(int, io.questdb.cutlass.http.HttpRequestProcessor, long, int, boolean, io.questdb.cutlass.http.RescheduleContext):boolean" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::continueConsumeMultipart(int, long, long, int, io.questdb.cutlass.http.HttpMultipartContentListener, io.questdb.cutlass.http.HttpRequestProcessor, io.questdb.cutlass.http.RescheduleContext):boolean" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::failProcessor(io.questdb.cutlass.http.HttpRequestProcessor, io.questdb.cutlass.http.HttpException, int):void" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::handleClientRecv(io.questdb.cutlass.http.HttpRequestProcessorSelector, io.questdb.cutlass.http.RescheduleContext):boolean" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::handleClientSend():boolean" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::rejectRequest(java.lang.CharSequence):boolean" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::shiftReceiveBufferUnprocessedBytes(long, int):void" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::lambda$new$0(io.questdb.cutlass.http.Retry):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.CharacterStore" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.griffin.CharacterStore::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.CharacterStore::resizeAndPut(char):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.ops.AlterOperation" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.griffin.engine.ops.AlterOperation::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation::apply(io.questdb.cairo.wal.MetadataService, boolean):long" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation::applyParamO3MaxLag(io.questdb.cairo.wal.MetadataService):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.ColumnVersionReader" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.ColumnVersionReader::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.ColumnVersionReader::readSafe(io.questdb.std.datetime.millitime.MillisecondClock, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.std.MemoryPages" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.std.MemoryPages::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.std.MemoryPages::allocate0(long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::commitWalTables(long):long" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::doHandleDisconnectEvent():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::logParseError():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::parseMeasurements(io.questdb.cutlass.line.tcp.NetworkIOJob):io.questdb.cutlass.line.tcp.LineTcpConnectionContext$IOContextResult" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.HttpResponseSink" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.http.HttpResponseSink::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpResponseSink::deflate():void" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpResponseSink::sendBuffer(io.questdb.cutlass.http.HttpResponseSink$ChunkBuffer):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.DynamicTableReaderMetadata" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.DynamicTableReaderMetadata::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.DynamicTableReaderMetadata::readTxnSlow(long):void" />
			<role name="Request()" element="io.questdb.cairo.DynamicTableReaderMetadata::reloadMetadata(long, long):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.IndexBuilder" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.IndexBuilder::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.IndexBuilder::createIndexFiles(io.questdb.std.FilesFacade, java.lang.CharSequence, int, int, long):void" />
			<role name="Request()" element="io.questdb.cairo.IndexBuilder::removeFile(io.questdb.std.FilesFacade, io.questdb.std.str.Path):void" />
			<role name="Request()" element="io.questdb.cairo.IndexBuilder::doReindex(io.questdb.std.FilesFacade, io.questdb.cairo.ColumnVersionReader, int, java.lang.CharSequence, long, long, long, int, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.BitmapIndexWriter" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.BitmapIndexWriter::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.BitmapIndexWriter::of(io.questdb.cairo.CairoConfiguration, int, int, boolean, int):void" />
			<role name="Request()" element="io.questdb.cairo.BitmapIndexWriter::of(io.questdb.std.str.Path, java.lang.CharSequence, long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.RecoverVarIndex" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.RecoverVarIndex::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.RecoverVarIndex::doReindex(io.questdb.std.FilesFacade, io.questdb.cairo.ColumnVersionReader, int, java.lang.CharSequence, long, long, long, int, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TxnScoreboard" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.TxnScoreboard::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.TxnScoreboard::close():void" />
			<role name="Request()" element="io.questdb.cairo.TxnScoreboard::acquireTxn(long, long):long" />
			<role name="Request()" element="io.questdb.cairo.TxnScoreboard::releaseTxn(long, long):long" />
			<role name="Request()" element="io.questdb.cairo.TxnScoreboard::openCleanRW(io.questdb.std.FilesFacade, io.questdb.std.str.LPSZ, long):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.vm.MemoryCARWImpl" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.vm.MemoryCARWImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryCARWImpl::extend0(long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.vm.MemoryCMARWImpl" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.vm.MemoryCMARWImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryCMARWImpl::close(boolean, byte):void" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryCMARWImpl::map(io.questdb.std.FilesFacade, java.lang.CharSequence, long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.vm.MemoryCMORImpl" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.vm.MemoryCMORImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryCMORImpl::map(io.questdb.std.FilesFacade, io.questdb.std.str.LPSZ, long, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.vm.MemoryCMRImpl" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.vm.MemoryCMRImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryCMRImpl::close():void" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryCMRImpl::map(io.questdb.std.FilesFacade, io.questdb.std.str.LPSZ, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.std.DirectLongList" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.std.DirectLongList::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.std.DirectLongList::setCapacityBytes(long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.CheckWalTransactionsJob" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.wal.CheckWalTransactionsJob::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.wal.CheckWalTransactionsJob::checkNotifyOutstandingTxnInWal(io.questdb.cairo.TableToken, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.WalPurgeJob" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.wal.WalPurgeJob::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::broadSweep(int, io.questdb.cairo.TableToken, long):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::deleteFile(io.questdb.std.str.Path):boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::discoverWalSegments():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::recursiveDelete(io.questdb.std.str.Path):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::segmentHasPendingTasks(int, int):boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::unlocked(io.questdb.std.str.Path):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.log.LogRollingFileWriter" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.log.LogRollingFileWriter::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::close():void" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::buildUniquePath():void" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::flush():void" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::openFile():void" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::pushFileStackUp():void" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::removeExcessiveLogs():void" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::removeExcessiveLogs(long, int):void" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::removeExpiredLogs(long, int):void" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::removeOldLogs():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.cairo.LogRecordSinkAdapter" />
			<role name="State" element="io.questdb.log.LogRecord" />
			<role name="state" element="io.questdb.test.cairo.LogRecordSinkAdapter::line:io.questdb.log.LogRecord" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::put(java.lang.CharSequence):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::put(char):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::put(int):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::put(long):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::put(float, int):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::put(double):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::put(double, int):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::put(boolean):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::put(java.lang.Throwable):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::put(io.questdb.std.Sinkable):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::putISODate(long):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::putISODateMillis(long):io.questdb.std.str.CharSink" />
			<role name="Request()" element="io.questdb.test.cairo.LogRecordSinkAdapter::putQuoted(java.lang.CharSequence):io.questdb.std.str.CharSink" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableWriter" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cairo.TableWriter::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::attachPartition(long, long):io.questdb.cairo.AttachDetachStatus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::commitWalTransaction(io.questdb.std.str.Path, boolean, long, long, long, long, io.questdb.cairo.wal.SymbolMapDiffCursor, long):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::detachPartition(long):io.questdb.cairo.AttachDetachStatus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::dropIndex(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::getPartitionO3SplitThreshold():long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumnToMeta(java.lang.CharSequence, int, boolean, int, boolean):int" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::checkColumnName(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::commit(long):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::configureColumn(int, boolean, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::copyMetadataAndSetIndexAttrs(int, int, int):int" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::copyMetadataAndUpdateVersion():long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::getMaxWalSquashRows():long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::mmapWalColumns(io.questdb.std.str.Path, int, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::openColumnFiles(java.lang.CharSequence, long, int, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::openTodoMem():long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removePartitionDirsNotAttached(long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::squashSplitPartitions(int, int, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::syncColumns():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::truncate(boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::updateIndexesParallel(long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::updateIndexesSlow():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::writeRestoreMetaTodo():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.WalWriter" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cairo.wal.WalWriter::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::addColumn(java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::commit():long" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::rollUncommittedToNewSegment():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::configureSymbolTable():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::closeSegmentSwitchFiles(io.questdb.std.LongList):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::configureColumn(int, int):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::configureSymbolMapWriter(int, java.lang.CharSequence, int, long):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::createSecondaryMem(int):io.questdb.cairo.vm.api.MemoryMA" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::mayRollSegmentOnNextRow():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::openColumnFiles(java.lang.CharSequence, int, int):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::openNewSegment():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory::initializeLimitedSizeCursor(io.questdb.griffin.SqlExecutionContext, io.questdb.cairo.sql.RecordCursor):void" />
			<role name="Request()" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory::initializeUnlimitedSizeCursor():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.ShowPartitionsRecordCursorFactory" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.griffin.engine.table.ShowPartitionsRecordCursorFactory::cairoConfig:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.griffin.engine.table.ShowPartitionsRecordCursorFactory::getCursor(io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.table.DataFrameRecordCursorFactory" />
			<role name="state" element="io.questdb.griffin.engine.table.DataFrameRecordCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.DataFrameRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursorFactory" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.SqlExecutionContextImpl" />
			<role name="State" element="io.questdb.griffin.SqlExecutionContextImpl$TelemetryFacade" />
			<role name="state" element="io.questdb.griffin.SqlExecutionContextImpl::telemetryFacade:io.questdb.griffin.SqlExecutionContextImpl$TelemetryFacade" />
			<role name="Request()" element="io.questdb.griffin.SqlExecutionContextImpl::storeTelemetry(short, short):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.TelemetryJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.TelemetryJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.TelemetryJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.ColumnPurgeJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.ColumnPurgeJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeJob::commit():void" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeJob::processTableRecords(io.questdb.cairo.CairoEngine):void" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeJob::saveToStorage(io.questdb.cairo.ColumnPurgeJob$ColumnPurgeRetryTask):void" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.O3CopyJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.O3CopyJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.O3CopyJob::copy(java.util.concurrent.atomic.AtomicInteger, java.util.concurrent.atomic.AtomicInteger, int, int, long, long, int, long, long, long, int, long, long, long, long, long, long, long, long, long, long, long, long, long, long, long, long, int, long, long, long, long, int, long, long, long, long, long, int, int, long, long, int, int, long, long, boolean, long, long, io.questdb.cairo.TableWriter, io.questdb.cairo.BitmapIndexWriter, long):void" />
			<role name="Request()" element="io.questdb.cairo.O3CopyJob::copyTail(java.util.concurrent.atomic.AtomicInteger, java.util.concurrent.atomic.AtomicInteger, long, long, int, long, long, int, long, long, long, long, long, long, int, long, long, int, long, long, int, int, long, long, int, int, long, long, boolean, long, long, io.questdb.cairo.TableWriter, io.questdb.cairo.BitmapIndexWriter, long):void" />
			<role name="Request()" element="io.questdb.cairo.O3CopyJob::syncColumns(java.util.concurrent.atomic.AtomicInteger, long, long, int, long, long, int, long, long, int, long, long, int, long, long, int, long, long, io.questdb.cairo.TableWriter, io.questdb.std.FilesFacade, int):void" />
			<role name="Request()" element="io.questdb.cairo.O3CopyJob::updateIndex(java.util.concurrent.atomic.AtomicInteger, long, long, int, long, long, int, long, long, int, long, long, int, long, long, int, int, long, long, int, long, long, io.questdb.cairo.TableWriter, io.questdb.cairo.BitmapIndexWriter, int):void" />
			<role name="Request()" element="io.questdb.cairo.O3CopyJob::closeColumnIdle(java.util.concurrent.atomic.AtomicInteger, long, long, int, long, long, io.questdb.cairo.TableWriter):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.O3OpenColumnJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.O3OpenColumnJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.O3OpenColumnJob::appendFixColumn(io.questdb.std.str.Path, int, java.lang.CharSequence, java.util.concurrent.atomic.AtomicInteger, int, long, long, long, long, long, long, long, long, long, int, int, long, long, int, io.questdb.cairo.vm.api.MemoryMA, long, io.questdb.cairo.TableWriter, long, long, io.questdb.cairo.BitmapIndexWriter, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.O3OpenColumnJob::appendMidPartition(io.questdb.std.str.Path, int, java.lang.CharSequence, java.util.concurrent.atomic.AtomicInteger, int, long, long, long, long, long, long, long, long, long, long, int, int, long, long, long, long, io.questdb.cairo.TableWriter, io.questdb.cairo.BitmapIndexWriter, long, int, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.O3OpenColumnJob::appendNewPartition(io.questdb.std.str.Path, int, java.lang.CharSequence, java.util.concurrent.atomic.AtomicInteger, int, long, long, long, long, long, long, long, long, long, long, int, long, long, io.questdb.cairo.TableWriter, io.questdb.cairo.BitmapIndexWriter, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.O3OpenColumnJob::appendTimestampColumn(java.util.concurrent.atomic.AtomicInteger, int, long, long, long, long, long, long, long, long, int, int, long, long, io.questdb.cairo.vm.api.MemoryMA, long, long, long, io.questdb.cairo.TableWriter, long):void" />
			<role name="Request()" element="io.questdb.cairo.O3OpenColumnJob::appendVarColumn(java.util.concurrent.atomic.AtomicInteger, int, long, long, long, long, long, long, long, long, long, int, int, long, long, int, int, io.questdb.cairo.vm.api.MemoryMA, io.questdb.cairo.vm.api.MemoryMA, long, long, long, io.questdb.cairo.TableWriter, long):void" />
			<role name="Request()" element="io.questdb.cairo.O3OpenColumnJob::mergeFixColumn(io.questdb.std.str.Path, int, java.lang.CharSequence, java.util.concurrent.atomic.AtomicInteger, java.util.concurrent.atomic.AtomicInteger, int, long, long, long, long, long, long, long, long, long, long, long, int, int, long, long, int, long, long, int, long, long, long, long, long, int, long, long, int, long, long, io.questdb.cairo.TableWriter, io.questdb.cairo.BitmapIndexWriter, long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.O3OpenColumnJob::mergeMidPartition(io.questdb.std.str.Path, int, io.questdb.std.str.Path, int, java.lang.CharSequence, java.util.concurrent.atomic.AtomicInteger, java.util.concurrent.atomic.AtomicInteger, int, long, long, long, long, long, long, long, long, long, long, long, int, long, long, int, long, long, long, long, long, int, long, long, int, int, long, long, long, long, io.questdb.cairo.TableWriter, io.questdb.cairo.BitmapIndexWriter, long, long, int, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.O3OpenColumnJob::mergeVarColumn(io.questdb.std.str.Path, int, java.lang.CharSequence, java.util.concurrent.atomic.AtomicInteger, java.util.concurrent.atomic.AtomicInteger, int, long, long, long, long, long, long, long, long, long, long, long, int, long, long, int, long, long, long, long, long, int, long, long, int, int, long, long, int, int, long, long, io.questdb.cairo.TableWriter, long, long, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.O3PartitionJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.O3PartitionJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.O3PartitionJob::processPartition(io.questdb.std.str.Path, int, io.questdb.std.ObjList, io.questdb.std.ReadOnlyObjList, long, long, long, long, long, long, long, long, long, boolean, long, long, io.questdb.cairo.TableWriter, java.util.concurrent.atomic.AtomicInteger, io.questdb.cairo.O3Basket, long):void" />
			<role name="Request()" element="io.questdb.cairo.O3PartitionJob::publishOpenColumnTasks(long, io.questdb.std.ObjList, io.questdb.std.ReadOnlyObjList, io.questdb.std.str.Path, long, long, long, long, long, long, long, int, long, long, int, long, long, long, long, int, long, long, long, long, int, int, long, long, int, long, long, long, io.questdb.cairo.TableWriter, java.util.concurrent.atomic.AtomicInteger, io.questdb.cairo.O3Basket, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.O3PartitionPurgeJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.O3PartitionPurgeJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.O3PartitionPurgeJob::parsePartitionDateVersion(io.questdb.std.str.StringSink, io.questdb.std.DirectLongList, java.lang.CharSequence, io.questdb.std.datetime.DateFormat):void" />
			<role name="Request()" element="io.questdb.cairo.O3PartitionPurgeJob::processDetachedPartition(io.questdb.std.FilesFacade, io.questdb.std.str.Path, int, io.questdb.cairo.TxReader, io.questdb.cairo.TxnScoreboard, long, int, io.questdb.std.DirectLongList, int, int):void" />
			<role name="Request()" element="io.questdb.cairo.O3PartitionPurgeJob::processPartition0(io.questdb.std.FilesFacade, io.questdb.std.str.Path, int, io.questdb.cairo.TxReader, io.questdb.cairo.TxnScoreboard, long, int, io.questdb.std.DirectLongList, int, int):void" />
			<role name="Request()" element="io.questdb.cairo.O3PartitionPurgeJob::discoverPartitions(io.questdb.std.FilesFacade, io.questdb.std.str.StringSink, io.questdb.std.DirectLongList, java.lang.CharSequence, io.questdb.cairo.TableToken, io.questdb.cairo.TxnScoreboard, io.questdb.cairo.TxReader, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.sql.async.PageFrameReduceJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.sql.async.PageFrameReduceJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameReduceJob::consumeQueue(int, io.questdb.mp.RingQueue, io.questdb.mp.MCSequence, io.questdb.cairo.sql.PageAddressCacheRecord, io.questdb.cairo.sql.SqlExecutionCircuitBreaker, io.questdb.cairo.sql.async.PageFrameSequence):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.ApplyWal2TableJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.wal.ApplyWal2TableJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::cleanDroppedTableDirectory(io.questdb.cairo.CairoEngine, io.questdb.std.str.Path, io.questdb.cairo.TableToken):boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::tryDestroyDroppedTable(io.questdb.cairo.TableToken, io.questdb.cairo.TableWriter, io.questdb.cairo.CairoEngine, io.questdb.std.str.Path):boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::applyOutstandingWalTransactions(io.questdb.cairo.TableToken, io.questdb.cairo.TableWriter, io.questdb.cairo.CairoEngine, io.questdb.cairo.wal.OperationCompiler, io.questdb.std.str.Path, io.questdb.mp.Job$RunStatus):boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::processWalSql(io.questdb.cairo.TableWriter, io.questdb.cairo.wal.WalEventCursor$SqlInfo, io.questdb.cairo.wal.OperationCompiler, long):void" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::applyWAL(io.questdb.cairo.TableToken, io.questdb.cairo.CairoEngine, io.questdb.cairo.wal.OperationCompiler, io.questdb.mp.Job$RunStatus):long" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::doRun(int, long, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.WalPurgeJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.wal.WalPurgeJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::broadSweep(int, io.questdb.cairo.TableToken, long):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::deleteFile(io.questdb.std.str.Path):boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::deleteSegmentDirectory(io.questdb.cairo.TableToken, int, int):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::deleteWalDirectory(int):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::mayLogDebugInfo():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::recursiveDelete(io.questdb.std.str.Path):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob::run(int, io.questdb.mp.Job$RunStatus):boolean" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob::onRequest(int, io.questdb.cutlass.line.tcp.LineTcpConnectionContext):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob::close():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob::commitTables():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob::drainQueue():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CopyRequestJob" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.text.CopyRequestJob::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyRequestJob::updateStatus(byte, byte, java.lang.CharSequence, long, long, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.log.LogAlertSocketWriter" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.log.LogAlertSocketWriter::log:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.log.LogAlertSocketWriter::onLogRecord(io.questdb.log.LogRecordSink):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.Bootstrap" />
			<role name="State" element="io.questdb.ServerConfiguration" />
			<role name="state" element="io.questdb.Bootstrap::config:io.questdb.ServerConfiguration" />
			<role name="Request()" element="io.questdb.Bootstrap::reportValidateConfig():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.NowFunctionFactory$Func" />
			<role name="State" element="io.questdb.griffin.SqlExecutionContext" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.NowFunctionFactory$Func::context:io.questdb.griffin.SqlExecutionContext" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.NowFunctionFactory$Func::getTimestamp(io.questdb.cairo.sql.Record):long" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.NowFunctionFactory$Func::init(io.questdb.cairo.sql.SymbolTableSource, io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.SystimestampFunctionFactory$Func" />
			<role name="State" element="io.questdb.griffin.SqlExecutionContext" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.SystimestampFunctionFactory$Func::context:io.questdb.griffin.SqlExecutionContext" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.SystimestampFunctionFactory$Func::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.O3PartitionPurgeJob" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cairo.O3PartitionPurgeJob::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.O3PartitionPurgeJob::discoverPartitions(io.questdb.std.FilesFacade, io.questdb.std.str.StringSink, io.questdb.std.DirectLongList, java.lang.CharSequence, io.questdb.cairo.TableToken, io.questdb.cairo.TxnScoreboard, io.questdb.cairo.TxReader, int):void" />
			<role name="Request()" element="io.questdb.cairo.O3PartitionPurgeJob::doRun(int, long, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.WalPurgeJob" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cairo.wal.WalPurgeJob::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::broadSweep(int, io.questdb.cairo.TableToken, long):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::setSegmentLockPath(io.questdb.cairo.TableToken, int, int):io.questdb.std.str.Path" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::setSegmentPath(io.questdb.cairo.TableToken, int, int):io.questdb.std.str.Path" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::setSegmentPendingPath(io.questdb.cairo.TableToken, int, int):io.questdb.std.str.Path" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::setTablePath(io.questdb.cairo.TableToken):io.questdb.std.str.Path" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::setTxnPath(io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::setWalLockPath(io.questdb.cairo.TableToken, int):io.questdb.std.str.Path" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::setWalPath(io.questdb.cairo.TableToken, int):io.questdb.std.str.Path" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.FunctionParser" />
			<role name="State" element="io.questdb.griffin.SqlExecutionContext" />
			<role name="state" element="io.questdb.griffin.FunctionParser::sqlExecutionContext:io.questdb.griffin.SqlExecutionContext" />
			<role name="Request()" element="io.questdb.griffin.FunctionParser::createCursorFunction(io.questdb.griffin.model.ExpressionNode):io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.FunctionParser::createFunction(io.questdb.griffin.model.ExpressionNode, io.questdb.std.ObjList, io.questdb.std.IntList):io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.FunctionParser::getBindVariableService():io.questdb.cairo.sql.BindVariableService" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.jit.CompiledFilterIRSerializer" />
			<role name="State" element="io.questdb.griffin.SqlExecutionContext" />
			<role name="state" element="io.questdb.jit.CompiledFilterIRSerializer::executionContext:io.questdb.griffin.SqlExecutionContext" />
			<role name="Request()" element="io.questdb.jit.CompiledFilterIRSerializer::getBindVariableService():io.questdb.cairo.sql.BindVariableService" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory::loFunction:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory::hiFunction:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory::initializeLimitedSizeCursor(io.questdb.griffin.SqlExecutionContext, io.questdb.cairo.sql.RecordCursor):void" />
			<role name="Request()" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursorFactory::canBeOptimized(io.questdb.cairo.sql.RecordCursor, io.questdb.griffin.SqlExecutionContext):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursorFactory" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursorFactory::limitLoFunction:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursorFactory::getCursor(io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursorFactory::toPlan(io.questdb.griffin.PlanSink):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.AsyncJitFilteredRecordCursorFactory" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.AsyncJitFilteredRecordCursorFactory::limitLoFunction:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncJitFilteredRecordCursorFactory::getCursor(io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncJitFilteredRecordCursorFactory::toPlan(io.questdb.griffin.PlanSink):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.DeferredSingleSymbolFilterDataFrameRecordCursorFactory" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.DeferredSingleSymbolFilterDataFrameRecordCursorFactory::symbolFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.DeferredSingleSymbolFilterDataFrameRecordCursorFactory::getPageFrameCursor(io.questdb.griffin.SqlExecutionContext, int):io.questdb.cairo.sql.PageFrameCursor" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableWriter" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.TableWriter::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int, int, boolean, boolean, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::attachPartition(long, long):io.questdb.cairo.AttachDetachStatus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::detachPartition(long):io.questdb.cairo.AttachDetachStatus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::attachPartitionCheckFilesMatchFixedColumn(int, long, long, java.lang.String, long, io.questdb.std.str.Path, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::attachPartitionCheckFilesMatchVarLenColumn(long, long, java.lang.String, long, io.questdb.std.str.Path, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::attachPartitionCheckSymbolColumn(long, long, java.lang.String, long, io.questdb.std.str.Path, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::attachPrepare(long, long, io.questdb.std.str.Path, int):boolean" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::copyOverwrite(io.questdb.std.str.Path):int" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::createIndexFiles(java.lang.CharSequence, long, int, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::indexHistoricPartitions(io.questdb.cairo.SymbolColumnIndexer, java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::lock():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3MoveUncommitted0(int, int, long, long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3MoveWalFromFilesToLastPartition(int, int, long, long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::openPartition(long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::openTodoMem():long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::processPartitionRemoveCandidates0(int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::readMinTimestamp(long):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::releaseLock(boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeMetaFile():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeNonAttachedPartitions():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removePartitionDirsNotAttached(long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::rename(int):int" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::repairDataGaps(long):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::repairMetaRename(int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::rowCancel():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.WalWriter" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.wal.WalWriter::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::acquireSegmentLock():int" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::cleanupSymbolMapFiles(io.questdb.std.str.Path, int, java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::closeSegmentSwitchFiles(io.questdb.std.LongList):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::createSegmentDir(int):int" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::lockWal():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::mkWalDir():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::openNewSegment():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::releaseSegmentLock(int, int):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::releaseWalLock():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::renameColumnFiles(int, java.lang.CharSequence, java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::setFixColumnNulls(int, int, long):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::setVarColumnFixedFileNull(int, int, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::setVarColumnVarFileNull(int, int, long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.PageFrameCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor::pageFrameCursor:io.questdb.cairo.sql.PageFrameCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor::buildRosti():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.sql.async.PageFrameReduceJob" />
			<role name="State" element="io.questdb.MessageBus" />
			<role name="state" element="io.questdb.cairo.sql.async.PageFrameReduceJob::messageBus:io.questdb.MessageBus" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameReduceJob::run(int, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.ShowPartitionsRecordCursorFactory" />
			<role name="State" element="io.questdb.griffin.SqlExecutionContext" />
			<role name="state" element="io.questdb.griffin.engine.table.ShowPartitionsRecordCursorFactory::executionContext:io.questdb.griffin.SqlExecutionContext" />
			<role name="Request()" element="io.questdb.griffin.engine.table.ShowPartitionsRecordCursorFactory::getCursor(io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.catalogue.PgAttrDefFunctionFactory$AttrDefCatalogueCursor" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.griffin.engine.functions.catalogue.PgAttrDefFunctionFactory$AttrDefCatalogueCursor::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.PgAttrDefFunctionFactory$AttrDefCatalogueCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.PgAttrDefFunctionFactory$AttrDefCatalogueCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.PgAttrDefFunctionFactory$AttrDefCatalogueCursor::toTop():void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.PgAttrDefFunctionFactory$AttrDefCatalogueCursor::next0():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.catalogue.PgAttributeFunctionFactory$AttributeClassCatalogueCursor" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.griffin.engine.functions.catalogue.PgAttributeFunctionFactory$AttributeClassCatalogueCursor::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.PgAttributeFunctionFactory$AttributeClassCatalogueCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.PgAttributeFunctionFactory$AttributeClassCatalogueCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.PgAttributeFunctionFactory$AttributeClassCatalogueCursor::toTop():void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.PgAttributeFunctionFactory$AttributeClassCatalogueCursor::next0():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.TableStructureAdapter" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::cairoConfiguration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::getColumnName(int):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::getMaxUncommittedRows():int" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::getO3MaxLag():long" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::getSymbolCacheFlag(int):boolean" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::getSymbolCapacity(int):int" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableStructureAdapter::isWalEnabled():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::getIndexBlockCapacity(int):int" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::getMaxUncommittedRows():int" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::getO3MaxLag():long" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::getSymbolCapacity(int):int" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter$TableStructureAdapter::isWalEnabled():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.cairo.TableModel" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.test.cairo.TableModel::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.test.cairo.TableModel::getMaxUncommittedRows():int" />
			<role name="Request()" element="io.questdb.test.cairo.TableModel::getO3MaxLag():long" />
			<role name="Request()" element="io.questdb.test.cairo.TableModel::isWalEnabled():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValueDeferredIndexedRowCursorFactory" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValueDeferredIndexedRowCursorFactory::symbolFunc:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueDeferredIndexedRowCursorFactory::prepareCursor(io.questdb.cairo.TableReader):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="State" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$FieldNameParser" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onFieldName:io.questdb.cutlass.line.udp.LineUdpParserImpl$FieldNameParser" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onEvent(io.questdb.cutlass.line.udp.CachedCharSequence, int, io.questdb.cutlass.line.udp.CharSequenceCache):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="State" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$FieldValueParser" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onTagValue:io.questdb.cutlass.line.udp.LineUdpParserImpl$FieldValueParser" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onFieldValue:io.questdb.cutlass.line.udp.LineUdpParserImpl$FieldValueParser" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onEvent(io.questdb.cutlass.line.udp.CachedCharSequence, int, io.questdb.cutlass.line.udp.CharSequenceCache):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="State" element="io.questdb.cutlass.line.udp.LineUdpParserImpl$LineEndParser" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onLineEnd:io.questdb.cutlass.line.udp.LineUdpParserImpl$LineEndParser" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onLineEnd(io.questdb.cutlass.line.udp.CharSequenceCache):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$StrInCursorFunction" />
			<role name="State" element="io.questdb.cairo.sql.Record$CharSequenceFunction" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$StrInCursorFunction::func:io.questdb.cairo.sql.Record$CharSequenceFunction" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$StrInCursorFunction::buildValueSet():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$SymbolInCursorFunction" />
			<role name="State" element="io.questdb.cairo.sql.Record$CharSequenceFunction" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$SymbolInCursorFunction::func:io.questdb.cairo.sql.Record$CharSequenceFunction" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$SymbolInCursorFunction::buildSymbolKeys():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableWriter" />
			<role name="State" element="io.questdb.std.ReadOnlyObjList" />
			<role name="state" element="io.questdb.cairo.TableWriter::o3Columns:io.questdb.std.ReadOnlyObjList" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3MergeFixColumnLag(int, int, long, long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3MergeVarColumnLag(int, int, long, long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3MoveLag0(int, int, long, long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3MoveWalFromFilesToLastPartition(int, int, long, long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3SortFixColumn(int, int, long, long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3SortVarColumn(int, int, long, long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::processO3Block(long, int, long, long, long, long, boolean, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::remapWalSymbols(io.questdb.cairo.wal.SymbolMapDiffCursor, long, long, io.questdb.std.str.Path, long):io.questdb.std.ReadOnlyObjList" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.sql.async.PageFrameSequence" />
			<role name="State" element="io.questdb.MessageBus" />
			<role name="state" element="io.questdb.cairo.sql.async.PageFrameSequence::messageBus:io.questdb.MessageBus" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::await():void" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::clear():void" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::of(io.questdb.cairo.sql.RecordCursorFactory, io.questdb.griffin.SqlExecutionContext, io.questdb.mp.SCSequence, T, int):io.questdb.cairo.sql.async.PageFrameSequence" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::buildAddressCache():void" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::dispatch():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.PurgingOperator" />
			<role name="State" element="io.questdb.MessageBus" />
			<role name="state" element="io.questdb.griffin.PurgingOperator::messageBus:io.questdb.MessageBus" />
			<role name="Request()" element="io.questdb.griffin.PurgingOperator::purgeColumnVersionAsync(io.questdb.cairo.TableToken, java.lang.CharSequence, int, int, int, int, long, io.questdb.std.LongList):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllFilteredRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllSymbolsFilteredRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursor::findRecord():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValueIndexedFilteredRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValueIndexedFilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueIndexedFilteredRecordCursor::findRecord():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor::findAllWithFilter(int):void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor::findRestrictedExcludedOnlyWithFilter(int):void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor::findRestrictedWithFilter():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValuesFilteredRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValuesFilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValuesFilteredRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValuesIndexedFilteredRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValuesIndexedFilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValuesIndexedFilteredRecordCursor::addFoundKey(int, io.questdb.cairo.BitmapIndexReader, int, long, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.sql.PageAddressCacheRecord" />
			<role name="State" element="io.questdb.cairo.sql.SymbolTableSource" />
			<role name="state" element="io.questdb.cairo.sql.PageAddressCacheRecord::symbolTableSource:io.questdb.cairo.sql.SymbolTableSource" />
			<role name="Request()" element="io.questdb.cairo.sql.PageAddressCacheRecord::getSymbolTable(int):io.questdb.cairo.sql.SymbolTable" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel" />
			<role name="State" element="io.questdb.network.NetworkFacade" />
			<role name="state" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::close():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::errno():int" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::receive(long, int):int" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::send(long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.UdpLineChannel" />
			<role name="State" element="io.questdb.network.NetworkFacade" />
			<role name="state" element="io.questdb.cutlass.line.udp.UdpLineChannel::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.UdpLineChannel::close():void" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.UdpLineChannel::errno():int" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.UdpLineChannel::send(long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.TextLoader" />
			<role name="State" element="io.questdb.cutlass.text.TextConfiguration" />
			<role name="state" element="io.questdb.cutlass.text.TextLoader::textConfiguration:io.questdb.cutlass.text.TextConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.text.TextLoader::configureDestination(java.lang.CharSequence, boolean, int, int, java.lang.CharSequence, java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.griffin.engine.ops.AlterOperation$CharSequenceList" />
			<role name="Context" element="io.questdb.griffin.engine.ops.AlterOperation" />
			<role name="state" element="io.questdb.griffin.engine.ops.AlterOperation::activeExtraStrInfo:io.questdb.griffin.engine.ops.AlterOperation$CharSequenceList" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation::applyAddColumn(io.questdb.cairo.wal.MetadataService):void" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation::applyAddIndex(io.questdb.cairo.wal.MetadataService):void" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation::applyDropColumn(io.questdb.cairo.wal.MetadataService):void" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation::applyDropIndex(io.questdb.cairo.wal.MetadataService):void" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation::applyRenameColumn(io.questdb.cairo.wal.MetadataService):void" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.AlterOperation::applySetSymbolCache(io.questdb.cairo.wal.MetadataService, boolean):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob" />
			<role name="State" element="io.questdb.network.IODispatcher" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob::dispatcher:io.questdb.network.IODispatcher" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob::run(int, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.LineUdpLexer" />
			<role name="State" element="io.questdb.cutlass.line.udp.LineUdpParser" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpLexer::parser:io.questdb.cutlass.line.udp.LineUdpParser" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpLexer::parseLast():void" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpLexer::fireEvent():void" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpLexer::onEol():void" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpLexer::parsePartial(long, long):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.wal.seq.TableSequencerAPI" />
			<role name="state" element="io.questdb.cairo.wal.seq.TableSequencerAPI::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerAPI::deregisterTable(io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerAPI::dropTable(io.questdb.cairo.TableToken, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerAPI::forAllWalTables(io.questdb.std.ObjHashSet, boolean, io.questdb.cairo.wal.seq.TableSequencerAPI$TableSequencerCallback):void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerAPI::renameWalTable(io.questdb.cairo.TableToken, io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerAPI::releaseEntries(long):boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerAPI::throwIfClosed():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.griffin.UpdateOperatorImpl" />
			<role name="state" element="io.questdb.griffin.UpdateOperatorImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.UpdateOperatorImpl::executeUpdate(io.questdb.griffin.SqlExecutionContext, io.questdb.griffin.engine.ops.UpdateOperation):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.bind.BinBindVariable" />
			<role name="State" element="io.questdb.std.BinarySequence" />
			<role name="state" element="io.questdb.griffin.engine.functions.bind.BinBindVariable::value:io.questdb.std.BinarySequence" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bind.BinBindVariable::getBinLen(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableWriter" />
			<role name="State" element="io.questdb.MessageBus" />
			<role name="state" element="io.questdb.cairo.TableWriter::messageBus:io.questdb.MessageBus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::dispatchO3CallbackQueue(io.questdb.mp.RingQueue, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3CommitPartitionAsync(java.util.concurrent.atomic.AtomicInteger, long, long, long, long, long, long, long, long, boolean, long, long, io.questdb.cairo.O3Basket, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3ConsumePartitionUpdates():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3CopySafe(long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3MergeIntoLag(long, long, long, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3ScheduleMoveUncommitted0(int, long, long):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3ShiftLagRowsUp(int, long, long, long, boolean, io.questdb.cairo.TableWriter$O3ColumnUpdateMethod):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3Sort(long, int, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::publishTableWriterEvent(int, long, long, int, java.lang.CharSequence, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::updateIndexesParallel(long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::getO3CopyPubSeq():io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::getO3CopyQueue():io.questdb.mp.RingQueue" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::getO3OpenColumnPubSeq():io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::getO3OpenColumnQueue():io.questdb.mp.RingQueue" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.TableNameRegistry" />
			<role name="Context" element="io.questdb.cairo.CairoEngine" />
			<role name="state" element="io.questdb.cairo.CairoEngine::tableNameRegistry:io.questdb.cairo.TableNameRegistry" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::closeNameRegistry():void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::createTable(io.questdb.cairo.SecurityContext, io.questdb.cairo.vm.api.MemoryMARW, io.questdb.std.str.Path, boolean, io.questdb.cairo.TableStructure, boolean):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::createTableInVolume(io.questdb.cairo.SecurityContext, io.questdb.cairo.vm.api.MemoryMARW, io.questdb.std.str.Path, boolean, io.questdb.cairo.TableStructure, boolean):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::drop(io.questdb.std.str.Path, io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getTableStatus(io.questdb.std.str.Path, io.questdb.cairo.TableToken):int" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getTableTokenByDirName(java.lang.String, int):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getTableTokenCount(boolean):int" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getTableTokenIfExists(java.lang.CharSequence):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getTableTokenIfExists(java.lang.CharSequence, int, int):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getTableTokens(io.questdb.std.ObjHashSet, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getUpdatedTableToken(io.questdb.cairo.TableToken):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::isTableDropped(io.questdb.cairo.TableToken):boolean" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::lockTableName(java.lang.CharSequence, int, boolean):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::registerTableToken(io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::reloadTableNames(io.questdb.std.ObjList):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::removeTableToken(io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::rename(io.questdb.cairo.SecurityContext, io.questdb.std.str.Path, io.questdb.cairo.vm.api.MemoryMARW, java.lang.CharSequence, io.questdb.std.str.Path, java.lang.CharSequence):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::resetNameRegistryMemory():void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::unlockTableName(io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::verifyTableName(java.lang.CharSequence):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::verifyTableToken(io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::rename0(io.questdb.std.str.Path, io.questdb.cairo.TableToken, java.lang.CharSequence, io.questdb.std.str.Path, java.lang.CharSequence):io.questdb.cairo.TableToken" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cutlass.http.HttpContextConfiguration" />
			<role name="Context" element="io.questdb.cutlass.http.HttpConnectionContext" />
			<role name="state" element="io.questdb.cutlass.http.HttpConnectionContext::configuration:io.questdb.cutlass.http.HttpContextConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::handleClientOperation(int, io.questdb.cutlass.http.HttpRequestProcessorSelector, io.questdb.cutlass.http.RescheduleContext):boolean" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::busyRcvLoop(io.questdb.cutlass.http.HttpRequestProcessorSelector, io.questdb.cutlass.http.RescheduleContext):void" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::configureSecurityContext():void" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::handleClientRecv(io.questdb.cutlass.http.HttpRequestProcessorSelector, io.questdb.cutlass.http.RescheduleContext):boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.griffin.engine.functions.test.TestDataUnavailableFunctionFactory$DataUnavailableRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.functions.test.TestDataUnavailableFunctionFactory$DataUnavailableRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.test.TestDataUnavailableFunctionFactory$DataUnavailableRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.CountRecordCursorFactory$CountRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.CountRecordCursorFactory$CountRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.CountRecordCursorFactory$CountRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.GroupByNotKeyedRecordCursorFactory$GroupByNotKeyedRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.GroupByNotKeyedRecordCursorFactory$GroupByNotKeyedRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.GroupByNotKeyedRecordCursorFactory$GroupByNotKeyedRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.GroupByNotKeyedVectorRecordCursorFactory$GroupByNotKeyedVectorRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.GroupByNotKeyedVectorRecordCursorFactory$GroupByNotKeyedVectorRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.GroupByNotKeyedVectorRecordCursorFactory$GroupByNotKeyedVectorRecordCursor::buildFunctions():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashJoinLightRecordCursorFactory$HashJoinRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashJoinLightRecordCursorFactory$HashJoinRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashJoinLightRecordCursorFactory$HashJoinRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashJoinRecordCursorFactory$HashJoinRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashJoinRecordCursorFactory$HashJoinRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashJoinRecordCursorFactory$HashJoinRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredLightRecordCursorFactory$HashOuterJoinLightRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredLightRecordCursorFactory$HashOuterJoinLightRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredLightRecordCursorFactory$HashOuterJoinLightRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredRecordCursorFactory$HashOuterJoinRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredRecordCursorFactory$HashOuterJoinRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinFilteredRecordCursorFactory$HashOuterJoinRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashOuterJoinLightRecordCursorFactory$HashOuterJoinLightRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashOuterJoinLightRecordCursorFactory$HashOuterJoinLightRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinLightRecordCursorFactory$HashOuterJoinLightRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.griffin.engine.join.HashOuterJoinRecordCursorFactory$HashOuterJoinRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.join.HashOuterJoinRecordCursorFactory$HashOuterJoinRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.join.HashOuterJoinRecordCursorFactory$HashOuterJoinRecordCursor::buildMapOfSlaveRecords():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::buildMap():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor::buildRecordChain():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.orderby.SortedRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.orderby.SortedRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.orderby.SortedRecordCursor::buildChain():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.orderby.LimitedSizeSortedLightRecordCursor::buildChain():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.orderby.SortedLightRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.orderby.SortedLightRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.orderby.SortedLightRecordCursor::buildChain():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::buildMapForOrderedSubQuery():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::buildMapForUnorderedSubQuery():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.GroupByRecordCursorFactory$GroupByRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.groupby.GroupByRecordCursorFactory$GroupByRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.GroupByRecordCursorFactory$GroupByRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::buildMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::fillGaps(long, long):void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::fillMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByInterpolateRecordCursorFactory$SampleByInterpolateRecordCursor::initMap():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor::buildRosti():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.table.LatestBySubQueryRecordCursorFactory$DataFrameRecordCursorWrapper" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestBySubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::baseCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestBySubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::buildSymbolKeys():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper" />
			<role name="state" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::delegate:io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::getSymbolTable(int):io.questdb.cairo.sql.StaticSymbolTable" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::of(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilterOnSubQueryRecordCursorFactory$DataFrameRecordCursorWrapper::buildFactories():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.ops.UpdateOperation" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.ops.UpdateOperation::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.UpdateOperation::forceTestTimeout():void" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.UpdateOperation::testTimeout():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.join.NestedLoopLeftJoinRecordCursorFactory$NestedLoopLeftRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.join.NestedLoopLeftJoinRecordCursorFactory$NestedLoopLeftRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.join.NestedLoopLeftJoinRecordCursorFactory$NestedLoopLeftRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::append(long, io.questdb.cairo.frm.FrameColumn, long, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::appendNulls(long, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::close():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::append(long, io.questdb.cairo.frm.FrameColumn, long, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::appendNulls(long, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::close():void" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::readVarOffset(int, long):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.vm.MemoryPMARImpl" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.vm.MemoryPMARImpl::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryPMARImpl::mapPage(int):long" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryPMARImpl::sync(boolean):void" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryPMARImpl::truncate():void" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryPMARImpl::release(long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByAllIndexedRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByAllIndexedRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllIndexedRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueFilteredRecordCursor::findRecord():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValueIndexedFilteredRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValueIndexedFilteredRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueIndexedFilteredRecordCursor::findRecord():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor::findAllNoFilter(int):void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor::findAllWithFilter(int):void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor::findRestrictedExcludedOnlyNoFilter(int):void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor::findRestrictedExcludedOnlyWithFilter(int):void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor::findRestrictedNoFilter():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueListRecordCursor::findRestrictedWithFilter():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValueRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValueRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValueRecordCursor::findRecord():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValuesIndexedFilteredRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValuesIndexedFilteredRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValuesIndexedFilteredRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByValuesIndexedRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByValuesIndexedRecordCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByValuesIndexedRecordCursor::buildTreeMap():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CsvFileIndexer" />
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.cutlass.text.CsvFileIndexer::partitionDirFormatMethod:io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::getPartitionIndexDir(long):io.questdb.std.str.Path" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.types.DateAdapter" />
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.cutlass.text.types.DateAdapter::format:io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.cutlass.text.types.DateAdapter::probe(io.questdb.std.str.DirectByteCharSequence):boolean" />
			<role name="Request()" element="io.questdb.cutlass.text.types.DateAdapter::parseLong(io.questdb.std.str.DirectByteCharSequence):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.types.DateUtf8Adapter" />
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.cutlass.text.types.DateUtf8Adapter::format:io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.cutlass.text.types.DateUtf8Adapter::probe(io.questdb.std.str.DirectByteCharSequence):boolean" />
			<role name="Request()" element="io.questdb.cutlass.text.types.DateUtf8Adapter::write(io.questdb.cairo.TableWriter$Row, int, io.questdb.std.str.DirectByteCharSequence, io.questdb.std.str.DirectCharSink):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.types.TimestampAdapter" />
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.cutlass.text.types.TimestampAdapter::format:io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.cutlass.text.types.TimestampAdapter::getTimestamp(io.questdb.std.str.DirectByteCharSequence):long" />
			<role name="Request()" element="io.questdb.cutlass.text.types.TimestampAdapter::probe(io.questdb.std.str.DirectByteCharSequence):boolean" />
			<role name="Request()" element="io.questdb.cutlass.text.types.TimestampAdapter::write(io.questdb.cairo.TableWriter$Row, int, io.questdb.std.str.DirectByteCharSequence):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.columns.SymbolColumn" />
			<role name="State" element="io.questdb.cairo.sql.SymbolTableSource" />
			<role name="state" element="io.questdb.griffin.engine.functions.columns.SymbolColumn::symbolTableSource:io.questdb.cairo.sql.SymbolTableSource" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.columns.SymbolColumn::init(io.questdb.cairo.sql.SymbolTableSource, io.questdb.griffin.SqlExecutionContext):void" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.columns.SymbolColumn::newSymbolTable():io.questdb.cairo.sql.SymbolTable" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.MapSymbolColumn" />
			<role name="State" element="io.questdb.cairo.sql.SymbolTableSource" />
			<role name="state" element="io.questdb.griffin.engine.groupby.MapSymbolColumn::symbolTableSource:io.questdb.cairo.sql.SymbolTableSource" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.MapSymbolColumn::init(io.questdb.cairo.sql.SymbolTableSource, io.questdb.griffin.SqlExecutionContext):void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.MapSymbolColumn::newSymbolTable():io.questdb.cairo.sql.SymbolTable" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.JsonQueryProcessor" />
			<role name="State" element="io.questdb.cutlass.http.processors.JsonQueryProcessorConfiguration" />
			<role name="state" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::configuration:io.questdb.cutlass.http.processors.JsonQueryProcessorConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::execute0(io.questdb.cutlass.http.processors.JsonQueryProcessorState):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::failRequest(io.questdb.cutlass.http.HttpConnectionContext, io.questdb.cutlass.http.HttpException):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::onRequestComplete(io.questdb.cutlass.http.HttpConnectionContext):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::compileQuery(io.questdb.cutlass.http.processors.JsonQueryProcessorState):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::internalError(io.questdb.cutlass.http.HttpChunkedResponseSocket, long, java.lang.CharSequence, java.lang.Throwable, io.questdb.cutlass.http.processors.JsonQueryProcessorState, io.questdb.Metrics):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::parseUrl(io.questdb.cutlass.http.processors.JsonQueryProcessorState, java.lang.CharSequence):boolean" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::retryQueryExecution(io.questdb.cutlass.http.processors.JsonQueryProcessorState, io.questdb.cairo.sql.OperationFuture):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.TextQueryProcessor" />
			<role name="State" element="io.questdb.cutlass.http.processors.JsonQueryProcessorConfiguration" />
			<role name="state" element="io.questdb.cutlass.http.processors.TextQueryProcessor::configuration:io.questdb.cutlass.http.processors.JsonQueryProcessorConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessor::parseUrl(io.questdb.cutlass.http.HttpChunkedResponseSocket, io.questdb.cutlass.http.HttpRequestHeader, io.questdb.cutlass.http.processors.TextQueryProcessorState):boolean" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessor::header(io.questdb.cutlass.http.HttpChunkedResponseSocket, io.questdb.cutlass.http.processors.TextQueryProcessorState, int):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessor::headerJsonError(io.questdb.cutlass.http.HttpChunkedResponseSocket):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessor::headerNoContentDisposition(io.questdb.cutlass.http.HttpChunkedResponseSocket):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.network.Epoll" />
			<role name="State" element="io.questdb.network.EpollFacade" />
			<role name="state" element="io.questdb.network.Epoll::epf:io.questdb.network.EpollFacade" />
			<role name="Request()" element="io.questdb.network.Epoll::close():void" />
			<role name="Request()" element="io.questdb.network.Epoll::control(int, long, int, int):int" />
			<role name="Request()" element="io.questdb.network.Epoll::listen(int):void" />
			<role name="Request()" element="io.questdb.network.Epoll::poll():int" />
			<role name="Request()" element="io.questdb.network.Epoll::removeListen(int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.Telemetry" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.Telemetry::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.Telemetry::close():void" />
			<role name="Request()" element="io.questdb.Telemetry::consume(T):void" />
			<role name="Request()" element="io.questdb.Telemetry::init(io.questdb.cairo.CairoEngine, io.questdb.griffin.SqlCompiler, io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementEvent" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementEvent::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementEvent::append():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.ColumnPurgeOperator" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.cairo.ColumnPurgeOperator::microClock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeOperator::purge(io.questdb.tasks.ColumnPurgeTask):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory$ListBasedSymbolIndexRowCursor" />
			<role name="State" element="io.questdb.cairo.sql.DataFrame" />
			<role name="state" element="io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory$ListBasedSymbolIndexRowCursor::dataFrame:io.questdb.cairo.sql.DataFrame" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SortedSymbolIndexRowCursorFactory$ListBasedSymbolIndexRowCursor::fetchNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler" />
			<role name="State" element="io.questdb.cutlass.line.tcp.LineTcpReceiverConfiguration" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::configuration:io.questdb.cutlass.line.tcp.LineTcpReceiverConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::appendToWal(io.questdb.cairo.SecurityContext, io.questdb.cutlass.line.tcp.NetworkIOJob, io.questdb.cutlass.line.tcp.LineTcpParser, io.questdb.cutlass.line.tcp.TableUpdateDetails):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.tasks.LatestByTask" />
			<role name="State" element="io.questdb.mp.CountDownLatchSPI" />
			<role name="state" element="io.questdb.tasks.LatestByTask::doneLatch:io.questdb.mp.CountDownLatchSPI" />
			<role name="Request()" element="io.questdb.tasks.LatestByTask::run():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$RankFunction" />
			<role name="State" element="io.questdb.griffin.engine.RecordComparator" />
			<role name="state" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$RankFunction::recordComparator:io.questdb.griffin.engine.RecordComparator" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$RankFunction::pass1(io.questdb.cairo.sql.Record, long, io.questdb.cairo.sql.AnalyticSPI):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.orderby.RecordTreeChain" />
			<role name="State" element="io.questdb.griffin.engine.RecordComparator" />
			<role name="state" element="io.questdb.griffin.engine.orderby.RecordTreeChain::comparator:io.questdb.griffin.engine.RecordComparator" />
			<role name="Request()" element="io.questdb.griffin.engine.orderby.RecordTreeChain::put(io.questdb.cairo.sql.Record):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$OrderRankFunction" />
			<role name="State" element="io.questdb.griffin.engine.RecordComparator" />
			<role name="state" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$OrderRankFunction::recordComparator:io.questdb.griffin.engine.RecordComparator" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.analytic.RankFunctionFactory$OrderRankFunction::pass1(io.questdb.cairo.sql.Record, long, io.questdb.cairo.sql.AnalyticSPI):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.QueryCache" />
			<role name="State" element="io.questdb.cutlass.http.HttpServerConfiguration" />
			<role name="state" element="io.questdb.cutlass.http.processors.QueryCache::httpServerConfiguration:io.questdb.cutlass.http.HttpServerConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.QueryCache::getThreadLocalInstance():io.questdb.cutlass.http.processors.QueryCache" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler" />
			<role name="State" element="io.questdb.cutlass.line.tcp.NetworkIOJob" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::netIoJobs:io.questdb.cutlass.line.tcp.NetworkIOJob[]" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::getTableUpdateDetailsFromSharedArea(io.questdb.cairo.SecurityContext, io.questdb.cutlass.line.tcp.NetworkIOJob, io.questdb.cutlass.line.tcp.LineTcpConnectionContext, io.questdb.cutlass.line.tcp.LineTcpParser):io.questdb.cutlass.line.tcp.TableUpdateDetails" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.types.OtherToTimestampAdapter" />
			<role name="State" element="io.questdb.cutlass.text.types.TimestampCompatibleAdapter" />
			<role name="state" element="io.questdb.cutlass.text.types.OtherToTimestampAdapter::compatibleAdapter:io.questdb.cutlass.text.types.TimestampCompatibleAdapter" />
			<role name="Request()" element="io.questdb.cutlass.text.types.OtherToTimestampAdapter::getTimestamp(io.questdb.std.str.DirectByteCharSequence):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableWriterMetrics" />
			<role name="State" element="io.questdb.metrics.Counter" />
			<role name="state" element="io.questdb.cairo.TableWriterMetrics::committedRowCounter:io.questdb.metrics.Counter" />
			<role name="state" element="io.questdb.cairo.TableWriterMetrics::physicallyWrittenRowCounter:io.questdb.metrics.Counter" />
			<role name="state" element="io.questdb.cairo.TableWriterMetrics::commitCounter:io.questdb.metrics.Counter" />
			<role name="state" element="io.questdb.cairo.TableWriterMetrics::o3CommitCounter:io.questdb.metrics.Counter" />
			<role name="state" element="io.questdb.cairo.TableWriterMetrics::rollbackCounter:io.questdb.metrics.Counter" />
			<role name="Request()" element="io.questdb.cairo.TableWriterMetrics::addCommittedRows(long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriterMetrics::addPhysicallyWrittenRows(long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriterMetrics::getCommitCount():long" />
			<role name="Request()" element="io.questdb.cairo.TableWriterMetrics::getCommittedRows():long" />
			<role name="Request()" element="io.questdb.cairo.TableWriterMetrics::getO3CommitCount():long" />
			<role name="Request()" element="io.questdb.cairo.TableWriterMetrics::getPhysicallyWrittenRows():long" />
			<role name="Request()" element="io.questdb.cairo.TableWriterMetrics::getRollbackCount():long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.WalMetrics" />
			<role name="State" element="io.questdb.metrics.Counter" />
			<role name="state" element="io.questdb.cairo.wal.WalMetrics::applyRowsWrittenCounter:io.questdb.metrics.Counter" />
			<role name="state" element="io.questdb.cairo.wal.WalMetrics::applyPhysicallyWrittenRowsCounter:io.questdb.metrics.Counter" />
			<role name="state" element="io.questdb.cairo.wal.WalMetrics::rowsWrittenCounter:io.questdb.metrics.Counter" />
			<role name="Request()" element="io.questdb.cairo.wal.WalMetrics::addApplyRowsWritten(long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalMetrics::addRowsWritten(long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.JsonQueryMetrics" />
			<role name="State" element="io.questdb.metrics.Counter" />
			<role name="state" element="io.questdb.cutlass.http.processors.JsonQueryMetrics::completedQueriesCounter:io.questdb.metrics.Counter" />
			<role name="state" element="io.questdb.cutlass.http.processors.JsonQueryMetrics::startedQueriesCounter:io.questdb.metrics.Counter" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryMetrics::completedQueriesCount():long" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryMetrics::startedQueriesCount():long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.WalMetrics" />
			<role name="State" element="io.questdb.metrics.LongGauge" />
			<role name="state" element="io.questdb.cairo.wal.WalMetrics::applyRowsWriteRateGauge:io.questdb.metrics.LongGauge" />
			<role name="Request()" element="io.questdb.cairo.wal.WalMetrics::addApplyRowsWritten(long, long, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.metrics.VirtualLongGauge" />
			<role name="State" element="io.questdb.metrics.VirtualLongGauge$StatProvider" />
			<role name="state" element="io.questdb.metrics.VirtualLongGauge::provider:io.questdb.metrics.VirtualLongGauge$StatProvider" />
			<role name="Request()" element="io.questdb.metrics.VirtualLongGauge::getValue():long" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cutlass.line.tcp.LineTcpReceiverConfiguration" />
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::configuration:io.questdb.cutlass.line.tcp.LineTcpReceiverConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::handleIO(io.questdb.cutlass.line.tcp.NetworkIOJob):io.questdb.cutlass.line.tcp.LineTcpConnectionContext$IOContextResult" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::of(int, io.questdb.network.IODispatcher):io.questdb.cutlass.line.tcp.LineTcpConnectionContext" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.cutlass.line.interop.TestInterop$JsonTestSuiteParser" />
			<role name="State" element="io.questdb.client.Sender" />
			<role name="state" element="io.questdb.test.cutlass.line.interop.TestInterop$JsonTestSuiteParser::sender:io.questdb.client.Sender" />
			<role name="Request()" element="io.questdb.test.cutlass.line.interop.TestInterop$JsonTestSuiteParser::onEvent(int, java.lang.CharSequence, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.JsonQueryProcessor" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::execute0(io.questdb.cutlass.http.processors.JsonQueryProcessorState):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::doResumeSend(io.questdb.cutlass.http.processors.JsonQueryProcessorState, io.questdb.cutlass.http.HttpConnectionContext, io.questdb.griffin.SqlExecutionContext):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::readyForNextRequest(io.questdb.cutlass.http.HttpConnectionContext):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::compileQuery(io.questdb.cutlass.http.processors.JsonQueryProcessorState):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.StaticContentProcessor" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.http.processors.StaticContentProcessor::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.StaticContentProcessor::logInfoWithFd(io.questdb.cutlass.http.HttpConnectionContext):io.questdb.log.LogRecord" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.StaticContentProcessor::resumeSend(io.questdb.cutlass.http.HttpConnectionContext):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.StaticContentProcessor::send(io.questdb.cutlass.http.HttpConnectionContext, io.questdb.std.str.LPSZ, boolean):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.StaticContentProcessor::sendRange(io.questdb.cutlass.http.HttpConnectionContext, java.lang.CharSequence, io.questdb.std.str.LPSZ, java.lang.CharSequence, boolean):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.StaticContentProcessor::sendVanilla(io.questdb.cutlass.http.HttpConnectionContext, io.questdb.std.str.LPSZ, java.lang.CharSequence, boolean):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.TextImportProcessor" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.http.processors.TextImportProcessor::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextImportProcessor::onPartBegin(io.questdb.cutlass.http.HttpRequestHeader):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextImportProcessor::onPartEnd():void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextImportProcessor::resumeRecv(io.questdb.cutlass.http.HttpConnectionContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.TextQueryProcessor" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.http.processors.TextQueryProcessor::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessor::readyForNextRequest(io.questdb.cutlass.http.HttpConnectionContext):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessor::critical(io.questdb.cutlass.http.processors.TextQueryProcessorState):io.questdb.log.LogRecord" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessor::doResumeSend(io.questdb.cutlass.http.HttpConnectionContext):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessor::error(io.questdb.cutlass.http.processors.TextQueryProcessorState):io.questdb.log.LogRecord" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessor::info(io.questdb.cutlass.http.processors.TextQueryProcessorState):io.questdb.log.LogRecord" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.seq.TableSequencerAPI" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cairo.wal.seq.TableSequencerAPI::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerAPI::forAllWalTables(io.questdb.std.ObjHashSet, boolean, io.questdb.cairo.wal.seq.TableSequencerAPI$TableSequencerCallback):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.pgwire.PGConnectionContext" />
			<role name="State" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="state" element="io.questdb.cutlass.pgwire.PGConnectionContext::currentCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::resumeCursorExecute(boolean):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::resumeCursorQuery0(boolean):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::sendCursor(int, io.questdb.cutlass.pgwire.PGConnectionContext$PGResumeProcessor, io.questdb.cutlass.pgwire.PGConnectionContext$PGResumeProcessor):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::sendCursor0(io.questdb.cairo.sql.Record, int, io.questdb.cutlass.pgwire.PGConnectionContext$PGResumeProcessor):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableWriter" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.TableWriter::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addColumn(java.lang.CharSequence, int, int, boolean, boolean, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::addIndex(java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::apply(io.questdb.griffin.engine.ops.AbstractOperation, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::attachPartition(long, long):io.questdb.cairo.AttachDetachStatus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::checkScoreboardHasReadersBeforeLastCommittedTxn():boolean" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::closeActivePartition(boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::commitWalTransaction(io.questdb.std.str.Path, boolean, long, long, long, long, io.questdb.cairo.wal.SymbolMapDiffCursor, long):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::destroy():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::detachPartition(long):io.questdb.cairo.AttachDetachStatus" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::dropIndex(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::processCommandQueue(io.questdb.tasks.TableWriterTask, io.questdb.mp.Sequence, long, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::processWalBlock(io.questdb.std.str.Path, int, boolean, long, long, long, long, io.questdb.cairo.wal.SymbolMapDiffCursor, long):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeAllPartitions():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeColumn(java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::renameColumn(java.lang.CharSequence, java.lang.CharSequence):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::rollback():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::linkFile(io.questdb.std.FilesFacade, io.questdb.std.str.LPSZ, io.questdb.std.str.LPSZ):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeFileAndOrLog(io.questdb.std.FilesFacade, io.questdb.std.str.LPSZ):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::applyFromWalLagToLastPartition(long):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::attachPartitionCheckFilesMatchFixedColumn(int, long, long, java.lang.String, long, io.questdb.std.str.Path, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::attachPartitionCheckFilesMatchVarLenColumn(long, long, java.lang.String, long, io.questdb.std.str.Path, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::attachPrepare(long, long, io.questdb.std.str.Path, int):boolean" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::commit(long):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::createIndexFiles(java.lang.CharSequence, long, int, int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::doClose(boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::dropPartitionByExactTimestamp(long):boolean" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::finishO3Append(long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::finishO3Commit(long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::handleWorkStealingException(java.lang.String, int, int, long, long, long, long, java.lang.Throwable):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::indexHistoricPartitions(io.questdb.cairo.SymbolColumnIndexer, java.lang.CharSequence, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::newRowO3(long):io.questdb.cairo.TableWriter$Row" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3Commit(long):boolean" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3CopySafe(long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3MoveUncommitted(int):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3MoveUncommitted0(int, int, long, long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3OpenColumnSafe(io.questdb.mp.Sequence, long, io.questdb.tasks.O3OpenColumnTask):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3OpenColumns():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3PartitionUpdate(long, long, long, long, boolean, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3ProcessPartitionSafe(io.questdb.mp.Sequence, long, io.questdb.tasks.O3PartitionTask):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::openNewColumnFiles(java.lang.CharSequence, int, boolean, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::openPartition(long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::processAsyncWriterCommand(io.questdb.cairo.sql.AsyncWriterCommand, io.questdb.tasks.TableWriterTask, long, io.questdb.mp.Sequence, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::processO3Block(long, int, long, long, long, long, boolean, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::processPartitionRemoveCandidates0(int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::publishTableWriterEvent(int, long, long, int, java.lang.CharSequence, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeColumnFilesInPartition(java.lang.CharSequence, int, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeMetaFile():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removeNonAttachedPartitions():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removePartitionDirsNotAttached(long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::rename(int):int" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::repairDataGaps(long):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::repairMetaRename(int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::repairTruncate():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::rollbackIndexes():void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::runFragile(io.questdb.cairo.TableWriter$FragileCode, java.lang.CharSequence, io.questdb.cairo.CairoException):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::squashSplitPartitions(int, int, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::throwDistressException(io.questdb.cairo.CairoException):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::truncate(boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::updateIndexesParallel(long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::updateIndexesSerially(long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::indexAndCountDown(io.questdb.cairo.ColumnIndexer, long, long, io.questdb.mp.SOCountDownLatch):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.WalWriter" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.wal.WalWriter::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::commit():long" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::doClose(boolean):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::goActive(long):boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::rollUncommittedToNewSegment():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::applyStructural(io.questdb.griffin.engine.ops.AlterOperation):long" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::configureSymbolMapWriter(int, java.lang.CharSequence, int, long):void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::openNewSegment():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::releaseSegmentLock(int, int):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.CairoEngine" />
			<role name="state" element="io.questdb.cairo.CairoEngine::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::createTable(io.questdb.cairo.SecurityContext, io.questdb.cairo.vm.api.MemoryMARW, io.questdb.std.str.Path, boolean, io.questdb.cairo.TableStructure, boolean):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::createTableInVolume(io.questdb.cairo.SecurityContext, io.questdb.cairo.vm.api.MemoryMARW, io.questdb.std.str.Path, boolean, io.questdb.cairo.TableStructure, boolean):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::drop(io.questdb.std.str.Path, io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getReaderWithRepair(io.questdb.cairo.TableToken):io.questdb.cairo.TableReader" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::lock(io.questdb.cairo.TableToken, java.lang.String):java.lang.String" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::notifyWalTxnCommitted(io.questdb.cairo.TableToken, long):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::rename(io.questdb.cairo.SecurityContext, io.questdb.std.str.Path, io.questdb.cairo.vm.api.MemoryMARW, java.lang.CharSequence, io.questdb.std.str.Path, java.lang.CharSequence):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::unlock(io.questdb.cairo.SecurityContext, io.questdb.cairo.TableToken, io.questdb.cairo.TableWriter, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::rename0(io.questdb.std.str.Path, io.questdb.cairo.TableToken, java.lang.CharSequence, io.questdb.std.str.Path, java.lang.CharSequence):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::tryRepairTable(io.questdb.cairo.TableToken, java.lang.RuntimeException):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor" />
			<role name="State" element="io.questdb.cairo.map.MapRecord" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::mapRecord:io.questdb.cairo.map.MapRecord" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByLightRecordCursorFactory$LatestByLightRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.DataFrameRecordCursorImpl" />
			<role name="State" element="io.questdb.cairo.sql.RowCursor" />
			<role name="state" element="io.questdb.griffin.engine.table.DataFrameRecordCursorImpl::rowCursor:io.questdb.cairo.sql.RowCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.DataFrameRecordCursorImpl::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.PageFrameCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor::pageFrameCursor:io.questdb.cairo.sql.PageFrameCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor::toTop():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor::getNextState(int):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.GroupByNotKeyedVectorRecordCursorFactory$GroupByNotKeyedVectorRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.PageFrameCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.GroupByNotKeyedVectorRecordCursorFactory$GroupByNotKeyedVectorRecordCursor::pageFrameCursor:io.questdb.cairo.sql.PageFrameCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.GroupByNotKeyedVectorRecordCursorFactory$GroupByNotKeyedVectorRecordCursor::buildFunctions():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.vm.MemorySRImpl" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.vm.MemorySRImpl::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.vm.MemorySRImpl::mapPage(int):long" />
			<role name="Request()" element="io.questdb.cairo.vm.MemorySRImpl::releaseCurrentPage():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.network.Kqueue" />
			<role name="State" element="io.questdb.network.KqueueFacade" />
			<role name="state" element="io.questdb.network.Kqueue::kqf:io.questdb.network.KqueueFacade" />
			<role name="Request()" element="io.questdb.network.Kqueue::close():void" />
			<role name="Request()" element="io.questdb.network.Kqueue::poll():int" />
			<role name="Request()" element="io.questdb.network.Kqueue::register(int):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.std.IOURingImpl" />
			<role name="State" element="io.questdb.std.IOURingFacade" />
			<role name="state" element="io.questdb.std.IOURingImpl::facade:io.questdb.std.IOURingFacade" />
			<role name="Request()" element="io.questdb.std.IOURingImpl::close():void" />
			<role name="Request()" element="io.questdb.std.IOURingImpl::submit():int" />
			<role name="Request()" element="io.questdb.std.IOURingImpl::submitAndWait():int" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cutlass.auth.Authenticator" />
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::authenticator:io.questdb.cutlass.auth.Authenticator" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::handleIO(io.questdb.cutlass.line.tcp.NetworkIOJob):io.questdb.cutlass.line.tcp.LineTcpConnectionContext$IOContextResult" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::of(int, io.questdb.network.IODispatcher):io.questdb.cutlass.line.tcp.LineTcpConnectionContext" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.pgwire.PGConnectionContext" />
			<role name="State" element="io.questdb.cutlass.pgwire.PgWireAuthenticator" />
			<role name="state" element="io.questdb.cutlass.pgwire.PGConnectionContext::authenticator:io.questdb.cutlass.pgwire.PgWireAuthenticator" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::onAfterAuthSuccess():void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::parse(long, int, io.questdb.griffin.SqlCompiler):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.AbstractTest" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.test.AbstractTest::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.test.AbstractTest::setUpStatic():void" />
			<role name="Request()" element="io.questdb.test.AbstractTest::setUp():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverTest" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverTest::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverTest::sendToSocket(io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverTest$Socket, java.lang.String):void" />
			<role name="Request()" element="io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverTest::sendToSocket(java.lang.String):void" />
			<role name="Request()" element="io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverTest::lambda$runInContext$2(boolean, io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverTest$LineTcpServerAwareContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.pool.WriterPool" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.pool.WriterPool::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::countFreeWriters():int" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::lock(io.questdb.cairo.TableToken, java.lang.String):java.lang.String" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::unlock(io.questdb.cairo.TableToken, io.questdb.cairo.TableWriter, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::checkClosed():void" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::checkClosedAndGetWriter(io.questdb.cairo.TableToken, io.questdb.cairo.pool.WriterPool$Entry, java.lang.String):io.questdb.cairo.TableWriter" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::closeWriter(long, io.questdb.cairo.pool.WriterPool$Entry, short, int):void" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::createWriter(io.questdb.cairo.TableToken, io.questdb.cairo.pool.WriterPool$Entry, long, java.lang.String):io.questdb.cairo.TableWriter" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::getWriterEntry(io.questdb.cairo.TableToken, java.lang.String, io.questdb.cairo.sql.AsyncWriterCommand):io.questdb.cairo.TableWriter" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::lockAndNotify(long, io.questdb.cairo.pool.WriterPool$Entry, io.questdb.cairo.TableToken, java.lang.String):boolean" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::logAndReturn(io.questdb.cairo.pool.WriterPool$Entry, short):io.questdb.cairo.TableWriter" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::returnToPool(io.questdb.cairo.pool.WriterPool$Entry):boolean" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::closePool():void" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::releaseAll(long):boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Context" element="io.questdb.cairo.CairoEngine" />
			<role name="state" element="io.questdb.cairo.CairoEngine::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::createTable(io.questdb.cairo.SecurityContext, io.questdb.cairo.vm.api.MemoryMARW, io.questdb.std.str.Path, boolean, io.questdb.cairo.TableStructure, boolean):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::createTableInVolume(io.questdb.cairo.SecurityContext, io.questdb.cairo.vm.api.MemoryMARW, io.questdb.std.str.Path, boolean, io.questdb.cairo.TableStructure, boolean):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::drop(io.questdb.std.str.Path, io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getTableStatus(io.questdb.std.str.Path, io.questdb.cairo.TableToken):int" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::getTableStatus(java.lang.CharSequence):int" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::lockTableName(java.lang.CharSequence, int, boolean):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::removeDirectory(io.questdb.std.str.Path, java.lang.CharSequence):int" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::rename(io.questdb.cairo.SecurityContext, io.questdb.std.str.Path, io.questdb.cairo.vm.api.MemoryMARW, java.lang.CharSequence, io.questdb.std.str.Path, java.lang.CharSequence):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::createTableInVolumeUnsafe(io.questdb.cairo.vm.api.MemoryMARW, io.questdb.std.str.Path, io.questdb.cairo.TableStructure, io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::createTableUnsafe(io.questdb.cairo.vm.api.MemoryMARW, io.questdb.std.str.Path, io.questdb.cairo.TableStructure, io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::rename0(io.questdb.std.str.Path, io.questdb.cairo.TableToken, java.lang.CharSequence, io.questdb.std.str.Path, java.lang.CharSequence):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine::validNameOrThrow(java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.PageFrame" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor::currentFrame:io.questdb.cairo.sql.PageFrame" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor::getNextState(int):int" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor::saveLastValuesToBuffer():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor::saveRowIdValueToCrossRow(long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::loFunction:io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::hiFunction:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.LimitRecordCursorFactory$LimitRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.FilteredRecordCursor" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.FilteredRecordCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FilteredRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.CairoEngine$EngineMaintenanceJob" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.cairo.CairoEngine$EngineMaintenanceJob::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cairo.CairoEngine$EngineMaintenanceJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.ColumnPurgeJob" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.cairo.ColumnPurgeJob::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeJob::processInQueue():boolean" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeJob::processTableRecords(io.questdb.cairo.CairoEngine):void" />
			<role name="Request()" element="io.questdb.cairo.ColumnPurgeJob::purge():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.ApplyWal2TableJob" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.cairo.wal.ApplyWal2TableJob::microClock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::applyOutstandingWalTransactions(io.questdb.cairo.TableToken, io.questdb.cairo.TableWriter, io.questdb.cairo.CairoEngine, io.questdb.cairo.wal.OperationCompiler, io.questdb.std.str.Path, io.questdb.mp.Job$RunStatus):boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.ApplyWal2TableJob::processWalCommit(io.questdb.cairo.TableWriter, int, io.questdb.std.str.Path, long, io.questdb.cairo.wal.OperationCompiler, long, long):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.WalPurgeJob" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.cairo.wal.WalPurgeJob::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::delayByHalfInterval():void" />
			<role name="Request()" element="io.questdb.cairo.wal.WalPurgeJob::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.CopyRequestJob" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.cutlass.text.CopyRequestJob::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cutlass.text.CopyRequestJob::updateStatus(byte, byte, java.lang.CharSequence, long, long, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.log.LogAlertSocketWriter" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.log.LogAlertSocketWriter::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.log.LogAlertSocketWriter::onLogRecord(io.questdb.log.LogRecordSink):void" />
			<role name="Request()" element="io.questdb.log.LogAlertSocketWriter::loadLogAlertTemplate():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.log.LogRollingFileWriter" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.log.LogRollingFileWriter::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::bindProperties(io.questdb.log.LogFactory):void" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::flush():void" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::getNextDayDeadline():long" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::getNextHourDeadline():long" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::getNextMinuteDeadline():long" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::getNextMonthDeadline():long" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::getNextYearDeadline():long" />
			<role name="Request()" element="io.questdb.log.LogRollingFileWriter::removeExpiredLogs(long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.pgwire.PGConnectionContext" />
			<role name="State" element="io.questdb.network.NetworkFacade" />
			<role name="state" element="io.questdb.cutlass.pgwire.PGConnectionContext::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::doSendWithRetries(int, int):void" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::doReceive(int):int" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::doSend(int, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.HttpConnectionContext" />
			<role name="State" element="io.questdb.network.NetworkFacade" />
			<role name="state" element="io.questdb.cutlass.http.HttpConnectionContext::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::continueConsumeMultipart(int, long, long, int, io.questdb.cutlass.http.HttpMultipartContentListener, io.questdb.cutlass.http.HttpRequestProcessor, io.questdb.cutlass.http.RescheduleContext):boolean" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpConnectionContext::handleClientRecv(io.questdb.cutlass.http.HttpRequestProcessorSelector, io.questdb.cutlass.http.RescheduleContext):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext" />
			<role name="State" element="io.questdb.network.NetworkFacade" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::read():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.HttpResponseSink" />
			<role name="State" element="io.questdb.network.NetworkFacade" />
			<role name="state" element="io.questdb.cutlass.http.HttpResponseSink::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpResponseSink::sendBuffer(io.questdb.cutlass.http.HttpResponseSink$ChunkBuffer):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.ObjectFactory" />
			<role name="Context" element="io.questdb.std.ObjectPool" />
			<role name="state" element="io.questdb.std.ObjectPool::factory:io.questdb.std.ObjectFactory" />
			<role name="Request()" element="io.questdb.std.ObjectPool::fill():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::milliClock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::handleIO(io.questdb.cutlass.line.tcp.NetworkIOJob):io.questdb.cutlass.line.tcp.LineTcpConnectionContext$IOContextResult" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpConnectionContext::checkQueueFullLogHysteresis():boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Context" element="io.questdb.cutlass.http.HttpResponseSink$HttpResponseHeaderImpl" />
			<role name="state" element="io.questdb.cutlass.http.HttpResponseSink$HttpResponseHeaderImpl::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cutlass.http.HttpResponseSink$HttpResponseHeaderImpl::status(java.lang.CharSequence, int, java.lang.CharSequence, long):java.lang.String" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Context" element="io.questdb.cairo.DynamicTableReaderMetadata" />
			<role name="state" element="io.questdb.cairo.DynamicTableReaderMetadata::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cairo.DynamicTableReaderMetadata::readTxnSlow(long):void" />
			<role name="Request()" element="io.questdb.cairo.DynamicTableReaderMetadata::reloadMetadata(long, long):boolean" />
			<role name="Request()" element="io.questdb.cairo.DynamicTableReaderMetadata::reloadSlow():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.frm.file.PartitionFrame" />
			<role name="State" element="io.questdb.cairo.frm.file.RecycleBin" />
			<role name="state" element="io.questdb.cairo.frm.file.PartitionFrame::frameRecycleBin:io.questdb.cairo.frm.file.RecycleBin" />
			<role name="Request()" element="io.questdb.cairo.frm.file.PartitionFrame::close():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor" />
			<role name="State" element="io.questdb.cairo.RecordSink" />
			<role name="state" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::recordSink:io.questdb.cairo.RecordSink" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctRecordCursorFactory$DistinctRecordCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor" />
			<role name="State" element="io.questdb.cairo.RecordSink" />
			<role name="state" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::recordSink:io.questdb.cairo.RecordSink" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctTimeSeriesRecordCursorFactory$DistinctTimeSeriesRecordCursor::checkIfNotDupe():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.RecordChain" />
			<role name="State" element="io.questdb.cairo.RecordSink" />
			<role name="state" element="io.questdb.cairo.RecordChain::recordSink:io.questdb.cairo.RecordSink" />
			<role name="Request()" element="io.questdb.cairo.RecordChain::put(io.questdb.cairo.sql.Record, long):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.table.TouchTableFunctionFactory$TouchTableFunc" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.griffin.engine.functions.table.TouchTableFunctionFactory$TouchTableFunc::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.table.TouchTableFunctionFactory$TouchTableFunc::touchTable():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker" />
			<role name="State" element="io.questdb.cairo.sql.SqlExecutionCircuitBreakerConfiguration" />
			<role name="state" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker::configuration:io.questdb.cairo.sql.SqlExecutionCircuitBreakerConfiguration" />
			<role name="Request()" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker::testConnection(int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableReader" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cairo.TableReader::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.TableReader::readTxnSlow(long):void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::reloadMetadata(int, long, boolean):boolean" />
			<role name="Request()" element="io.questdb.cairo.TableReader::reloadSlow(boolean):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="State" element="io.questdb.cutlass.line.udp.LineUdpReceiverConfiguration" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::udpConfiguration:io.questdb.cutlass.line.udp.LineUdpReceiverConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::parseFieldNameNewTable(io.questdb.cutlass.line.udp.CachedCharSequence):void" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::parseValue(io.questdb.cutlass.line.udp.CachedCharSequence, int, io.questdb.cutlass.line.udp.CharSequenceCache, boolean):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.WaitProcessor" />
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="state" element="io.questdb.cutlass.http.WaitProcessor::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cutlass.http.WaitProcessor::reschedule(io.questdb.cutlass.http.Retry, int, long):void" />
			<role name="Request()" element="io.questdb.cutlass.http.WaitProcessor::sendToOutQueue():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob" />
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob::millisecondClock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob::run(int, io.questdb.mp.Job$RunStatus):boolean" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpNetworkIOJob::onRequest(int, io.questdb.cutlass.line.tcp.LineTcpConnectionContext):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob" />
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob::millisecondClock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob::commitTables():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpWriterJob::drainQueue():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.StaticContentProcessor" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cutlass.http.processors.StaticContentProcessor::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.StaticContentProcessor::onRequestComplete(io.questdb.cutlass.http.HttpConnectionContext):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.StaticContentProcessor::resumeSend(io.questdb.cutlass.http.HttpConnectionContext):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.StaticContentProcessor::send(io.questdb.cutlass.http.HttpConnectionContext, io.questdb.std.str.LPSZ, boolean):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.StaticContentProcessor::sendRange(io.questdb.cutlass.http.HttpConnectionContext, java.lang.CharSequence, io.questdb.std.str.LPSZ, java.lang.CharSequence, boolean):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.StaticContentProcessor::sendVanilla(io.questdb.cutlass.http.HttpConnectionContext, io.questdb.std.str.LPSZ, java.lang.CharSequence, boolean):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor" />
			<role name="State" element="io.questdb.cairo.sql.DataFrameCursor" />
			<role name="state" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::dataFrameCursor:io.questdb.cairo.sql.DataFrameCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::next():io.questdb.cairo.sql.PageFrame" />
			<role name="Request()" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::of(io.questdb.cairo.sql.DataFrameCursor):io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.BwdTableReaderPageFrameCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor" />
			<role name="State" element="io.questdb.cairo.sql.DataFrameCursor" />
			<role name="state" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::dataFrameCursor:io.questdb.cairo.sql.DataFrameCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::next():io.questdb.cairo.sql.PageFrame" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::of(io.questdb.cairo.sql.DataFrameCursor):io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.table.FwdTableReaderPageFrameCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.std.WeakSelfReturningObjectPool" />
			<role name="State" element="io.questdb.std.SelfReturningObjectFactory" />
			<role name="state" element="io.questdb.std.WeakSelfReturningObjectPool::factory:io.questdb.std.SelfReturningObjectFactory" />
			<role name="Request()" element="io.questdb.std.WeakSelfReturningObjectPool::newInstance():io.questdb.std.AbstractSelfReturningObject" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$SymbolInCursorFunction" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$SymbolInCursorFunction::cursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$SymbolInCursorFunction::buildSymbolKeys():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="Context" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$StrInCursorFunction" />
			<role name="state" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$StrInCursorFunction::cursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.bool.InSymbolCursorFunctionFactory$StrInCursorFunction::buildValueSet():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredNegativeLimitRecordCursor::fetchAllFrames():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::close():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.AsyncFilteredRecordCursor::fetchNextFrame():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory" />
			<role name="State" element="io.questdb.cairo.sql.SingleSymbolFilter" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory::symbolFilter:io.questdb.cairo.sql.SingleSymbolFilter" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory::getCursor(io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.frm.file.PartitionFrame" />
			<role name="State" element="io.questdb.cairo.sql.RecordMetadata" />
			<role name="state" element="io.questdb.cairo.frm.file.PartitionFrame::metadata:io.questdb.cairo.sql.RecordMetadata" />
			<role name="Request()" element="io.questdb.cairo.frm.file.PartitionFrame::columnCount():int" />
			<role name="Request()" element="io.questdb.cairo.frm.file.PartitionFrame::createColumn(int):io.questdb.cairo.frm.FrameColumn" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.PrometheusMetricsProcessor" />
			<role name="State" element="io.questdb.metrics.Scrapable" />
			<role name="state" element="io.questdb.cutlass.http.processors.PrometheusMetricsProcessor::metrics:io.questdb.metrics.Scrapable" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.PrometheusMetricsProcessor::onRequestComplete(io.questdb.cutlass.http.HttpConnectionContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.network.EventFdSuspendEvent" />
			<role name="State" element="io.questdb.network.EpollFacade" />
			<role name="state" element="io.questdb.network.EventFdSuspendEvent::epf:io.questdb.network.EpollFacade" />
			<role name="Request()" element="io.questdb.network.EventFdSuspendEvent::_close():void" />
			<role name="Request()" element="io.questdb.network.EventFdSuspendEvent::checkTriggered():boolean" />
			<role name="Request()" element="io.questdb.network.EventFdSuspendEvent::trigger():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.ops.OperationFutureImpl" />
			<role name="State" element="io.questdb.cairo.sql.AsyncWriterCommand" />
			<role name="state" element="io.questdb.griffin.engine.ops.OperationFutureImpl::asyncWriterCommand:io.questdb.cairo.sql.AsyncWriterCommand" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.OperationFutureImpl::of(io.questdb.cairo.sql.AsyncWriterCommand, io.questdb.griffin.SqlExecutionContext, io.questdb.mp.SCSequence, int, boolean):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl::close():void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl::hasNext():boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl::setPosition():boolean" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl::of(io.questdb.std.FilesFacade, long, io.questdb.std.str.Path):io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TransactionLogCursorImpl::remap(long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.text.ParallelCsvFileImporter" />
			<role name="State" element="io.questdb.mp.Sequence" />
			<role name="state" element="io.questdb.cutlass.text.ParallelCsvFileImporter::pubSeq:io.questdb.mp.Sequence" />
			<role name="state" element="io.questdb.cutlass.text.ParallelCsvFileImporter::collectSeq:io.questdb.mp.Sequence" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::phaseBoundaryCheck(long):io.questdb.std.LongList" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::phaseIndexing():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::collect(int, java.util.function.Consumer):int" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::phaseBuildSymbolIndex():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::phasePartitionImport():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::phaseSymbolTableMerge():void" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::phaseUpdateSymbolKeys():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.std.Unsafe" />
			<role name="State" element="io.questdb.std.Unsafe$AnonymousClassDefiner" />
			<role name="state" element="io.questdb.std.Unsafe::anonymousClassDefiner:io.questdb.std.Unsafe$AnonymousClassDefiner" />
			<role name="Request()" element="io.questdb.std.Unsafe::defineAnonymousClass(java.lang.Class, byte[]):java.lang.Class" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToDateFunctionFactory$ToDateFunction" />
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToDateFunctionFactory$ToDateFunction::dateFormat:io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToDateFunctionFactory$ToDateFunction::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToStrDateFunctionFactory$ToCharDateVCFFunc" />
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToStrDateFunctionFactory$ToCharDateVCFFunc::format:io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToStrDateFunctionFactory$ToCharDateVCFFunc::toSink(long, io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToStrTimestampFunctionFactory$ToCharDateFFunc" />
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToStrTimestampFunctionFactory$ToCharDateFFunc::format:io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToStrTimestampFunctionFactory$ToCharDateFFunc::toSink(long, io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.ToTimestampVCFunctionFactory$Func" />
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.ToTimestampVCFunctionFactory$Func::timestampFormat:io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.ToTimestampVCFunctionFactory$Func::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.sql.async.PageFrameSequence" />
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="state" element="io.questdb.cairo.sql.async.PageFrameSequence::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cairo.sql.async.PageFrameSequence::of(io.questdb.cairo.sql.RecordCursorFactory, io.questdb.griffin.SqlExecutionContext, io.questdb.mp.SCSequence, T, int):io.questdb.cairo.sql.async.PageFrameSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.TableUpdateDetails" />
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="state" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::millisecondClock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::commitIfIntervalElapsed(long):long" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::commitIfMaxUncommittedRowsCountReached():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.TableUpdateDetails::getThreadLocalDetails(int):io.questdb.cutlass.line.tcp.TableUpdateDetails$ThreadLocalDetails" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.TelemetryConfigLogger" />
			<role name="State" element="io.questdb.TelemetryConfiguration" />
			<role name="state" element="io.questdb.TelemetryConfigLogger::telemetryConfiguration:io.questdb.TelemetryConfiguration" />
			<role name="Request()" element="io.questdb.TelemetryConfigLogger::updateTelemetryConfig(io.questdb.griffin.SqlCompiler, io.questdb.griffin.SqlExecutionContextImpl, io.questdb.cairo.TableToken):io.questdb.cairo.TableWriter" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.map.FastMapRecord" />
			<role name="State" element="io.questdb.cairo.ColumnTypes" />
			<role name="state" element="io.questdb.cairo.map.FastMapRecord::keyTypes:io.questdb.cairo.ColumnTypes" />
			<role name="Request()" element="io.questdb.cairo.map.FastMapRecord::addressOfKeyColumn(int):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableWriter" />
			<role name="State" element="io.questdb.cairo.vm.api.MemoryMAT" />
			<role name="state" element="io.questdb.cairo.TableWriter::o3TimestampMem:io.questdb.cairo.vm.api.MemoryMAT" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::processWalBlock(io.questdb.std.str.Path, int, boolean, long, long, long, long, io.questdb.cairo.wal.SymbolMapDiffCursor, long):long" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3Commit(long):boolean" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3MoveLag0(int, int, long, long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::o3SetAppendOffset(int, int, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn" />
			<role name="State" element="io.questdb.cairo.frm.file.RecycleBin" />
			<role name="state" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::recycleBin:io.questdb.cairo.frm.file.RecycleBin" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileFixFrameColumn::close():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn" />
			<role name="State" element="io.questdb.cairo.frm.file.RecycleBin" />
			<role name="state" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::recycleBin:io.questdb.cairo.frm.file.RecycleBin" />
			<role name="Request()" element="io.questdb.cairo.frm.file.ContiguousFileVarFrameColumn::close():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.ExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.cutlass.text.SerialCsvFileImporter" />
			<role name="state" element="io.questdb.cutlass.text.SerialCsvFileImporter::circuitBreaker:io.questdb.cairo.sql.ExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.cutlass.text.SerialCsvFileImporter::process(io.questdb.cairo.SecurityContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.DeferredSymbolIndexFilteredRowCursorFactory" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.DeferredSymbolIndexFilteredRowCursorFactory::symbolFunction:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.DeferredSymbolIndexFilteredRowCursorFactory::prepareCursor(io.questdb.cairo.TableReader):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.DeferredSymbolIndexRowCursorFactory" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.DeferredSymbolIndexRowCursorFactory::symbol:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.DeferredSymbolIndexRowCursorFactory::prepareCursor(io.questdb.cairo.TableReader):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor" />
			<role name="State" element="io.questdb.cairo.RecordSink" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor::keyMapSink:io.questdb.cairo.RecordSink" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor::buildMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillNoneRecordCursor::updateValueWhenClockMovesBack(io.questdb.cairo.map.MapValue):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByFillPrevRecordCursor" />
			<role name="State" element="io.questdb.cairo.RecordSink" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByFillPrevRecordCursor::keyMapSink:io.questdb.cairo.RecordSink" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillPrevRecordCursor::buildMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillPrevRecordCursor::initializeMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillPrevRecordCursor::updateValueWhenClockMovesBack(io.questdb.cairo.map.MapValue):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByFillValueRecordCursor" />
			<role name="State" element="io.questdb.cairo.RecordSink" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByFillValueRecordCursor::keyMapSink:io.questdb.cairo.RecordSink" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillValueRecordCursor::buildMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillValueRecordCursor::initMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFillValueRecordCursor::updateValueWhenClockMovesBack(io.questdb.cairo.map.MapValue):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor" />
			<role name="State" element="io.questdb.cairo.RecordSink" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::recordSink:io.questdb.cairo.RecordSink" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByRecordCursorFactory$LatestByRecordCursor::buildMap():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.ExplainPlanFactory$ExplainPlanRecordCursor" />
			<role name="State" element="io.questdb.griffin.PlanSink" />
			<role name="state" element="io.questdb.griffin.engine.ExplainPlanFactory$ExplainPlanRecordCursor::planSink:io.questdb.griffin.PlanSink" />
			<role name="Request()" element="io.questdb.griffin.engine.ExplainPlanFactory$ExplainPlanRecordCursor::of(io.questdb.cairo.sql.RecordCursorFactory, io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory" />
			<role name="State" element="io.questdb.std.RostiAllocFacade" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory::raf:io.questdb.std.RostiAllocFacade" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory::getCursor(io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory::resetRostiMemorySize():void" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory::_close():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.SymbolMapReaderImpl$SymbolTableView" />
			<role name="State" element="io.questdb.cairo.sql.RowCursor" />
			<role name="state" element="io.questdb.cairo.SymbolMapReaderImpl$SymbolTableView::rowCursor:io.questdb.cairo.sql.RowCursor" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapReaderImpl$SymbolTableView::keyOf(java.lang.CharSequence):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableReader" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.TableReader::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.TableReader::close():void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::reconcileOpenPartitionsFrom(int, boolean):void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::checkSchedulePurgeO3Partitions():void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::closeDeletedPartition(int):void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::closePartition(int):void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::closeRewrittenPartitionFiles(int, int):long" />
			<role name="Request()" element="io.questdb.cairo.TableReader::createNewColumnList(int, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::insertPartition(int, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::openPartition0(int):long" />
			<role name="Request()" element="io.questdb.cairo.TableReader::readTxnSlow(long):void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::reconcileOpenPartitions(long, long, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::reloadColumnAt(int, io.questdb.std.str.Path, io.questdb.std.ObjList, io.questdb.std.LongList, io.questdb.std.ObjList, int, int, long):void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::reloadMetadata(int, long, boolean):boolean" />
			<role name="Request()" element="io.questdb.cairo.TableReader::reshuffleColumns(int, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.DataFrameRecordCursorImpl" />
			<role name="State" element="io.questdb.cairo.sql.RowCursorFactory" />
			<role name="state" element="io.questdb.griffin.engine.table.DataFrameRecordCursorImpl::rowCursorFactory:io.questdb.cairo.sql.RowCursorFactory" />
			<role name="Request()" element="io.questdb.griffin.engine.table.DataFrameRecordCursorImpl::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.table.DataFrameRecordCursorImpl::skipTo(long):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.network.PipeSuspendEvent" />
			<role name="State" element="io.questdb.network.KqueueFacade" />
			<role name="state" element="io.questdb.network.PipeSuspendEvent::kqf:io.questdb.network.KqueueFacade" />
			<role name="Request()" element="io.questdb.network.PipeSuspendEvent::_close():void" />
			<role name="Request()" element="io.questdb.network.PipeSuspendEvent::checkTriggered():boolean" />
			<role name="Request()" element="io.questdb.network.PipeSuspendEvent::trigger():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl::close():void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl::of(io.questdb.std.FilesFacade, io.questdb.cairo.TableToken, long, io.questdb.cairo.MemorySerializer, io.questdb.std.str.Path):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.pool.WriterPool" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.cairo.pool.WriterPool::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::lock(io.questdb.cairo.TableToken, java.lang.String):java.lang.String" />
			<role name="Request()" element="io.questdb.cairo.pool.WriterPool::getWriterEntry(io.questdb.cairo.TableToken, java.lang.String, io.questdb.cairo.sql.AsyncWriterCommand):io.questdb.cairo.TableWriter" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.GroupByNotKeyedVectorRecordCursorFactory$GroupByNotKeyedVectorRecordCursor" />
			<role name="State" element="io.questdb.MessageBus" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.GroupByNotKeyedVectorRecordCursorFactory$GroupByNotKeyedVectorRecordCursor::bus:io.questdb.MessageBus" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.GroupByNotKeyedVectorRecordCursorFactory$GroupByNotKeyedVectorRecordCursor::buildFunctions():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.ops.OperationFutureImpl" />
			<role name="State" element="io.questdb.griffin.QueryFutureUpdateListener" />
			<role name="state" element="io.questdb.griffin.engine.ops.OperationFutureImpl::queryFutureUpdateListener:io.questdb.griffin.QueryFutureUpdateListener" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.OperationFutureImpl::awaitWriterEvent(long):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor" />
			<role name="State" element="io.questdb.MessageBus" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor::bus:io.questdb.MessageBus" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory$RostiRecordCursor::buildRosti():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter" />
			<role name="State" element="io.questdb.cairo.sql.RecordMetadata" />
			<role name="state" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::metadata:io.questdb.cairo.sql.RecordMetadata" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getColumnType(int):int" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getSymbolCacheFlag(int):boolean" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getSymbolCapacity(int):int" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::of(io.questdb.griffin.model.CreateTableModel, io.questdb.cairo.sql.RecordMetadata, io.questdb.std.IntIntHashMap):io.questdb.griffin.SqlCompiler$TableStructureAdapter" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="State" element="io.questdb.cairo.sql.RecordMetadata" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::metadata:io.questdb.cairo.sql.RecordMetadata" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::parseFieldName(io.questdb.cutlass.line.udp.CachedCharSequence):void" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::parseValue(io.questdb.cutlass.line.udp.CachedCharSequence, int, io.questdb.cutlass.line.udp.CharSequenceCache, boolean):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.vm.MemoryPARWImpl" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.vm.MemoryPARWImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryPARWImpl::allocateNextPage(int):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.vm.MemoryPMARImpl" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.vm.MemoryPMARImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryPMARImpl::of(io.questdb.std.FilesFacade, io.questdb.std.str.LPSZ, long, long, int, long, int):void" />
			<role name="Request()" element="io.questdb.cairo.vm.MemoryPMARImpl::truncate():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.vm.MemorySRImpl" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.vm.MemorySRImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.vm.MemorySRImpl::of(io.questdb.cairo.vm.api.MemoryMA, int):void" />
			<role name="Request()" element="io.questdb.cairo.vm.MemorySRImpl::closeFile():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.seq.TableSequencerImpl" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.wal.seq.TableSequencerImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextStructureTxn(long, io.questdb.cairo.wal.seq.TableMetadataChange):long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextTxn(long, int, int, int):long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::open():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.DelegatingTlsChannel" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.line.tcp.DelegatingTlsChannel::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.DelegatingTlsChannel::close0(boolean):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.PlainTcpLineChannel::configureBuffers(io.questdb.network.NetworkFacade, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.UdpLineChannel" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.line.udp.UdpLineChannel::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.UdpLineChannel::close():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler" />
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::cairoConfiguration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::appendToWal(io.questdb.cairo.SecurityContext, io.questdb.cutlass.line.tcp.NetworkIOJob, io.questdb.cutlass.line.tcp.LineTcpParser, io.questdb.cutlass.line.tcp.TableUpdateDetails):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::doMaintenance(io.questdb.std.ByteCharSequenceObjHashMap, int, long):boolean" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::processWriterReleaseEvent(io.questdb.cutlass.line.tcp.LineTcpMeasurementEvent, int):void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::scheduleEvent(io.questdb.cairo.SecurityContext, io.questdb.cutlass.line.tcp.NetworkIOJob, io.questdb.cutlass.line.tcp.LineTcpConnectionContext, io.questdb.cutlass.line.tcp.LineTcpParser):boolean" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::handleAppendException(io.questdb.std.str.DirectByteCharSequence, io.questdb.cutlass.line.tcp.TableUpdateDetails, java.lang.Throwable):void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::appendToWal(io.questdb.cairo.SecurityContext, io.questdb.cutlass.line.tcp.NetworkIOJob, io.questdb.cutlass.line.tcp.LineTcpParser, io.questdb.cutlass.line.tcp.TableUpdateDetails):void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::getTableUpdateDetailsFromSharedArea(io.questdb.cairo.SecurityContext, io.questdb.cutlass.line.tcp.NetworkIOJob, io.questdb.cutlass.line.tcp.LineTcpConnectionContext, io.questdb.cutlass.line.tcp.LineTcpParser):io.questdb.cutlass.line.tcp.TableUpdateDetails" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::unsafeAssignTableToWriterThread(int, java.lang.CharSequence, io.questdb.std.str.ByteCharSequence):io.questdb.cutlass.line.tcp.TableUpdateDetails" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.LineTcpMeasurementScheduler::unsafeCalcThreadLoad():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.LatestByAllIndexedRecordCursor" />
			<role name="State" element="io.questdb.MessageBus" />
			<role name="state" element="io.questdb.griffin.engine.table.LatestByAllIndexedRecordCursor::bus:io.questdb.MessageBus" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllIndexedRecordCursor::buildTreeMap():void" />
			<role name="Request()" element="io.questdb.griffin.engine.table.LatestByAllIndexedRecordCursor::processTasks(int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.std.TestFilesFacadeImpl" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.test.std.TestFilesFacadeImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.test.std.TestFilesFacadeImpl::remove(io.questdb.std.str.LPSZ):boolean" />
			<role name="Request()" element="io.questdb.test.std.TestFilesFacadeImpl::checkRemove(io.questdb.std.str.LPSZ):boolean" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.security.SecurityContextFactory" />
			<role name="Context" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator" />
			<role name="state" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator::securityContextFactory:io.questdb.cairo.security.SecurityContextFactory" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator::processMessage(java.lang.CharSequence, long, long):io.questdb.cutlass.pgwire.PgWireAuthenticator$AuthenticationResult" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.sql.ExecutionCircuitBreaker" />
			<role name="Context" element="io.questdb.cutlass.text.CsvFileIndexer" />
			<role name="state" element="io.questdb.cutlass.text.CsvFileIndexer::circuitBreaker:io.questdb.cairo.sql.ExecutionCircuitBreaker" />
			<role name="Request()" element="io.questdb.cutlass.text.CsvFileIndexer::index(long, long, long, io.questdb.std.LongList, long, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.std.AssociativeCache" />
			<role name="State" element="io.questdb.metrics.LongGauge" />
			<role name="state" element="io.questdb.std.AssociativeCache::cachedGauge:io.questdb.metrics.LongGauge" />
			<role name="Request()" element="io.questdb.std.AssociativeCache::clear():void" />
			<role name="Request()" element="io.questdb.std.AssociativeCache::poll(java.lang.CharSequence):java.lang.Object" />
			<role name="Request()" element="io.questdb.std.AssociativeCache::put(java.lang.CharSequence, V):java.lang.CharSequence" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.std.ThreadLocal" />
			<role name="State" element="io.questdb.std.ObjectFactory" />
			<role name="state" element="io.questdb.std.ThreadLocal::factory:io.questdb.std.ObjectFactory" />
			<role name="Request()" element="io.questdb.std.ThreadLocal::get():java.lang.Object" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.Bootstrap" />
			<role name="State" element="io.questdb.BuildInformation" />
			<role name="state" element="io.questdb.Bootstrap::buildInformation:io.questdb.BuildInformation" />
			<role name="Request()" element="io.questdb.Bootstrap::extractSite():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.PropServerConfiguration" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.PropServerConfiguration::log:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.PropServerConfiguration::pathEquals(java.lang.String, java.lang.String):boolean" />
			<role name="Request()" element="io.questdb.PropServerConfiguration::validateProperties(java.util.Properties, boolean):void" />
			<role name="Request()" element="io.questdb.PropServerConfiguration::overrideWithEnv(java.util.Properties, java.util.Map, io.questdb.ConfigProperty):java.lang.String" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.LifecycleManager" />
			<role name="Context" element="io.questdb.cairo.TableWriter" />
			<role name="state" element="io.questdb.cairo.TableWriter::lifecycleManager:io.questdb.cairo.LifecycleManager" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::close():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.SymbolMapWriter" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.SymbolMapWriter::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::close():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.frm.file.PartitionFrame" />
			<role name="State" element="io.questdb.cairo.frm.FrameColumnPool" />
			<role name="state" element="io.questdb.cairo.frm.file.PartitionFrame::columnPool:io.questdb.cairo.frm.FrameColumnPool" />
			<role name="Request()" element="io.questdb.cairo.frm.file.PartitionFrame::createColumn(int):io.questdb.cairo.frm.FrameColumn" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.ops.OperationFutureImpl" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.griffin.engine.ops.OperationFutureImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.OperationFutureImpl::of(io.questdb.cairo.sql.AsyncWriterCommand, io.questdb.griffin.SqlExecutionContext, io.questdb.mp.SCSequence, int, boolean):void" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.OperationFutureImpl::awaitWriterEvent(long):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.ops.CopyFactory" />
			<role name="State" element="io.questdb.MessageBus" />
			<role name="state" element="io.questdb.griffin.engine.ops.CopyFactory::messageBus:io.questdb.MessageBus" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.CopyFactory::getCursor(io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory::resetRostiMemorySize():void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.log.Log" />
			<role name="Context" element="io.questdb.cairo.SymbolMapReaderImpl" />
			<role name="state" element="io.questdb.cairo.SymbolMapReaderImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapReaderImpl::close():void" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapReaderImpl::of(io.questdb.cairo.CairoConfiguration, io.questdb.std.str.Path, java.lang.CharSequence, long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.cairo.map.CompactMapTest$MockHash" />
			<role name="State" element="io.questdb.cairo.vm.api.MemoryR" />
			<role name="state" element="io.questdb.test.cairo.map.CompactMapTest$MockHash::mem:io.questdb.cairo.vm.api.MemoryR" />
			<role name="Request()" element="io.questdb.test.cairo.map.CompactMapTest$MockHash::hash(long, long):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.cairo.map.CompactMapTest$MockHash2" />
			<role name="State" element="io.questdb.cairo.vm.api.MemoryR" />
			<role name="state" element="io.questdb.test.cairo.map.CompactMapTest$MockHash2::mem:io.questdb.cairo.vm.api.MemoryR" />
			<role name="Request()" element="io.questdb.test.cairo.map.CompactMapTest$MockHash2::hash(long, long):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.seq.TableSequencerImpl" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.cairo.wal.seq.TableSequencerImpl::microClock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::dropTable():void" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextStructureTxn(long, io.questdb.cairo.wal.seq.TableMetadataChange):long" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableSequencerImpl::nextTxn(int, int, int):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::onLineEnd(io.questdb.cutlass.line.udp.CharSequenceCache):void" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::cacheWriter(io.questdb.cutlass.line.udp.LineUdpParserImpl$CacheEntry, io.questdb.cutlass.line.udp.CachedCharSequence, io.questdb.cairo.TableToken):void" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::createNewRow(io.questdb.cutlass.line.udp.CharSequenceCache, int):io.questdb.cairo.TableWriter$Row" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::parseFieldNameNewTable(io.questdb.cutlass.line.udp.CachedCharSequence):void" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::parseValue(io.questdb.cutlass.line.udp.CachedCharSequence, int, io.questdb.cutlass.line.udp.CharSequenceCache, boolean):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator" />
			<role name="State" element="io.questdb.cutlass.pgwire.PgWireUserDatabase" />
			<role name="state" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator::userDatabase:io.questdb.cutlass.pgwire.PgWireUserDatabase" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.ClearTextPgWireAuthenticator::processMessage(java.lang.CharSequence, long, long):io.questdb.cutlass.pgwire.PgWireAuthenticator$AuthenticationResult" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.tasks.TelemetryTask" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.tasks.TelemetryTask::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.tasks.TelemetryTask::writeTo(io.questdb.cairo.TableWriter, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.tasks.TelemetryWalTask" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.tasks.TelemetryWalTask::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.tasks.TelemetryWalTask::writeTo(io.questdb.cairo.TableWriter, long):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.mp.Worker" />
			<role name="State" element="io.questdb.metrics.HealthMetrics" />
			<role name="state" element="io.questdb.mp.Worker::metrics:io.questdb.metrics.HealthMetrics" />
			<role name="Request()" element="io.questdb.mp.Worker::onError(int, java.lang.Throwable):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.metrics.HealthMetricsImpl" />
			<role name="State" element="io.questdb.metrics.Counter" />
			<role name="state" element="io.questdb.metrics.HealthMetricsImpl::unhandledErrorCounter:io.questdb.metrics.Counter" />
			<role name="Request()" element="io.questdb.metrics.HealthMetricsImpl::unhandledErrorsCount():long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator" />
			<role name="State" element="io.questdb.network.NetworkFacade" />
			<role name="state" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::findLineEnd():int" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::sendChallenge():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.std.WeakClosableObjectPool" />
			<role name="State" element="io.questdb.std.ObjectFactory" />
			<role name="state" element="io.questdb.std.WeakClosableObjectPool::factory:io.questdb.std.ObjectFactory" />
			<role name="Request()" element="io.questdb.std.WeakClosableObjectPool::newInstance():java.io.Closeable" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.std.WeakMutableObjectPool" />
			<role name="State" element="io.questdb.std.ObjectFactory" />
			<role name="state" element="io.questdb.std.WeakMutableObjectPool::factory:io.questdb.std.ObjectFactory" />
			<role name="Request()" element="io.questdb.std.WeakMutableObjectPool::newInstance():io.questdb.std.Mutable" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.log.Logger" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.log.Logger::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.log.Logger::ts():io.questdb.log.LogRecord" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.log.SyncLogger" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.log.SyncLogger::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.log.SyncLogger::ts():io.questdb.log.LogRecord" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.PropServerConfiguration" />
			<role name="State" element="io.questdb.FactoryProviderFactory" />
			<role name="state" element="io.questdb.PropServerConfiguration::fpf:io.questdb.FactoryProviderFactory" />
			<role name="Request()" element="io.questdb.PropServerConfiguration::init(io.questdb.cairo.CairoEngine, io.questdb.griffin.FunctionFactoryCache):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.ServerMain" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.ServerMain::log:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.ServerMain::start(boolean):void" />
		</instance>
		<instance>
			<role name="State" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Context" element="io.questdb.cairo.SymbolMapReaderImpl" />
			<role name="state" element="io.questdb.cairo.SymbolMapReaderImpl::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapReaderImpl::of(io.questdb.cairo.CairoConfiguration, io.questdb.std.str.Path, java.lang.CharSequence, long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor" />
			<role name="State" element="io.questdb.cairo.IndexFrameCursor" />
			<role name="state" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor::indexCursor:io.questdb.cairo.IndexFrameCursor" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.SampleByFirstLastRecordCursorFactory$SampleByFirstLastRecordCursor::getNextState(int):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.SymbolMapWriter" />
			<role name="State" element="io.questdb.cairo.SymbolValueCountCollector" />
			<role name="state" element="io.questdb.cairo.SymbolMapWriter::valueCountCollector:io.questdb.cairo.SymbolValueCountCollector" />
			<role name="Request()" element="io.questdb.cairo.SymbolMapWriter::rollback(int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableNameRegistryRO" />
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="state" element="io.questdb.cairo.TableNameRegistryRO::clockMs:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryRO::getTableToken(java.lang.CharSequence):io.questdb.cairo.TableToken" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryRO::reloadTableNameCache(io.questdb.std.ObjList):void" />
			<role name="Request()" element="io.questdb.cairo.TableNameRegistryRO::reloadTableNameCacheThrottled():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.ops.InsertOperationImpl$InsertMethodImpl" />
			<role name="State" element="io.questdb.cairo.TableWriterAPI" />
			<role name="state" element="io.questdb.griffin.engine.ops.InsertOperationImpl$InsertMethodImpl::writer:io.questdb.cairo.TableWriterAPI" />
			<role name="Request()" element="io.questdb.griffin.engine.ops.InsertOperationImpl$InsertMethodImpl::commit():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.WalWriter" />
			<role name="State" element="io.questdb.cairo.wal.WalInitializer" />
			<role name="state" element="io.questdb.cairo.wal.WalWriter::walInitializer:io.questdb.cairo.wal.WalInitializer" />
			<role name="Request()" element="io.questdb.cairo.wal.WalWriter::createSegmentDir(int):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.SymbolCache" />
			<role name="State" element="io.questdb.cairo.TableWriterAPI" />
			<role name="state" element="io.questdb.cutlass.line.tcp.SymbolCache::writerAPI:io.questdb.cairo.TableWriterAPI" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.SymbolCache::readSymbolCount(int, boolean):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.pool.ReaderPool$R" />
			<role name="State" element="io.questdb.cairo.pool.ReaderPool$ReaderListener" />
			<role name="state" element="io.questdb.cairo.pool.ReaderPool$R::readerListener:io.questdb.cairo.pool.ReaderPool$ReaderListener" />
			<role name="Request()" element="io.questdb.cairo.pool.ReaderPool$R::openPartition(int):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.IntervalBwdDataFrameCursor" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cairo.IntervalBwdDataFrameCursor::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cairo.IntervalBwdDataFrameCursor::next():io.questdb.cairo.sql.DataFrame" />
			<role name="Request()" element="io.questdb.cairo.IntervalBwdDataFrameCursor::skipInterval(int, long):void" />
			<role name="Request()" element="io.questdb.cairo.IntervalBwdDataFrameCursor::skipPartition(int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.SysdateFunctionFactory$Func" />
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.SysdateFunctionFactory$Func::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.SysdateFunctionFactory$Func::getDate(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.ExplainPlanFactory$ExplainPlanRecord" />
			<role name="State" element="io.questdb.griffin.PlanSink" />
			<role name="state" element="io.questdb.griffin.engine.ExplainPlanFactory$ExplainPlanRecord::planSink:io.questdb.griffin.PlanSink" />
			<role name="Request()" element="io.questdb.griffin.engine.ExplainPlanFactory$ExplainPlanRecord::getStr(int):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.engine.ExplainPlanFactory$ExplainPlanRecord::getStr(int, io.questdb.std.str.CharSink):void" />
			<role name="Request()" element="io.questdb.griffin.engine.ExplainPlanFactory$ExplainPlanRecord::getStrLen(int):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor" />
			<role name="State" element="io.questdb.cairo.sql.Function" />
			<role name="state" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor::filter:io.questdb.cairo.sql.Function" />
			<role name="Request()" element="io.questdb.griffin.engine.table.SymbolIndexFilteredRowCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.catalogue.FlushQueryCacheFunctionFactory$FlushQueryCacheFunction" />
			<role name="State" element="io.questdb.MessageBus" />
			<role name="state" element="io.questdb.griffin.engine.functions.catalogue.FlushQueryCacheFunctionFactory$FlushQueryCacheFunction::messageBus:io.questdb.MessageBus" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.FlushQueryCacheFunctionFactory$FlushQueryCacheFunction::getBool(io.questdb.cairo.sql.Record):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker" />
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="state" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker::checkIfTripped(long, int):boolean" />
			<role name="Request()" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker::resetTimer():void" />
			<role name="Request()" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker::testTimeout():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableReader" />
			<role name="State" element="io.questdb.std.FilesFacade" />
			<role name="state" element="io.questdb.cairo.TableReader::ff:io.questdb.std.FilesFacade" />
			<role name="Request()" element="io.questdb.cairo.TableReader::openPartition0(int):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableReader" />
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="state" element="io.questdb.cairo.TableReader::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cairo.TableReader::readTxnSlow(long):void" />
			<role name="Request()" element="io.questdb.cairo.TableReader::reloadMetadata(int, long, boolean):boolean" />
			<role name="Request()" element="io.questdb.cairo.TableReader::reloadSlow(boolean):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl" />
			<role name="State" element="io.questdb.cairo.MemorySerializer" />
			<role name="state" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl::serializer:io.questdb.cairo.MemorySerializer" />
			<role name="Request()" element="io.questdb.cairo.wal.seq.TableTransactionLog$TableMetadataChangeLogImpl::next():io.questdb.cairo.wal.seq.TableMetadataChange" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::findLineEnd():int" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::readKeyId():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::sendChallenge():void" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::waitForResponse():int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator" />
			<role name="State" element="io.questdb.cutlass.auth.PublicKeyRepo" />
			<role name="state" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::publicKeyRepo:io.questdb.cutlass.auth.PublicKeyRepo" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.auth.EllipticCurveAuthenticator::readKeyId():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.JsonQueryProcessor" />
			<role name="State" element="io.questdb.std.NanosecondClock" />
			<role name="state" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::nanosecondClock:io.questdb.std.NanosecondClock" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessor::compileQuery(io.questdb.cutlass.http.processors.JsonQueryProcessorState):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.TextQueryProcessor" />
			<role name="State" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="state" element="io.questdb.cutlass.http.processors.TextQueryProcessor::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextQueryProcessor::header(io.questdb.cutlass.http.HttpChunkedResponseSocket, io.questdb.cutlass.http.processors.TextQueryProcessorState, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="State" element="io.questdb.cutlass.line.LineProtoTimestampAdapter" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::timestampAdapter:io.questdb.cutlass.line.LineProtoTimestampAdapter" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::createNewRow(io.questdb.cutlass.line.udp.CharSequenceCache, int):io.questdb.cairo.TableWriter$Row" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.CompiledQueryImpl" />
			<role name="State" element="io.questdb.cairo.sql.InsertOperation" />
			<role name="state" element="io.questdb.griffin.CompiledQueryImpl::insertOp:io.questdb.cairo.sql.InsertOperation" />
			<role name="Request()" element="io.questdb.griffin.CompiledQueryImpl::execute(io.questdb.griffin.SqlExecutionContext, io.questdb.mp.SCSequence, boolean):io.questdb.cairo.sql.OperationFuture" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.catalogue.DumpThreadStacksFunctionFactory" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.griffin.engine.functions.catalogue.DumpThreadStacksFunctionFactory::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.catalogue.DumpThreadStacksFunctionFactory::dumpThreadStacks():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.model.RuntimeIntervalModel" />
			<role name="State" element="io.questdb.log.Log" />
			<role name="state" element="io.questdb.griffin.model.RuntimeIntervalModel::LOG:io.questdb.log.Log" />
			<role name="Request()" element="io.questdb.griffin.model.RuntimeIntervalModel::toPlan(io.questdb.griffin.PlanSink):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.SqlExecutionContextImpl" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.griffin.SqlExecutionContextImpl::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.griffin.SqlExecutionContextImpl::getMicrosecondTimestamp():long" />
			<role name="Request()" element="io.questdb.griffin.SqlExecutionContextImpl::initNow():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics" />
			<role name="State" element="io.questdb.metrics.CounterWithOneLabel" />
			<role name="state" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics::failedQueriesCounter:io.questdb.metrics.CounterWithOneLabel" />
			<role name="Request()" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics::markSyntaxError():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics" />
			<role name="State" element="io.questdb.metrics.CounterWithTwoLabels" />
			<role name="state" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics::failedCompiledQueriesCounter:io.questdb.metrics.CounterWithTwoLabels" />
			<role name="Request()" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics::markInsertCancelled():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics" />
			<role name="State" element="io.questdb.metrics.LongGauge" />
			<role name="state" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics::runningQueries:io.questdb.metrics.LongGauge" />
			<role name="Request()" element="io.questdb.test.cutlass.http.MetricsIODispatcherTest$TestMetrics::markQueryStart():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.network.IODispatcherWindows" />
			<role name="State" element="io.questdb.network.SelectFacade" />
			<role name="state" element="io.questdb.network.IODispatcherWindows::sf:io.questdb.network.SelectFacade" />
			<role name="Request()" element="io.questdb.network.IODispatcherWindows::runSerially():boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker" />
			<role name="State" element="io.questdb.network.NetworkFacade" />
			<role name="state" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker::nf:io.questdb.network.NetworkFacade" />
			<role name="Request()" element="io.questdb.cairo.sql.NetworkSqlExecutionCircuitBreaker::testConnection(int):boolean" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState" />
			<role name="State" element="io.questdb.std.NanosecondClock" />
			<role name="state" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::nanosecondClock:io.questdb.std.NanosecondClock" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::getExecutionTimeNanos():long" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::logTimings():void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::startExecutionTimer():void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::doQuerySuffix(io.questdb.cutlass.http.HttpChunkedResponseSocket, int):void" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.JsonQueryProcessorState::onNoMoreData():void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cairo.TableWriter" />
			<role name="State" element="io.questdb.std.datetime.DateFormat" />
			<role name="state" element="io.questdb.cairo.TableWriter::partitionDirFmt:io.questdb.std.datetime.DateFormat" />
			<role name="Request()" element="io.questdb.cairo.TableWriter::removePartitionDirsNotAttached(long, int):void" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.griffin.engine.functions.date.OffsetTimestampFunctionFromRules" />
			<role name="State" element="io.questdb.std.datetime.TimeZoneRules" />
			<role name="state" element="io.questdb.griffin.engine.functions.date.OffsetTimestampFunctionFromRules::rules:io.questdb.std.datetime.TimeZoneRules" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.date.OffsetTimestampFunctionFromRules::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.tcp.SymbolCache" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.cutlass.line.tcp.SymbolCache::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cutlass.line.tcp.SymbolCache::keyOf(io.questdb.std.str.DirectByteCharSequence):int" />
		</instance>
		<instance>
			<role name="Context" element="io.questdb.cutlass.line.udp.LineUdpParserImpl" />
			<role name="State" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="state" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Request()" element="io.questdb.cutlass.line.udp.LineUdpParserImpl::createNewRow(io.questdb.cutlass.line.udp.CharSequenceCache, int):io.questdb.cairo.TableWriter$Row" />
		</instance>
	</pattern>
	<pattern name="Strategy">
		<instance>
			<role name="Strategy" element="io.questdb.std.LongLongHashSet$SinkStrategy" />
			<role name="Context" element="io.questdb.std.LongLongHashSet" />
			<role name="strategy" element="io.questdb.std.LongLongHashSet::sinkStrategy:io.questdb.std.LongLongHashSet$SinkStrategy" />
			<role name="ContextInterface()" element="io.questdb.std.LongLongHashSet::toSink(io.questdb.std.str.CharSink):void" />
		</instance>
	</pattern>
	<pattern name="Bridge">
		<instance>
			<role name="Implementor" element="io.questdb.cairo.sql.Function" />
			<role name="Abstraction" element="io.questdb.griffin.engine.functions.date.TimestampCeilFunctionFactory$AbstractTimestampCeilFunction" />
			<role name="implementor" element="io.questdb.griffin.engine.functions.date.TimestampCeilFunctionFactory$AbstractTimestampCeilFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.date.TimestampCeilFunctionFactory$AbstractTimestampCeilFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Implementor" element="io.questdb.cairo.sql.Function" />
			<role name="Abstraction" element="io.questdb.griffin.engine.functions.date.TimestampFloorFunctions$AbstractTimestampFloorFunction" />
			<role name="implementor" element="io.questdb.griffin.engine.functions.date.TimestampFloorFunctions$AbstractTimestampFloorFunction::arg:io.questdb.cairo.sql.Function" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.date.TimestampFloorFunctions$AbstractTimestampFloorFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="Implementor" element="io.questdb.cairo.sql.Function" />
			<role name="Abstraction" element="io.questdb.griffin.engine.functions.str.SplitPartCharFunctionFactory$AbstractSplitPartFunction" />
			<role name="implementor" element="io.questdb.griffin.engine.functions.str.SplitPartCharFunctionFactory$AbstractSplitPartFunction::indexFunc:io.questdb.cairo.sql.Function" />
			<role name="implementor" element="io.questdb.griffin.engine.functions.str.SplitPartCharFunctionFactory$AbstractSplitPartFunction::strFunc:io.questdb.cairo.sql.Function" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.str.SplitPartCharFunctionFactory$AbstractSplitPartFunction::init(io.questdb.cairo.sql.SymbolTableSource, io.questdb.griffin.SqlExecutionContext):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.str.SplitPartCharFunctionFactory$AbstractSplitPartFunction::getStr0(, S, boolean):io.questdb.std.str.CharSink" />
		</instance>
		<instance>
			<role name="Implementor" element="io.questdb.cairo.sql.Function" />
			<role name="Abstraction" element="io.questdb.griffin.engine.functions.str.SplitPartFunctionFactory$AbstractSplitPartFunction" />
			<role name="implementor" element="io.questdb.griffin.engine.functions.str.SplitPartFunctionFactory$AbstractSplitPartFunction::indexFunc:io.questdb.cairo.sql.Function" />
			<role name="implementor" element="io.questdb.griffin.engine.functions.str.SplitPartFunctionFactory$AbstractSplitPartFunction::strFunc:io.questdb.cairo.sql.Function" />
			<role name="implementor" element="io.questdb.griffin.engine.functions.str.SplitPartFunctionFactory$AbstractSplitPartFunction::delimiterFunc:io.questdb.cairo.sql.Function" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.str.SplitPartFunctionFactory$AbstractSplitPartFunction::init(io.questdb.cairo.sql.SymbolTableSource, io.questdb.griffin.SqlExecutionContext):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.functions.str.SplitPartFunctionFactory$AbstractSplitPartFunction::getStr0(, S, boolean):io.questdb.std.str.CharSink" />
		</instance>
		<instance>
			<role name="Implementor" element="io.questdb.cairo.sql.RecordCursor" />
			<role name="Abstraction" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor" />
			<role name="implementor" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor::baseCursor:io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor::of(io.questdb.cairo.sql.RecordCursor, io.questdb.griffin.SqlExecutionContext):void" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor::toTop():void" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor::initTimestamps():void" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor::notKeyedLoop(io.questdb.cairo.map.MapValue):boolean" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor" />
			<role name="Implementor" element="io.questdb.griffin.engine.groupby.GroupByFunctionsUpdater" />
			<role name="implementor" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor::groupByFunctionsUpdater:io.questdb.griffin.engine.groupby.GroupByFunctionsUpdater" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor::notKeyedLoop(io.questdb.cairo.map.MapValue):boolean" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor::updateValueWhenClockMovesBack(io.questdb.cairo.map.MapValue):void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.mp.AbstractQueueConsumerJob" />
			<role name="Implementor" element="io.questdb.mp.Sequence" />
			<role name="implementor" element="io.questdb.mp.AbstractQueueConsumerJob::subSeq:io.questdb.mp.Sequence" />
			<role name="Operation()" element="io.questdb.mp.AbstractQueueConsumerJob::run(int, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="Implementor" element="io.questdb.cairo.CairoConfiguration" />
			<role name="Abstraction" element="io.questdb.cairo.RebuildColumnBase" />
			<role name="implementor" element="io.questdb.cairo.RebuildColumnBase::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Operation()" element="io.questdb.cairo.RebuildColumnBase::reindex(io.questdb.std.FilesFacade, java.lang.CharSequence, java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="Implementor" element="io.questdb.log.Log" />
			<role name="Abstraction" element="io.questdb.cutlass.text.AbstractTextLexer" />
			<role name="implementor" element="io.questdb.cutlass.text.AbstractTextLexer::LOG:io.questdb.log.Log" />
			<role name="Operation()" element="io.questdb.cutlass.text.AbstractTextLexer::parseLast():void" />
			<role name="Operation()" element="io.questdb.cutlass.text.AbstractTextLexer::extraField(int):void" />
			<role name="Operation()" element="io.questdb.cutlass.text.AbstractTextLexer::growRollBuf(int, boolean):boolean" />
		</instance>
		<instance>
			<role name="Implementor" element="io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Abstraction" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory" />
			<role name="implementor" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Implementor" element="io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Abstraction" element="io.questdb.griffin.engine.table.AbstractTreeSetRecordCursorFactory" />
			<role name="implementor" element="io.questdb.griffin.engine.table.AbstractTreeSetRecordCursorFactory::cursor:io.questdb.griffin.engine.table.DataFrameRecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.AbstractTreeSetRecordCursorFactory::getCursorInstance(io.questdb.cairo.sql.DataFrameCursor, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver" />
			<role name="Implementor" element="io.questdb.log.Log" />
			<role name="implementor" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver::LOG:io.questdb.log.Log" />
			<role name="Operation()" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver::close():void" />
			<role name="Operation()" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver::logStarted(io.questdb.cutlass.line.udp.LineUdpReceiverConfiguration):void" />
			<role name="Operation()" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver::lambda$start$0():void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.network.AbstractIODispatcher" />
			<role name="Implementor" element="io.questdb.log.Log" />
			<role name="implementor" element="io.questdb.network.AbstractIODispatcher::LOG:io.questdb.log.Log" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::disconnect(C, int):void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::registerChannel(C, int):void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::addPending(int, long):void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::createListenFd():void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::disconnectContext(io.questdb.network.IOEvent):void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::accept(long):void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::doDisconnect(C, int):void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::processDisconnects(long):void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::publishOperation(int, C):void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.cutlass.text.AbstractTextLexer" />
			<role name="Implementor" element="io.questdb.cutlass.text.AbstractTextLexer$Listener" />
			<role name="implementor" element="io.questdb.cutlass.text.AbstractTextLexer::textLexerListener:io.questdb.cutlass.text.AbstractTextLexer$Listener" />
			<role name="Operation()" element="io.questdb.cutlass.text.AbstractTextLexer::triggerLine(long):void" />
		</instance>
		<instance>
			<role name="Implementor" element="io.questdb.cairo.sql.Function" />
			<role name="Abstraction" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory" />
			<role name="implementor" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory::symbolFunc:io.questdb.cairo.sql.Function" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory::lookupDeferredSymbol(io.questdb.cairo.sql.DataFrameCursor):boolean" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursor" />
			<role name="Implementor" element="io.questdb.cairo.sql.DataFrameCursor" />
			<role name="implementor" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursor::dataFrameCursor:io.questdb.cairo.sql.DataFrameCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursor::getSymbolTable(int):io.questdb.cairo.sql.StaticSymbolTable" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursor::newSymbolTable(int):io.questdb.cairo.sql.SymbolTable" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver" />
			<role name="Implementor" element="io.questdb.network.NetworkFacade" />
			<role name="implementor" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver::nf:io.questdb.network.NetworkFacade" />
			<role name="Operation()" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver::close():void" />
			<role name="Operation()" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver::bind(io.questdb.cutlass.line.udp.LineUdpReceiverConfiguration):void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.network.AbstractIODispatcher" />
			<role name="Implementor" element="io.questdb.network.NetworkFacade" />
			<role name="implementor" element="io.questdb.network.AbstractIODispatcher::nf:io.questdb.network.NetworkFacade" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::close():void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::createListenFd():void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::accept(long):void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::doDisconnect(C, int):void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::processDisconnects(long):void" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::testConnection(int):boolean" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.network.AbstractIODispatcher" />
			<role name="Implementor" element="io.questdb.network.IODispatcherConfiguration" />
			<role name="implementor" element="io.questdb.network.AbstractIODispatcher::configuration:io.questdb.network.IODispatcherConfiguration" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::createListenFd():void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor" />
			<role name="Implementor" element="io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="implementor" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor::circuitBreaker:io.questdb.cairo.sql.SqlExecutionCircuitBreaker" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.AbstractNoRecordSampleByCursor::notKeyedLoop(io.questdb.cairo.map.MapValue):boolean" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.test.AbstractCairoTest" />
			<role name="Implementor" element="io.questdb.cairo.CairoConfiguration" />
			<role name="implementor" element="io.questdb.test.AbstractCairoTest::configuration:io.questdb.cairo.CairoConfiguration" />
			<role name="Operation()" element="io.questdb.test.AbstractCairoTest::setUpStatic():void" />
			<role name="Operation()" element="io.questdb.test.AbstractCairoTest::replicate(java.lang.String, java.lang.String, io.questdb.test.QuestDBTestNode, io.questdb.test.QuestDBTestNode):void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursorFactory" />
			<role name="Implementor" element="io.questdb.cairo.sql.DataFrameCursorFactory" />
			<role name="implementor" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursorFactory::dataFrameCursorFactory:io.questdb.cairo.sql.DataFrameCursorFactory" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursorFactory::getBaseColumnName(int):java.lang.String" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursorFactory::getCursor(io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
			<role name="Operation()" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursorFactory::supportsUpdateRowId(io.questdb.cairo.TableToken):boolean" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.griffin.engine.groupby.AbstractSampleByCursor" />
			<role name="Implementor" element="io.questdb.cairo.sql.Function" />
			<role name="implementor" element="io.questdb.griffin.engine.groupby.AbstractSampleByCursor::timezoneNameFunc:io.questdb.cairo.sql.Function" />
			<role name="implementor" element="io.questdb.griffin.engine.groupby.AbstractSampleByCursor::offsetFunc:io.questdb.cairo.sql.Function" />
			<role name="Operation()" element="io.questdb.griffin.engine.groupby.AbstractSampleByCursor::parseParams(io.questdb.cairo.sql.RecordCursor, io.questdb.griffin.SqlExecutionContext):void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver" />
			<role name="Implementor" element="io.questdb.cutlass.line.udp.LineUdpReceiverConfiguration" />
			<role name="implementor" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver::configuration:io.questdb.cutlass.line.udp.LineUdpReceiverConfiguration" />
			<role name="Operation()" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver::start():void" />
			<role name="Operation()" element="io.questdb.cutlass.line.udp.AbstractLineProtoUdpReceiver::lambda$start$0():void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.network.AbstractIODispatcher" />
			<role name="Implementor" element="io.questdb.network.IOContextFactory" />
			<role name="implementor" element="io.questdb.network.AbstractIODispatcher::ioContextFactory:io.questdb.network.IOContextFactory" />
			<role name="Operation()" element="io.questdb.network.AbstractIODispatcher::addPending(int, long):void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.test.AbstractCairoTest" />
			<role name="Implementor" element="io.questdb.log.Log" />
			<role name="implementor" element="io.questdb.test.AbstractCairoTest::LOG:io.questdb.log.Log" />
			<role name="Operation()" element="io.questdb.test.AbstractCairoTest::tearDown(boolean):void" />
			<role name="Operation()" element="io.questdb.test.AbstractCairoTest::dumpMemoryUsage():void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.cairo.pool.AbstractMultiTenantPool" />
			<role name="Implementor" element="io.questdb.log.Log" />
			<role name="implementor" element="io.questdb.cairo.pool.AbstractMultiTenantPool::LOG:io.questdb.log.Log" />
			<role name="Operation()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::get(io.questdb.cairo.TableToken):io.questdb.cairo.pool.PoolTenant" />
			<role name="Operation()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::lock(io.questdb.cairo.TableToken):boolean" />
			<role name="Operation()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::unlock(io.questdb.cairo.TableToken):void" />
			<role name="Operation()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::checkClosed():void" />
			<role name="Operation()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::closeTenant(long, io.questdb.cairo.pool.AbstractMultiTenantPool$Entry, int, short, int):void" />
			<role name="Operation()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::closePool():void" />
			<role name="Operation()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::expelFromPool(T):void" />
			<role name="Operation()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::releaseAll(long):boolean" />
			<role name="Operation()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::returnToPool(T):boolean" />
		</instance>
		<instance>
			<role name="Implementor" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Abstraction" element="io.questdb.cairo.RebuildColumnBase" />
			<role name="implementor" element="io.questdb.cairo.RebuildColumnBase::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Operation()" element="io.questdb.cairo.RebuildColumnBase::reindex(io.questdb.std.FilesFacade, java.lang.CharSequence, java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.test.cutlass.line.tcp.BaseLineTcpContextTest" />
			<role name="Implementor" element="io.questdb.cutlass.line.tcp.LineTcpReceiverConfiguration" />
			<role name="implementor" element="io.questdb.test.cutlass.line.tcp.BaseLineTcpContextTest::lineTcpConfiguration:io.questdb.cutlass.line.tcp.LineTcpReceiverConfiguration" />
			<role name="Operation()" element="io.questdb.test.cutlass.line.tcp.BaseLineTcpContextTest::waitForIOCompletion():void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.cutlass.line.AbstractLineSender" />
			<role name="Implementor" element="io.questdb.cutlass.line.LineChannel" />
			<role name="implementor" element="io.questdb.cutlass.line.AbstractLineSender::lineChannel:io.questdb.cutlass.line.LineChannel" />
			<role name="Operation()" element="io.questdb.cutlass.line.AbstractLineSender::receiveChallengeBytes():byte[]" />
			<role name="Operation()" element="io.questdb.cutlass.line.AbstractLineSender::sendLine():void" />
			<role name="Operation()" element="io.questdb.cutlass.line.AbstractLineSender::sendAll():void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.test.AbstractGriffinTest" />
			<role name="Implementor" element="io.questdb.griffin.SqlExecutionContext" />
			<role name="implementor" element="io.questdb.test.AbstractGriffinTest::sqlExecutionContext:io.questdb.griffin.SqlExecutionContext" />
			<role name="Operation()" element="io.questdb.test.AbstractGriffinTest::setUp():void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.cairo.pool.AbstractPool" />
			<role name="Implementor" element="io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="implementor" element="io.questdb.cairo.pool.AbstractPool::clock:io.questdb.std.datetime.microtime.MicrosecondClock" />
			<role name="Operation()" element="io.questdb.cairo.pool.AbstractPool::releaseInactive():boolean" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.test.cutlass.line.udp.LineUdpInsertTest" />
			<role name="Implementor" element="io.questdb.cutlass.line.udp.LineUdpReceiverConfiguration" />
			<role name="implementor" element="io.questdb.test.cutlass.line.udp.LineUdpInsertTest::RCVR_CONF:io.questdb.cutlass.line.udp.LineUdpReceiverConfiguration" />
			<role name="Operation()" element="io.questdb.test.cutlass.line.udp.LineUdpInsertTest::&lt;clinit&gt;():void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.WorkerPoolManager" />
			<role name="Implementor" element="io.questdb.log.Log" />
			<role name="implementor" element="io.questdb.WorkerPoolManager::LOG:io.questdb.log.Log" />
			<role name="Operation()" element="io.questdb.WorkerPoolManager::getInstance(io.questdb.mp.WorkerPoolConfiguration, io.questdb.metrics.HealthMetrics, io.questdb.WorkerPoolManager$Requester):io.questdb.mp.WorkerPool" />
			<role name="Operation()" element="io.questdb.WorkerPoolManager::halt():void" />
			<role name="Operation()" element="io.questdb.WorkerPoolManager::start(io.questdb.log.Log):void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.cairo.AbstractIndexReader" />
			<role name="Implementor" element="io.questdb.log.Log" />
			<role name="implementor" element="io.questdb.cairo.AbstractIndexReader::LOG:io.questdb.log.Log" />
			<role name="Operation()" element="io.questdb.cairo.AbstractIndexReader::of(io.questdb.cairo.CairoConfiguration, io.questdb.std.str.Path, java.lang.CharSequence, long, long):void" />
			<role name="Operation()" element="io.questdb.cairo.AbstractIndexReader::updateKeyCount():void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.cairo.AbstractIndexReader" />
			<role name="Implementor" element="io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="implementor" element="io.questdb.cairo.AbstractIndexReader::clock:io.questdb.std.datetime.millitime.MillisecondClock" />
			<role name="Operation()" element="io.questdb.cairo.AbstractIndexReader::of(io.questdb.cairo.CairoConfiguration, io.questdb.std.str.Path, java.lang.CharSequence, long, long):void" />
			<role name="Operation()" element="io.questdb.cairo.AbstractIndexReader::updateKeyCount():void" />
		</instance>
		<instance>
			<role name="Abstraction" element="io.questdb.cairo.AbstractIntervalDataFrameCursor" />
			<role name="Implementor" element="io.questdb.griffin.model.RuntimeIntrinsicIntervalModel" />
			<role name="implementor" element="io.questdb.cairo.AbstractIntervalDataFrameCursor::intervalsModel:io.questdb.griffin.model.RuntimeIntrinsicIntervalModel" />
			<role name="Operation()" element="io.questdb.cairo.AbstractIntervalDataFrameCursor::of(io.questdb.cairo.TableReader, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.AbstractIntervalDataFrameCursor" />
		</instance>
	</pattern>
	<pattern name="Template Method">
		<instance>
			<role name="AbstractClass" element="io.questdb.network.AbstractIODispatcher" />
			<role name="TemplateMethod()" element="io.questdb.network.AbstractIODispatcher::addPending(int, long):void" />
			<role name="TemplateMethod()" element="io.questdb.network.AbstractIODispatcher::accept(long):void" />
			<role name="TemplateMethod()" element="io.questdb.network.AbstractIODispatcher::doDisconnect(C, int):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.network.SuspendEvent" />
			<role name="TemplateMethod()" element="io.questdb.network.SuspendEvent::close():void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.std.AbstractLowerCaseAsciiCharSequenceHashSet" />
			<role name="TemplateMethod()" element="io.questdb.std.AbstractLowerCaseAsciiCharSequenceHashSet::removeAt(int):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.std.WeakObjectPoolBase" />
			<role name="TemplateMethod()" element="io.questdb.std.WeakObjectPoolBase::pop():java.lang.Object" />
			<role name="TemplateMethod()" element="io.questdb.std.WeakObjectPoolBase::fill():void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.std.ConcurrentHashMap$CollectionView" />
			<role name="TemplateMethod()" element="io.questdb.std.ConcurrentHashMap$CollectionView::containsAll(java.util.Collection):boolean" />
			<role name="TemplateMethod()" element="io.questdb.std.ConcurrentHashMap$CollectionView::removeAll(java.util.Collection):boolean" />
			<role name="TemplateMethod()" element="io.questdb.std.ConcurrentHashMap$CollectionView::retainAll(java.util.Collection):boolean" />
			<role name="TemplateMethod()" element="io.questdb.std.ConcurrentHashMap$CollectionView::toArray():java.lang.Object[]" />
			<role name="TemplateMethod()" element="io.questdb.std.ConcurrentHashMap$CollectionView::toString():java.lang.String" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.std.AbstractLowerCaseCharSequenceHashMap" />
			<role name="TemplateMethod()" element="io.questdb.std.AbstractLowerCaseCharSequenceHashMap::putAt0(int, java.lang.CharSequence):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.std.AbstractIntHashSet" />
			<role name="TemplateMethod()" element="io.questdb.std.AbstractIntHashSet::removeAt(int):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.std.AbstractLowerCaseCharSequenceHashSet" />
			<role name="TemplateMethod()" element="io.questdb.std.AbstractLowerCaseCharSequenceHashSet::removeAt(int):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.std.AbstractCharSequenceHashSet" />
			<role name="TemplateMethod()" element="io.questdb.std.AbstractCharSequenceHashSet::removeAt(int):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.std.AbstractLongHashSet" />
			<role name="TemplateMethod()" element="io.questdb.std.AbstractLongHashSet::removeAt(int):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.std.datetime.AbstractTimeZoneRules" />
			<role name="TemplateMethod()" element="io.questdb.std.datetime.AbstractTimeZoneRules::getNextDST(long):long" />
			<role name="TemplateMethod()" element="io.questdb.std.datetime.AbstractTimeZoneRules::getOffset(long):long" />
			<role name="TemplateMethod()" element="io.questdb.std.datetime.AbstractTimeZoneRules::dstFromRules(long, int, boolean):long" />
			<role name="TemplateMethod()" element="io.questdb.std.datetime.AbstractTimeZoneRules::getDSTFromRule(int, boolean, int):long" />
			<role name="TemplateMethod()" element="io.questdb.std.datetime.AbstractTimeZoneRules::offsetFromRules(long, int, boolean):long" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.cutlass.text.AbstractTextLexer" />
			<role name="TemplateMethod()" element="io.questdb.cutlass.text.AbstractTextLexer::parseExactLines(long, long):void" />
			<role name="TemplateMethod()" element="io.questdb.cutlass.text.AbstractTextLexer::parse0(long, long):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.mp.AbstractQueueConsumerJob" />
			<role name="TemplateMethod()" element="io.questdb.mp.AbstractQueueConsumerJob::run(int, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.mp.SynchronizedJob" />
			<role name="TemplateMethod()" element="io.questdb.mp.SynchronizedJob::run(int, io.questdb.mp.Job$RunStatus):boolean" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.cairo.map.FastMap$BaseKey" />
			<role name="TemplateMethod()" element="io.questdb.cairo.map.FastMap$BaseKey::createValue(io.questdb.cairo.map.FastMapValue):io.questdb.cairo.map.MapValue" />
			<role name="TemplateMethod()" element="io.questdb.cairo.map.FastMap$BaseKey::findValue(io.questdb.cairo.map.FastMapValue):io.questdb.cairo.map.MapValue" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.cairo.pool.AbstractMultiTenantPool" />
			<role name="TemplateMethod()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::get(io.questdb.cairo.TableToken):io.questdb.cairo.pool.PoolTenant" />
			<role name="TemplateMethod()" element="io.questdb.cairo.pool.AbstractMultiTenantPool::notifyListener(long, io.questdb.cairo.TableToken, short, int, int):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.cairo.pool.AbstractPool" />
			<role name="TemplateMethod()" element="io.questdb.cairo.pool.AbstractPool::releaseAll():boolean" />
			<role name="TemplateMethod()" element="io.questdb.cairo.pool.AbstractPool::releaseInactive():boolean" />
			<role name="TemplateMethod()" element="io.questdb.cairo.pool.AbstractPool::closePool():void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.cairo.RebuildColumnBase" />
			<role name="TemplateMethod()" element="io.questdb.cairo.RebuildColumnBase::reindexAfterUpdate(io.questdb.std.FilesFacade, long, java.lang.CharSequence, io.questdb.cairo.TableWriter):void" />
			<role name="TemplateMethod()" element="io.questdb.cairo.RebuildColumnBase::reindexColumn(io.questdb.std.FilesFacade, io.questdb.cairo.ColumnVersionReader, io.questdb.cairo.sql.RecordMetadata, int, long, long, int, long):void" />
			<role name="TemplateMethod()" element="io.questdb.cairo.RebuildColumnBase::reindexOneOrAllColumns(io.questdb.std.FilesFacade, io.questdb.cairo.sql.RecordMetadata, io.questdb.cairo.ColumnVersionReader, int, int, long, long, long):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.ops.OperationDispatcher" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.ops.OperationDispatcher::execute(T, io.questdb.griffin.SqlExecutionContext, io.questdb.mp.SCSequence, boolean):io.questdb.cairo.sql.OperationFuture" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.union.AbstractSetRecordCursorFactory" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.union.AbstractSetRecordCursorFactory::toPlan(io.questdb.griffin.PlanSink):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.groupby.AbstractSampleByRecordCursorFactory" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.groupby.AbstractSampleByRecordCursorFactory::initFunctionsAndCursor(io.questdb.griffin.SqlExecutionContext, io.questdb.cairo.sql.RecordCursor):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.table.AbstractDescendingRecordListCursor" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.table.AbstractDescendingRecordListCursor::hasNext():boolean" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.table.AbstractDeferredValueRecordCursorFactory::lookupDeferredSymbol(io.questdb.cairo.sql.DataFrameCursor):boolean" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursorFactory" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.table.AbstractDataFrameRecordCursorFactory::getCursor(io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.RecordCursor" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.functions.eq.EqGeoHashGeoHashFunctionFactory$ConstCheckFunc" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.functions.eq.EqGeoHashGeoHashFunctionFactory$ConstCheckFunc::toPlan(io.questdb.griffin.PlanSink):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.functions.date.TimestampCeilFunctionFactory$AbstractTimestampCeilFunction" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.functions.date.TimestampCeilFunctionFactory$AbstractTimestampCeilFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.functions.date.TimestampFloorFunctions$AbstractTimestampFloorFunction" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.functions.date.TimestampFloorFunctions$AbstractTimestampFloorFunction::getTimestamp(io.questdb.cairo.sql.Record):long" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.functions.date.TimestampFloorFunctions$AbstractTimestampFloorFunction::toPlan(io.questdb.griffin.PlanSink):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.functions.str.SplitPartFunctionFactory$AbstractSplitPartFunction" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.functions.str.SplitPartFunctionFactory$AbstractSplitPartFunction::getStr0(, S, boolean):io.questdb.std.str.CharSink" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.functions.str.SplitPartCharFunctionFactory$AbstractSplitPartFunction" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.functions.str.SplitPartCharFunctionFactory$AbstractSplitPartFunction::getStr0(, S, boolean):io.questdb.std.str.CharSink" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.functions.regex.AbstractLikeStrFunctionFactory" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.functions.regex.AbstractLikeStrFunctionFactory::newInstance(int, io.questdb.std.ObjList, io.questdb.std.IntList, io.questdb.cairo.CairoConfiguration, io.questdb.griffin.SqlExecutionContext):io.questdb.cairo.sql.Function" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$AbstractCastGeoByteToStrFunction" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$AbstractCastGeoByteToStrFunction::getStr(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$AbstractCastGeoByteToStrFunction::getStrB(io.questdb.cairo.sql.Record):java.lang.CharSequence" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.functions.cast.CastGeoHashToGeoHashFunctionFactory$AbstractCastGeoByteToStrFunction::toSink(long, io.questdb.std.str.StringSink):io.questdb.std.str.StringSink" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.griffin.engine.functions.cast.AbstractCastToSymbolFunction" />
			<role name="TemplateMethod()" element="io.questdb.griffin.engine.functions.cast.AbstractCastToSymbolFunction::newSymbolTable():io.questdb.cairo.sql.SymbolTable" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverFuzzTest" />
			<role name="TemplateMethod()" element="io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverFuzzTest::setUp2():void" />
			<role name="TemplateMethod()" element="io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverFuzzTest::assertTable(io.questdb.test.cutlass.line.tcp.load.TableData):void" />
			<role name="TemplateMethod()" element="io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverFuzzTest::checkTable(io.questdb.test.cutlass.line.tcp.load.TableData):boolean" />
			<role name="TemplateMethod()" element="io.questdb.test.cutlass.line.tcp.AbstractLineTcpReceiverFuzzTest::lambda$runTest$2(io.questdb.cairo.pool.PoolListener, io.questdb.cutlass.line.tcp.LineTcpReceiver):void" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.test.cairo.TestFilesFacade" />
			<role name="TemplateMethod()" element="io.questdb.test.cairo.TestFilesFacade::called():int" />
		</instance>
		<instance>
			<role name="AbstractClass" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest" />
			<role name="TemplateMethod()" element="io.questdb.test.griffin.engine.AbstractFunctionFactoryTest::getFactory0():io.questdb.griffin.FunctionFactory" />
		</instance>
	</pattern>
	<pattern name="Visitor" />
	<pattern name="Proxy">
		<instance>
			<role name="RealSubject" element="io.questdb.std.ObjList" />
			<role name="Proxy" element="io.questdb.griffin.model.InsertModel" />
			<role name="Request()" element="io.questdb.griffin.model.InsertModel::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.ObjList" />
			<role name="Proxy" element="io.questdb.griffin.model.QueryModel" />
			<role name="Request()" element="io.questdb.griffin.model.QueryModel::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.ObjList" />
			<role name="Proxy" element="io.questdb.griffin.model.CreateTableModel" />
			<role name="Request()" element="io.questdb.griffin.model.CreateTableModel::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.ObjList" />
			<role name="Proxy" element="io.questdb.griffin.model.AnalyticColumn" />
			<role name="Request()" element="io.questdb.griffin.model.AnalyticColumn::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.ObjList" />
			<role name="Proxy" element="io.questdb.cutlass.text.ParallelCsvFileImporter" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.ObjList" />
			<role name="Proxy" element="io.questdb.griffin.WhereClauseParser" />
			<role name="Request()" element="io.questdb.griffin.WhereClauseParser::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.ObjList" />
			<role name="Proxy" element="io.questdb.cutlass.text.TextMetadataDetector" />
			<role name="Request()" element="io.questdb.cutlass.text.TextMetadataDetector::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.ObjList" />
			<role name="Proxy" element="io.questdb.griffin.model.JoinContext" />
			<role name="Request()" element="io.questdb.griffin.model.JoinContext::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.IntList" />
			<role name="Proxy" element="io.questdb.cutlass.text.ParallelCsvFileImporter" />
			<role name="Request()" element="io.questdb.cutlass.text.ParallelCsvFileImporter::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.IntList" />
			<role name="Proxy" element="io.questdb.griffin.model.QueryModel" />
			<role name="Request()" element="io.questdb.griffin.model.QueryModel::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.IntList" />
			<role name="Proxy" element="io.questdb.griffin.WhereClauseParser" />
			<role name="Request()" element="io.questdb.griffin.WhereClauseParser::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.IntList" />
			<role name="Proxy" element="io.questdb.cutlass.text.TextMetadataDetector" />
			<role name="Request()" element="io.questdb.cutlass.text.TextMetadataDetector::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.IntList" />
			<role name="Proxy" element="io.questdb.griffin.model.InsertModel" />
			<role name="Request()" element="io.questdb.griffin.model.InsertModel::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.IntList" />
			<role name="Proxy" element="io.questdb.cutlass.text.CairoTextWriter" />
			<role name="Request()" element="io.questdb.cutlass.text.CairoTextWriter::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.IntList" />
			<role name="Proxy" element="io.questdb.griffin.model.JoinContext" />
			<role name="Request()" element="io.questdb.griffin.model.JoinContext::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.std.MemoryPages" />
			<role name="Proxy" element="io.questdb.griffin.engine.orderby.RecordTreeChain" />
			<role name="Request()" element="io.questdb.griffin.engine.orderby.RecordTreeChain::clear():void" />
			<role name="Request()" element="io.questdb.griffin.engine.orderby.RecordTreeChain::reopen():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.cairo.vm.api.MemoryCR$ByteSequenceView" />
			<role name="Proxy" element="io.questdb.cairo.vm.AbstractMemoryCR" />
			<role name="Request()" element="io.questdb.cairo.vm.AbstractMemoryCR::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.cairo.vm.api.MemoryCR$CharSequenceView" />
			<role name="Proxy" element="io.questdb.cairo.vm.AbstractMemoryCR" />
			<role name="Request()" element="io.questdb.cairo.vm.AbstractMemoryCR::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.cairo.BitmapIndexWriter" />
			<role name="Proxy" element="io.questdb.cairo.SymbolColumnIndexer" />
			<role name="Request()" element="io.questdb.cairo.SymbolColumnIndexer::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.cairo.SymbolColumnIndexer" />
			<role name="Proxy" element="io.questdb.cairo.IndexBuilder" />
			<role name="Request()" element="io.questdb.cairo.IndexBuilder::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.cutlass.text.TextLoader" />
			<role name="Proxy" element="io.questdb.cutlass.text.TextMetadataDetector" />
			<role name="Request()" element="io.questdb.cutlass.text.TextLoader::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.cutlass.text.TextLoader" />
			<role name="Proxy" element="io.questdb.cutlass.text.CairoTextWriter" />
			<role name="Request()" element="io.questdb.cutlass.text.TextLoader::clear():void" />
		</instance>
		<instance>
			<role name="RealSubject" element="io.questdb.cutlass.text.TextLoader" />
			<role name="Proxy" element="io.questdb.cutlass.http.processors.TextImportProcessorState" />
			<role name="Request()" element="io.questdb.cutlass.http.processors.TextImportProcessorState::clear():void" />
		</instance>
		<instance>
			<role name="Proxy" element="io.questdb.cutlass.pgwire.PGConnectionContext" />
			<role name="RealSubject" element="io.questdb.cairo.CairoEngine" />
			<role name="Request()" element="io.questdb.cutlass.pgwire.PGConnectionContext::getTableWriterAPI(io.questdb.cairo.TableToken, java.lang.String):io.questdb.cairo.TableWriterAPI" />
		</instance>
		<instance>
			<role name="Proxy" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor" />
			<role name="RealSubject" element="io.questdb.cairo.RecordChain" />
			<role name="Request()" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor::getRecord():io.questdb.cairo.sql.Record" />
			<role name="Request()" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor::getRecordB():io.questdb.cairo.sql.Record" />
			<role name="Request()" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor::hasNext():boolean" />
			<role name="Request()" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor::recordAt(io.questdb.cairo.sql.Record, long):void" />
			<role name="Request()" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor::size():long" />
			<role name="Request()" element="io.questdb.griffin.engine.analytic.CachedAnalyticRecordCursorFactory$CachedAnalyticRecordCursor::toTop():void" />
		</instance>
		<instance>
			<role name="Proxy" element="io.questdb.griffin.engine.groupby.DistinctKeyRecordCursorFactory" />
			<role name="RealSubject" element="io.questdb.griffin.engine.groupby.vect.GroupByRecordCursorFactory" />
			<role name="Request()" element="io.questdb.griffin.engine.groupby.DistinctKeyRecordCursorFactory::recordCursorSupportsRandomAccess():boolean" />
		</instance>
		<instance>
			<role name="Proxy" element="io.questdb.griffin.engine.functions.constants.Long256Constant" />
			<role name="RealSubject" element="io.questdb.std.Long256Impl" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.constants.Long256Constant::getLong0():long" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.constants.Long256Constant::getLong1():long" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.constants.Long256Constant::getLong2():long" />
			<role name="Request()" element="io.questdb.griffin.engine.functions.constants.Long256Constant::getLong3():long" />
		</instance>
		<instance>
			<role name="Proxy" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter" />
			<role name="RealSubject" element="io.questdb.griffin.model.CreateTableModel" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getColumnCount():int" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getColumnName(int):java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getIndexBlockCapacity(int):int" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getMaxUncommittedRows():int" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getO3MaxLag():long" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getPartitionBy():int" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getSymbolCacheFlag(int):boolean" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getSymbolCapacity(int):int" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::getTableName():java.lang.CharSequence" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::isIndexed(int):boolean" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::isSequential(int):boolean" />
			<role name="Request()" element="io.questdb.griffin.SqlCompiler$TableStructureAdapter::isWalEnabled():boolean" />
		</instance>
		<instance>
			<role name="Proxy" element="io.questdb.griffin.model.CreateTableModel" />
			<role name="RealSubject" element="io.questdb.griffin.model.QueryModel" />
			<role name="Request()" element="io.questdb.griffin.model.CreateTableModel::toSink(io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Proxy" element="io.questdb.griffin.model.InsertModel" />
			<role name="RealSubject" element="io.questdb.griffin.model.QueryModel" />
			<role name="Request()" element="io.questdb.griffin.model.InsertModel::toSink(io.questdb.std.str.CharSink):void" />
		</instance>
		<instance>
			<role name="Proxy" element="io.questdb.Metrics" />
			<role name="RealSubject" element="io.questdb.metrics.GCMetrics" />
			<role name="Request()" element="io.questdb.Metrics::scrapeIntoPrometheus(io.questdb.std.str.CharSink):void" />
		</instance>
	</pattern>
	<pattern name="Proxy2">
		<instance>
			<role name="Proxy" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry" />
			<role name="RealSubject" element="io.questdb.metrics.NullMetricsRegistry" />
			<role name="Subject" element="io.questdb.metrics.MetricsRegistry" />
			<role name="subject" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::delegate:io.questdb.metrics.MetricsRegistry" />
			<role name="Request()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::addScrapable(io.questdb.metrics.Scrapable):void" />
			<role name="Request()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newCounter(java.lang.CharSequence):io.questdb.metrics.Counter" />
			<role name="Request()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newCounter(java.lang.CharSequence, java.lang.CharSequence, java.lang.CharSequence[]):io.questdb.metrics.CounterWithOneLabel" />
			<role name="Request()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newCounter(java.lang.CharSequence, java.lang.CharSequence, java.lang.CharSequence[], java.lang.CharSequence, java.lang.CharSequence[]):io.questdb.metrics.CounterWithTwoLabels" />
			<role name="Request()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newDoubleGauge(java.lang.CharSequence):io.questdb.metrics.DoubleGauge" />
			<role name="Request()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newLongGauge(java.lang.CharSequence):io.questdb.metrics.LongGauge" />
			<role name="Request()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newLongGauge(int):io.questdb.metrics.LongGauge" />
			<role name="Request()" element="io.questdb.test.MetricsTest$SpyingMetricsRegistry::newVirtualGauge(java.lang.CharSequence, io.questdb.metrics.VirtualLongGauge$StatProvider):io.questdb.metrics.LongGauge" />
		</instance>
	</pattern>
	<pattern name="Chain of Responsibility" />
</system>

